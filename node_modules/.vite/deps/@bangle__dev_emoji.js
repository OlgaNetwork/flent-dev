import {
  domSerializationHelpers
} from "./chunk-HNOPRNJR.js";
import "./chunk-F3Z2TPKG.js";
import "./chunk-ZRMAPHIN.js";
import "./chunk-NVKSN2QT.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// ../../../../Users/ted/.yarn/berry/cache/markdown-it-emoji-npm-2.0.2-b64d35b1cb-10c0.zip/node_modules/markdown-it-emoji/lib/render.js
var require_render = __commonJS({
  "../../../../Users/ted/.yarn/berry/cache/markdown-it-emoji-npm-2.0.2-b64d35b1cb-10c0.zip/node_modules/markdown-it-emoji/lib/render.js"(exports, module) {
    "use strict";
    module.exports = function emoji_html(tokens, idx) {
      return tokens[idx].content;
    };
  }
});

// ../../../../Users/ted/.yarn/berry/cache/markdown-it-emoji-npm-2.0.2-b64d35b1cb-10c0.zip/node_modules/markdown-it-emoji/lib/replace.js
var require_replace = __commonJS({
  "../../../../Users/ted/.yarn/berry/cache/markdown-it-emoji-npm-2.0.2-b64d35b1cb-10c0.zip/node_modules/markdown-it-emoji/lib/replace.js"(exports, module) {
    "use strict";
    module.exports = function create_rule(md, emojies, shortcuts, scanRE, replaceRE) {
      var arrayReplaceAt = md.utils.arrayReplaceAt, ucm = md.utils.lib.ucmicro, ZPCc = new RegExp([ucm.Z.source, ucm.P.source, ucm.Cc.source].join("|"));
      function splitTextToken(text, level, Token) {
        var token, last_pos = 0, nodes = [];
        text.replace(replaceRE, function(match, offset, src) {
          var emoji_name;
          if (shortcuts.hasOwnProperty(match)) {
            emoji_name = shortcuts[match];
            if (offset > 0 && !ZPCc.test(src[offset - 1])) {
              return;
            }
            if (offset + match.length < src.length && !ZPCc.test(src[offset + match.length])) {
              return;
            }
          } else {
            emoji_name = match.slice(1, -1);
          }
          if (offset > last_pos) {
            token = new Token("text", "", 0);
            token.content = text.slice(last_pos, offset);
            nodes.push(token);
          }
          token = new Token("emoji", "", 0);
          token.markup = emoji_name;
          token.content = emojies[emoji_name];
          nodes.push(token);
          last_pos = offset + match.length;
        });
        if (last_pos < text.length) {
          token = new Token("text", "", 0);
          token.content = text.slice(last_pos);
          nodes.push(token);
        }
        return nodes;
      }
      return function emoji_replace(state) {
        var i, j, l, tokens, token, blockTokens = state.tokens, autolinkLevel = 0;
        for (j = 0, l = blockTokens.length; j < l; j++) {
          if (blockTokens[j].type !== "inline") {
            continue;
          }
          tokens = blockTokens[j].children;
          for (i = tokens.length - 1; i >= 0; i--) {
            token = tokens[i];
            if (token.type === "link_open" || token.type === "link_close") {
              if (token.info === "auto") {
                autolinkLevel -= token.nesting;
              }
            }
            if (token.type === "text" && autolinkLevel === 0 && scanRE.test(token.content)) {
              blockTokens[j].children = tokens = arrayReplaceAt(
                tokens,
                i,
                splitTextToken(token.content, token.level, state.Token)
              );
            }
          }
        }
      };
    };
  }
});

// ../../../../Users/ted/.yarn/berry/cache/markdown-it-emoji-npm-2.0.2-b64d35b1cb-10c0.zip/node_modules/markdown-it-emoji/lib/normalize_opts.js
var require_normalize_opts = __commonJS({
  "../../../../Users/ted/.yarn/berry/cache/markdown-it-emoji-npm-2.0.2-b64d35b1cb-10c0.zip/node_modules/markdown-it-emoji/lib/normalize_opts.js"(exports, module) {
    "use strict";
    function quoteRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    module.exports = function normalize_opts(options) {
      var emojies = options.defs, shortcuts;
      if (options.enabled.length) {
        emojies = Object.keys(emojies).reduce(function(acc, key) {
          if (options.enabled.indexOf(key) >= 0) {
            acc[key] = emojies[key];
          }
          return acc;
        }, {});
      }
      shortcuts = Object.keys(options.shortcuts).reduce(function(acc, key) {
        if (!emojies[key]) {
          return acc;
        }
        if (Array.isArray(options.shortcuts[key])) {
          options.shortcuts[key].forEach(function(alias) {
            acc[alias] = key;
          });
          return acc;
        }
        acc[options.shortcuts[key]] = key;
        return acc;
      }, {});
      var keys = Object.keys(emojies), names;
      if (keys.length === 0) {
        names = "^$";
      } else {
        names = keys.map(function(name2) {
          return ":" + name2 + ":";
        }).concat(Object.keys(shortcuts)).sort().reverse().map(function(name2) {
          return quoteRE(name2);
        }).join("|");
      }
      var scanRE = RegExp(names);
      var replaceRE = RegExp(names, "g");
      return {
        defs: emojies,
        shortcuts,
        scanRE,
        replaceRE
      };
    };
  }
});

// ../../../../Users/ted/.yarn/berry/cache/markdown-it-emoji-npm-2.0.2-b64d35b1cb-10c0.zip/node_modules/markdown-it-emoji/bare.js
var require_bare = __commonJS({
  "../../../../Users/ted/.yarn/berry/cache/markdown-it-emoji-npm-2.0.2-b64d35b1cb-10c0.zip/node_modules/markdown-it-emoji/bare.js"(exports, module) {
    "use strict";
    var emoji_html = require_render();
    var emoji_replace = require_replace();
    var normalize_opts = require_normalize_opts();
    module.exports = function emoji_plugin(md, options) {
      var defaults = {
        defs: {},
        shortcuts: {},
        enabled: []
      };
      var opts = normalize_opts(md.utils.assign({}, defaults, options || {}));
      md.renderer.rules.emoji = emoji_html;
      md.core.ruler.after(
        "linkify",
        "emoji",
        emoji_replace(md, opts.defs, opts.shortcuts, opts.scanRE, opts.replaceRE)
      );
    };
  }
});

// .yarn/__virtual__/@bangle.dev-emoji-virtual-57e0a76ba3/5/Users/ted/.yarn/berry/cache/@bangle.dev-emoji-npm-0.32.0-a73775c150-10c0.zip/node_modules/@bangle.dev/emoji/dist/index.js
var import_bare = __toESM(require_bare());
var spec = specFactory;
var plugins = pluginsFactory;
var commands = {
  insertEmoji
};
var name = "emoji";
var getTypeFromSchema = (schema) => schema.nodes[name];
function specFactory({ getEmoji, defaultEmojiAlias = "smiley" }) {
  const { toDOM, parseDOM } = domSerializationHelpers(name, {
    tag: "span",
    parsingPriority: 51,
    content: (node) => {
      let result = getEmoji(node.attrs["emojiAlias"], node);
      return result;
    }
  });
  return {
    type: "node",
    name,
    schema: {
      attrs: {
        emojiAlias: {
          default: defaultEmojiAlias
        }
      },
      inline: true,
      group: "inline",
      draggable: true,
      atom: true,
      toDOM,
      parseDOM
    },
    markdown: {
      toMarkdown: (state, node) => {
        state.write(`:${node.attrs["emojiAlias"]}:`);
      },
      parseMarkdown: {
        emoji: {
          node: "emoji",
          getAttrs: (tok) => {
            return {
              emojiAlias: tok.markup
            };
          }
        }
      }
    }
  };
}
function pluginsFactory({ keybindings = {} } = {}) {
  return () => {
    return [];
  };
}
function insertEmoji(emojiAlias) {
  return function(state, dispatch) {
    let emojiType = getTypeFromSchema(state.schema);
    let { $from } = state.selection, index = $from.index();
    if (!$from.parent.canReplaceWith(index, index, emojiType)) {
      return false;
    }
    if (dispatch) {
      const attr = {
        emojiAlias
      };
      dispatch(state.tr.replaceSelectionWith(emojiType.create(attr)));
    }
    return true;
  };
}
var emoji = Object.freeze({
  __proto__: null,
  spec,
  plugins,
  commands,
  insertEmoji
});
var emojiMarkdownItPlugin = import_bare.default;
export {
  emoji,
  emojiMarkdownItPlugin
};
//# sourceMappingURL=@bangle__dev_emoji.js.map
