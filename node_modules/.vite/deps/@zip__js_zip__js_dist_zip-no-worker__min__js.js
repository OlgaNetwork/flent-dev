import {
  __commonJS
} from "./chunk-AUZ3RYOM.js";

// ../../../../Users/ted/.yarn/berry/cache/@zip.js-zip.js-npm-2.4.26-a914bbe24b-10c0.zip/node_modules/@zip.js/zip.js/dist/zip-no-worker.min.js
var require_zip_no_worker_min = __commonJS({
  "../../../../Users/ted/.yarn/berry/cache/@zip.js-zip.js-npm-2.4.26-a914bbe24b-10c0.zip/node_modules/@zip.js/zip.js/dist/zip-no-worker.min.js"(exports, module) {
    ((e, t) => {
      "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).zip = {});
    })(exports, function(e) {
      "use strict";
      const { Array: t, Object: n, String: i, BigInt: r, Math: a, Date: s, Map: o, URL: l, Error: c, Uint8Array: d, Uint16Array: u, Uint32Array: f, DataView: h, Blob: _, Promise: w, TextEncoder: p, TextDecoder: g, FileReader: b, document: x, crypto: y, btoa: m } = globalThis, k = -2;
      function v(e2) {
        return R(e2.map(([e3, n2]) => new t(e3).fill(n2, 0, e3)));
      }
      function R(e2) {
        return e2.reduce((e3, n2) => e3.concat(t.isArray(n2) ? R(n2) : n2), []);
      }
      const E = [0, 1, 2, 3].concat(...v([[2, 4], [2, 5], [4, 6], [4, 7], [8, 8], [8, 9], [16, 10], [16, 11], [32, 12], [32, 13], [64, 14], [64, 15], [2, 0], [1, 16], [1, 17], [2, 18], [2, 19], [4, 20], [4, 21], [8, 22], [8, 23], [16, 24], [16, 25], [32, 26], [32, 27], [64, 28], [64, 29]]));
      function A() {
        const e2 = this;
        function t2(e3, t3) {
          let n2 = 0;
          do {
            n2 |= 1 & e3, e3 >>>= 1, n2 <<= 1;
          } while (--t3 > 0);
          return n2 >>> 1;
        }
        e2.build_tree = (n2) => {
          const i2 = e2.dyn_tree, r2 = e2.stat_desc.static_tree, s2 = e2.stat_desc.elems;
          let o2, l2, c2, d2 = -1;
          for (n2.heap_len = 0, n2.heap_max = 573, o2 = 0; s2 > o2; o2++)
            0 !== i2[2 * o2] ? (n2.heap[++n2.heap_len] = d2 = o2, n2.depth[o2] = 0) : i2[2 * o2 + 1] = 0;
          for (; 2 > n2.heap_len; )
            c2 = n2.heap[++n2.heap_len] = 2 > d2 ? ++d2 : 0, i2[2 * c2] = 1, n2.depth[c2] = 0, n2.opt_len--, r2 && (n2.static_len -= r2[2 * c2 + 1]);
          for (e2.max_code = d2, o2 = a.floor(n2.heap_len / 2); o2 >= 1; o2--)
            n2.pqdownheap(i2, o2);
          c2 = s2;
          do {
            o2 = n2.heap[1], n2.heap[1] = n2.heap[n2.heap_len--], n2.pqdownheap(i2, 1), l2 = n2.heap[1], n2.heap[--n2.heap_max] = o2, n2.heap[--n2.heap_max] = l2, i2[2 * c2] = i2[2 * o2] + i2[2 * l2], n2.depth[c2] = a.max(n2.depth[o2], n2.depth[l2]) + 1, i2[2 * o2 + 1] = i2[2 * l2 + 1] = c2, n2.heap[1] = c2++, n2.pqdownheap(i2, 1);
          } while (n2.heap_len >= 2);
          n2.heap[--n2.heap_max] = n2.heap[1], ((t3) => {
            const n3 = e2.dyn_tree, i3 = e2.stat_desc.static_tree, r3 = e2.stat_desc.extra_bits, a2 = e2.stat_desc.extra_base, s3 = e2.stat_desc.max_length;
            let o3, l3, c3, d3, u2, f2, h2 = 0;
            for (d3 = 0; 15 >= d3; d3++)
              t3.bl_count[d3] = 0;
            for (n3[2 * t3.heap[t3.heap_max] + 1] = 0, o3 = t3.heap_max + 1; 573 > o3; o3++)
              l3 = t3.heap[o3], d3 = n3[2 * n3[2 * l3 + 1] + 1] + 1, d3 > s3 && (d3 = s3, h2++), n3[2 * l3 + 1] = d3, l3 > e2.max_code || (t3.bl_count[d3]++, u2 = 0, a2 > l3 || (u2 = r3[l3 - a2]), f2 = n3[2 * l3], t3.opt_len += f2 * (d3 + u2), i3 && (t3.static_len += f2 * (i3[2 * l3 + 1] + u2)));
            if (0 !== h2) {
              do {
                for (d3 = s3 - 1; 0 === t3.bl_count[d3]; )
                  d3--;
                t3.bl_count[d3]--, t3.bl_count[d3 + 1] += 2, t3.bl_count[s3]--, h2 -= 2;
              } while (h2 > 0);
              for (d3 = s3; 0 !== d3; d3--)
                for (l3 = t3.bl_count[d3]; 0 !== l3; )
                  c3 = t3.heap[--o3], c3 > e2.max_code || (n3[2 * c3 + 1] != d3 && (t3.opt_len += (d3 - n3[2 * c3 + 1]) * n3[2 * c3], n3[2 * c3 + 1] = d3), l3--);
            }
          })(n2), ((e3, n3, i3) => {
            const r3 = [];
            let a2, s3, o3, l3 = 0;
            for (a2 = 1; 15 >= a2; a2++)
              r3[a2] = l3 = l3 + i3[a2 - 1] << 1;
            for (s3 = 0; n3 >= s3; s3++)
              o3 = e3[2 * s3 + 1], 0 !== o3 && (e3[2 * s3] = t2(r3[o3]++, o3));
          })(i2, e2.max_code, n2.bl_count);
        };
      }
      function S(e2, t2, n2, i2, r2) {
        const a2 = this;
        a2.static_tree = e2, a2.extra_bits = t2, a2.extra_base = n2, a2.elems = i2, a2.max_length = r2;
      }
      A._length_code = [0, 1, 2, 3, 4, 5, 6, 7].concat(...v([[2, 8], [2, 9], [2, 10], [2, 11], [4, 12], [4, 13], [4, 14], [4, 15], [8, 16], [8, 17], [8, 18], [8, 19], [16, 20], [16, 21], [16, 22], [16, 23], [32, 24], [32, 25], [32, 26], [31, 27], [1, 28]])), A.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0], A.base_dist = [0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576], A.d_code = (e2) => 256 > e2 ? E[e2] : E[256 + (e2 >>> 7)], A.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], A.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], A.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], A.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      const z = v([[144, 8], [112, 9], [24, 7], [8, 8]]);
      S.static_ltree = R([12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 19, 275, 147, 403, 83, 339, 211, 467, 51, 307, 179, 435, 115, 371, 243, 499, 11, 267, 139, 395, 75, 331, 203, 459, 43, 299, 171, 427, 107, 363, 235, 491, 27, 283, 155, 411, 91, 347, 219, 475, 59, 315, 187, 443, 123, 379, 251, 507, 7, 263, 135, 391, 71, 327, 199, 455, 39, 295, 167, 423, 103, 359, 231, 487, 23, 279, 151, 407, 87, 343, 215, 471, 55, 311, 183, 439, 119, 375, 247, 503, 15, 271, 143, 399, 79, 335, 207, 463, 47, 303, 175, 431, 111, 367, 239, 495, 31, 287, 159, 415, 95, 351, 223, 479, 63, 319, 191, 447, 127, 383, 255, 511, 0, 64, 32, 96, 16, 80, 48, 112, 8, 72, 40, 104, 24, 88, 56, 120, 4, 68, 36, 100, 20, 84, 52, 116, 3, 131, 67, 195, 35, 163, 99, 227].map((e2, t2) => [e2, z[t2]]));
      const D = v([[30, 5]]);
      function F(e2, t2, n2, i2, r2) {
        const a2 = this;
        a2.good_length = e2, a2.max_lazy = t2, a2.nice_length = n2, a2.max_chain = i2, a2.func = r2;
      }
      S.static_dtree = R([0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30, 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23].map((e2, t2) => [e2, D[t2]])), S.static_l_desc = new S(S.static_ltree, A.extra_lbits, 257, 286, 15), S.static_d_desc = new S(S.static_dtree, A.extra_dbits, 0, 30, 15), S.static_bl_desc = new S(null, A.extra_blbits, 0, 19, 7);
      const T = [new F(0, 0, 0, 0, 0), new F(4, 4, 8, 4, 1), new F(4, 5, 16, 8, 1), new F(4, 6, 32, 32, 1), new F(4, 4, 16, 16, 2), new F(8, 16, 32, 32, 2), new F(8, 16, 128, 128, 2), new F(8, 32, 128, 256, 2), new F(32, 128, 258, 1024, 2), new F(32, 258, 258, 4096, 2)], U = ["need dictionary", "stream end", "", "", "stream error", "data error", "", "buffer error", "", ""], C = 113, B = 666, W = 262;
      function I(e2, t2, n2, i2) {
        const r2 = e2[2 * t2], a2 = e2[2 * n2];
        return a2 > r2 || r2 == a2 && i2[t2] <= i2[n2];
      }
      function M() {
        const e2 = this;
        let t2, n2, i2, r2, s2, o2, l2, c2, f2, h2, _2, w2, p2, g2, b2, x2, y2, m2, v2, R2, E2, z2, D2, F2, M2, L2, N2, H2, O2, V2, P2, q2, Z2;
        const K2 = new A(), G2 = new A(), Y2 = new A();
        let j2, X2, J2, Q2, $2, ee2;
        function te2() {
          let t3;
          for (t3 = 0; 286 > t3; t3++)
            P2[2 * t3] = 0;
          for (t3 = 0; 30 > t3; t3++)
            q2[2 * t3] = 0;
          for (t3 = 0; 19 > t3; t3++)
            Z2[2 * t3] = 0;
          P2[512] = 1, e2.opt_len = e2.static_len = 0, X2 = J2 = 0;
        }
        function ne2(e3, t3) {
          let n3, i3 = -1, r3 = e3[1], a2 = 0, s3 = 7, o3 = 4;
          0 === r3 && (s3 = 138, o3 = 3), e3[2 * (t3 + 1) + 1] = 65535;
          for (let l3 = 0; t3 >= l3; l3++)
            n3 = r3, r3 = e3[2 * (l3 + 1) + 1], ++a2 < s3 && n3 == r3 || (o3 > a2 ? Z2[2 * n3] += a2 : 0 !== n3 ? (n3 != i3 && Z2[2 * n3]++, Z2[32]++) : a2 > 10 ? Z2[36]++ : Z2[34]++, a2 = 0, i3 = n3, 0 === r3 ? (s3 = 138, o3 = 3) : n3 == r3 ? (s3 = 6, o3 = 3) : (s3 = 7, o3 = 4));
        }
        function ie2(t3) {
          e2.pending_buf[e2.pending++] = t3;
        }
        function re2(e3) {
          ie2(255 & e3), ie2(e3 >>> 8 & 255);
        }
        function ae2(e3, t3) {
          let n3;
          const i3 = t3;
          ee2 > 16 - i3 ? (n3 = e3, $2 |= n3 << ee2 & 65535, re2($2), $2 = n3 >>> 16 - ee2, ee2 += i3 - 16) : ($2 |= e3 << ee2 & 65535, ee2 += i3);
        }
        function se2(e3, t3) {
          const n3 = 2 * e3;
          ae2(65535 & t3[n3], 65535 & t3[n3 + 1]);
        }
        function oe2(e3, t3) {
          let n3, i3, r3 = -1, a2 = e3[1], s3 = 0, o3 = 7, l3 = 4;
          for (0 === a2 && (o3 = 138, l3 = 3), n3 = 0; t3 >= n3; n3++)
            if (i3 = a2, a2 = e3[2 * (n3 + 1) + 1], ++s3 >= o3 || i3 != a2) {
              if (l3 > s3)
                do {
                  se2(i3, Z2);
                } while (0 != --s3);
              else
                0 !== i3 ? (i3 != r3 && (se2(i3, Z2), s3--), se2(16, Z2), ae2(s3 - 3, 2)) : s3 > 10 ? (se2(18, Z2), ae2(s3 - 11, 7)) : (se2(17, Z2), ae2(s3 - 3, 3));
              s3 = 0, r3 = i3, 0 === a2 ? (o3 = 138, l3 = 3) : i3 == a2 ? (o3 = 6, l3 = 3) : (o3 = 7, l3 = 4);
            }
        }
        function le2() {
          16 == ee2 ? (re2($2), $2 = 0, ee2 = 0) : 8 > ee2 || (ie2(255 & $2), $2 >>>= 8, ee2 -= 8);
        }
        function ce2(t3, n3) {
          let i3, r3, s3;
          if (e2.dist_buf[X2] = t3, e2.lc_buf[X2] = 255 & n3, X2++, 0 === t3 ? P2[2 * n3]++ : (J2++, t3--, P2[2 * (A._length_code[n3] + 256 + 1)]++, q2[2 * A.d_code(t3)]++), 0 == (8191 & X2) && N2 > 2) {
            for (i3 = 8 * X2, r3 = E2 - y2, s3 = 0; 30 > s3; s3++)
              i3 += q2[2 * s3] * (5 + A.extra_dbits[s3]);
            if (i3 >>>= 3, J2 < a.floor(X2 / 2) && i3 < a.floor(r3 / 2))
              return true;
          }
          return X2 == j2 - 1;
        }
        function de2(t3, n3) {
          let i3, r3, a2, s3, o3 = 0;
          if (0 !== X2)
            do {
              i3 = e2.dist_buf[o3], r3 = e2.lc_buf[o3], o3++, 0 === i3 ? se2(r3, t3) : (a2 = A._length_code[r3], se2(a2 + 256 + 1, t3), s3 = A.extra_lbits[a2], 0 !== s3 && (r3 -= A.base_length[a2], ae2(r3, s3)), i3--, a2 = A.d_code(i3), se2(a2, n3), s3 = A.extra_dbits[a2], 0 !== s3 && (i3 -= A.base_dist[a2], ae2(i3, s3)));
            } while (X2 > o3);
          se2(256, t3), Q2 = t3[513];
        }
        function ue2() {
          ee2 > 8 ? re2($2) : ee2 > 0 && ie2(255 & $2), $2 = 0, ee2 = 0;
        }
        function fe2(t3, n3, i3) {
          ae2(0 + (i3 ? 1 : 0), 3), ((t4, n4) => {
            ue2(), Q2 = 8, re2(n4), re2(~n4), e2.pending_buf.set(c2.subarray(t4, t4 + n4), e2.pending), e2.pending += n4;
          })(t3, n3);
        }
        function he2(n3) {
          ((t3, n4, i3) => {
            let r3, a2, s3 = 0;
            N2 > 0 ? (K2.build_tree(e2), G2.build_tree(e2), s3 = (() => {
              let t4;
              for (ne2(P2, K2.max_code), ne2(q2, G2.max_code), Y2.build_tree(e2), t4 = 18; t4 >= 3 && 0 === Z2[2 * A.bl_order[t4] + 1]; t4--)
                ;
              return e2.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
            })(), r3 = e2.opt_len + 3 + 7 >>> 3, a2 = e2.static_len + 3 + 7 >>> 3, a2 > r3 || (r3 = a2)) : r3 = a2 = n4 + 5, n4 + 4 > r3 || -1 == t3 ? a2 == r3 ? (ae2(2 + (i3 ? 1 : 0), 3), de2(S.static_ltree, S.static_dtree)) : (ae2(4 + (i3 ? 1 : 0), 3), ((e3, t4, n5) => {
              let i4;
              for (ae2(e3 - 257, 5), ae2(t4 - 1, 5), ae2(n5 - 4, 4), i4 = 0; n5 > i4; i4++)
                ae2(Z2[2 * A.bl_order[i4] + 1], 3);
              oe2(P2, e3 - 1), oe2(q2, t4 - 1);
            })(K2.max_code + 1, G2.max_code + 1, s3 + 1), de2(P2, q2)) : fe2(t3, n4, i3), te2(), i3 && ue2();
          })(0 > y2 ? -1 : y2, E2 - y2, n3), y2 = E2, t2.flush_pending();
        }
        function _e2() {
          let e3, n3, i3, r3;
          do {
            if (r3 = f2 - D2 - E2, 0 === r3 && 0 === E2 && 0 === D2)
              r3 = s2;
            else if (-1 == r3)
              r3--;
            else if (E2 >= s2 + s2 - W) {
              c2.set(c2.subarray(s2, s2 + s2), 0), z2 -= s2, E2 -= s2, y2 -= s2, e3 = p2, i3 = e3;
              do {
                n3 = 65535 & _2[--i3], _2[i3] = s2 > n3 ? 0 : n3 - s2;
              } while (0 != --e3);
              e3 = s2, i3 = e3;
              do {
                n3 = 65535 & h2[--i3], h2[i3] = s2 > n3 ? 0 : n3 - s2;
              } while (0 != --e3);
              r3 += s2;
            }
            if (0 === t2.avail_in)
              return;
            e3 = t2.read_buf(c2, E2 + D2, r3), D2 += e3, 3 > D2 || (w2 = 255 & c2[E2], w2 = (w2 << x2 ^ 255 & c2[E2 + 1]) & b2);
          } while (W > D2 && 0 !== t2.avail_in);
        }
        function we2(e3) {
          let t3, n3, i3 = M2, r3 = E2, a2 = F2;
          const o3 = E2 > s2 - W ? E2 - (s2 - W) : 0;
          let d2 = V2;
          const u2 = l2, f3 = E2 + 258;
          let _3 = c2[r3 + a2 - 1], w3 = c2[r3 + a2];
          O2 > F2 || (i3 >>= 2), d2 > D2 && (d2 = D2);
          do {
            if (t3 = e3, c2[t3 + a2] == w3 && c2[t3 + a2 - 1] == _3 && c2[t3] == c2[r3] && c2[++t3] == c2[r3 + 1]) {
              r3 += 2, t3++;
              do {
              } while (c2[++r3] == c2[++t3] && c2[++r3] == c2[++t3] && c2[++r3] == c2[++t3] && c2[++r3] == c2[++t3] && c2[++r3] == c2[++t3] && c2[++r3] == c2[++t3] && c2[++r3] == c2[++t3] && c2[++r3] == c2[++t3] && f3 > r3);
              if (n3 = 258 - (f3 - r3), r3 = f3 - 258, n3 > a2) {
                if (z2 = e3, a2 = n3, n3 >= d2)
                  break;
                _3 = c2[r3 + a2 - 1], w3 = c2[r3 + a2];
              }
            }
          } while ((e3 = 65535 & h2[e3 & u2]) > o3 && 0 != --i3);
          return a2 > D2 ? D2 : a2;
        }
        e2.depth = [], e2.bl_count = [], e2.heap = [], P2 = [], q2 = [], Z2 = [], e2.pqdownheap = (t3, n3) => {
          const i3 = e2.heap, r3 = i3[n3];
          let a2 = n3 << 1;
          for (; a2 <= e2.heap_len && (a2 < e2.heap_len && I(t3, i3[a2 + 1], i3[a2], e2.depth) && a2++, !I(t3, r3, i3[a2], e2.depth)); )
            i3[n3] = i3[a2], n3 = a2, a2 <<= 1;
          i3[n3] = r3;
        }, e2.deflateInit = (t3, v3, A2, z3, U2, B2) => (z3 || (z3 = 8), U2 || (U2 = 8), B2 || (B2 = 0), t3.msg = null, -1 == v3 && (v3 = 6), 1 > U2 || U2 > 9 || 8 != z3 || 9 > A2 || A2 > 15 || 0 > v3 || v3 > 9 || 0 > B2 || B2 > 2 ? k : (t3.dstate = e2, o2 = A2, s2 = 1 << o2, l2 = s2 - 1, g2 = U2 + 7, p2 = 1 << g2, b2 = p2 - 1, x2 = a.floor((g2 + 3 - 1) / 3), c2 = new d(2 * s2), h2 = [], _2 = [], j2 = 1 << U2 + 6, e2.pending_buf = new d(4 * j2), i2 = 4 * j2, e2.dist_buf = new u(j2), e2.lc_buf = new d(j2), N2 = v3, H2 = B2, ((t4) => (t4.total_in = t4.total_out = 0, t4.msg = null, e2.pending = 0, e2.pending_out = 0, n2 = C, r2 = 0, K2.dyn_tree = P2, K2.stat_desc = S.static_l_desc, G2.dyn_tree = q2, G2.stat_desc = S.static_d_desc, Y2.dyn_tree = Z2, Y2.stat_desc = S.static_bl_desc, $2 = 0, ee2 = 0, Q2 = 8, te2(), (() => {
          f2 = 2 * s2, _2[p2 - 1] = 0;
          for (let e3 = 0; p2 - 1 > e3; e3++)
            _2[e3] = 0;
          L2 = T[N2].max_lazy, O2 = T[N2].good_length, V2 = T[N2].nice_length, M2 = T[N2].max_chain, E2 = 0, y2 = 0, D2 = 0, m2 = F2 = 2, R2 = 0, w2 = 0;
        })(), 0))(t3))), e2.deflateEnd = () => 42 != n2 && n2 != C && n2 != B ? k : (e2.lc_buf = null, e2.dist_buf = null, e2.pending_buf = null, _2 = null, h2 = null, c2 = null, e2.dstate = null, n2 == C ? -3 : 0), e2.deflateParams = (e3, t3, n3) => {
          let i3 = 0;
          return -1 == t3 && (t3 = 6), 0 > t3 || t3 > 9 || 0 > n3 || n3 > 2 ? k : (T[N2].func != T[t3].func && 0 !== e3.total_in && (i3 = e3.deflate(1)), N2 != t3 && (N2 = t3, L2 = T[N2].max_lazy, O2 = T[N2].good_length, V2 = T[N2].nice_length, M2 = T[N2].max_chain), H2 = n3, i3);
        }, e2.deflateSetDictionary = (e3, t3, i3) => {
          let r3, a2 = i3, o3 = 0;
          if (!t3 || 42 != n2)
            return k;
          if (3 > a2)
            return 0;
          for (a2 > s2 - W && (a2 = s2 - W, o3 = i3 - a2), c2.set(t3.subarray(o3, o3 + a2), 0), E2 = a2, y2 = a2, w2 = 255 & c2[0], w2 = (w2 << x2 ^ 255 & c2[1]) & b2, r3 = 0; a2 - 3 >= r3; r3++)
            w2 = (w2 << x2 ^ 255 & c2[r3 + 2]) & b2, h2[r3 & l2] = _2[w2], _2[w2] = r3;
          return 0;
        }, e2.deflate = (a2, d2) => {
          let u2, f3, g3, A2, I2;
          if (d2 > 4 || 0 > d2)
            return k;
          if (!a2.next_out || !a2.next_in && 0 !== a2.avail_in || n2 == B && 4 != d2)
            return a2.msg = U[4], k;
          if (0 === a2.avail_out)
            return a2.msg = U[7], -5;
          var M3;
          if (t2 = a2, A2 = r2, r2 = d2, 42 == n2 && (f3 = 8 + (o2 - 8 << 4) << 8, g3 = (N2 - 1 & 255) >> 1, g3 > 3 && (g3 = 3), f3 |= g3 << 6, 0 !== E2 && (f3 |= 32), f3 += 31 - f3 % 31, n2 = C, ie2((M3 = f3) >> 8 & 255), ie2(255 & M3)), 0 !== e2.pending) {
            if (t2.flush_pending(), 0 === t2.avail_out)
              return r2 = -1, 0;
          } else if (0 === t2.avail_in && A2 >= d2 && 4 != d2)
            return t2.msg = U[7], -5;
          if (n2 == B && 0 !== t2.avail_in)
            return a2.msg = U[7], -5;
          if (0 !== t2.avail_in || 0 !== D2 || 0 != d2 && n2 != B) {
            switch (I2 = -1, T[N2].func) {
              case 0:
                I2 = ((e3) => {
                  let n3, r3 = 65535;
                  for (r3 > i2 - 5 && (r3 = i2 - 5); ; ) {
                    if (1 >= D2) {
                      if (_e2(), 0 === D2 && 0 == e3)
                        return 0;
                      if (0 === D2)
                        break;
                    }
                    if (E2 += D2, D2 = 0, n3 = y2 + r3, (0 === E2 || E2 >= n3) && (D2 = E2 - n3, E2 = n3, he2(false), 0 === t2.avail_out))
                      return 0;
                    if (E2 - y2 >= s2 - W && (he2(false), 0 === t2.avail_out))
                      return 0;
                  }
                  return he2(4 == e3), 0 === t2.avail_out ? 4 == e3 ? 2 : 0 : 4 == e3 ? 3 : 1;
                })(d2);
                break;
              case 1:
                I2 = ((e3) => {
                  let n3, i3 = 0;
                  for (; ; ) {
                    if (W > D2) {
                      if (_e2(), W > D2 && 0 == e3)
                        return 0;
                      if (0 === D2)
                        break;
                    }
                    if (3 > D2 || (w2 = (w2 << x2 ^ 255 & c2[E2 + 2]) & b2, i3 = 65535 & _2[w2], h2[E2 & l2] = _2[w2], _2[w2] = E2), 0 === i3 || (E2 - i3 & 65535) > s2 - W || 2 != H2 && (m2 = we2(i3)), 3 > m2)
                      n3 = ce2(0, 255 & c2[E2]), D2--, E2++;
                    else if (n3 = ce2(E2 - z2, m2 - 3), D2 -= m2, m2 > L2 || 3 > D2)
                      E2 += m2, m2 = 0, w2 = 255 & c2[E2], w2 = (w2 << x2 ^ 255 & c2[E2 + 1]) & b2;
                    else {
                      m2--;
                      do {
                        E2++, w2 = (w2 << x2 ^ 255 & c2[E2 + 2]) & b2, i3 = 65535 & _2[w2], h2[E2 & l2] = _2[w2], _2[w2] = E2;
                      } while (0 != --m2);
                      E2++;
                    }
                    if (n3 && (he2(false), 0 === t2.avail_out))
                      return 0;
                  }
                  return he2(4 == e3), 0 === t2.avail_out ? 4 == e3 ? 2 : 0 : 4 == e3 ? 3 : 1;
                })(d2);
                break;
              case 2:
                I2 = ((e3) => {
                  let n3, i3, r3 = 0;
                  for (; ; ) {
                    if (W > D2) {
                      if (_e2(), W > D2 && 0 == e3)
                        return 0;
                      if (0 === D2)
                        break;
                    }
                    if (3 > D2 || (w2 = (w2 << x2 ^ 255 & c2[E2 + 2]) & b2, r3 = 65535 & _2[w2], h2[E2 & l2] = _2[w2], _2[w2] = E2), F2 = m2, v2 = z2, m2 = 2, 0 !== r3 && L2 > F2 && s2 - W >= (E2 - r3 & 65535) && (2 != H2 && (m2 = we2(r3)), 5 >= m2 && (1 == H2 || 3 == m2 && E2 - z2 > 4096) && (m2 = 2)), 3 > F2 || m2 > F2)
                      if (0 !== R2) {
                        if (n3 = ce2(0, 255 & c2[E2 - 1]), n3 && he2(false), E2++, D2--, 0 === t2.avail_out)
                          return 0;
                      } else
                        R2 = 1, E2++, D2--;
                    else {
                      i3 = E2 + D2 - 3, n3 = ce2(E2 - 1 - v2, F2 - 3), D2 -= F2 - 1, F2 -= 2;
                      do {
                        ++E2 > i3 || (w2 = (w2 << x2 ^ 255 & c2[E2 + 2]) & b2, r3 = 65535 & _2[w2], h2[E2 & l2] = _2[w2], _2[w2] = E2);
                      } while (0 != --F2);
                      if (R2 = 0, m2 = 2, E2++, n3 && (he2(false), 0 === t2.avail_out))
                        return 0;
                    }
                  }
                  return 0 !== R2 && (n3 = ce2(0, 255 & c2[E2 - 1]), R2 = 0), he2(4 == e3), 0 === t2.avail_out ? 4 == e3 ? 2 : 0 : 4 == e3 ? 3 : 1;
                })(d2);
            }
            if (2 != I2 && 3 != I2 || (n2 = B), 0 == I2 || 2 == I2)
              return 0 === t2.avail_out && (r2 = -1), 0;
            if (1 == I2) {
              if (1 == d2)
                ae2(2, 3), se2(256, S.static_ltree), le2(), 9 > 1 + Q2 + 10 - ee2 && (ae2(2, 3), se2(256, S.static_ltree), le2()), Q2 = 7;
              else if (fe2(0, 0, false), 3 == d2)
                for (u2 = 0; p2 > u2; u2++)
                  _2[u2] = 0;
              if (t2.flush_pending(), 0 === t2.avail_out)
                return r2 = -1, 0;
            }
          }
          return 4 != d2 ? 0 : 1;
        };
      }
      function L() {
        const e2 = this;
        e2.next_in_index = 0, e2.next_out_index = 0, e2.avail_in = 0, e2.total_in = 0, e2.avail_out = 0, e2.total_out = 0;
      }
      L.prototype = { deflateInit: function(e2, t2) {
        const n2 = this;
        return n2.dstate = new M(), t2 || (t2 = 15), n2.dstate.deflateInit(n2, e2, t2);
      }, deflate: function(e2) {
        const t2 = this;
        return t2.dstate ? t2.dstate.deflate(t2, e2) : k;
      }, deflateEnd: function() {
        const e2 = this;
        if (!e2.dstate)
          return k;
        const t2 = e2.dstate.deflateEnd();
        return e2.dstate = null, t2;
      }, deflateParams: function(e2, t2) {
        const n2 = this;
        return n2.dstate ? n2.dstate.deflateParams(n2, e2, t2) : k;
      }, deflateSetDictionary: function(e2, t2) {
        const n2 = this;
        return n2.dstate ? n2.dstate.deflateSetDictionary(n2, e2, t2) : k;
      }, read_buf: function(e2, t2, n2) {
        const i2 = this;
        let r2 = i2.avail_in;
        return r2 > n2 && (r2 = n2), 0 === r2 ? 0 : (i2.avail_in -= r2, e2.set(i2.next_in.subarray(i2.next_in_index, i2.next_in_index + r2), t2), i2.next_in_index += r2, i2.total_in += r2, r2);
      }, flush_pending: function() {
        const e2 = this;
        let t2 = e2.dstate.pending;
        t2 > e2.avail_out && (t2 = e2.avail_out), 0 !== t2 && (e2.next_out.set(e2.dstate.pending_buf.subarray(e2.dstate.pending_out, e2.dstate.pending_out + t2), e2.next_out_index), e2.next_out_index += t2, e2.dstate.pending_out += t2, e2.total_out += t2, e2.avail_out -= t2, e2.dstate.pending -= t2, 0 === e2.dstate.pending && (e2.dstate.pending_out = 0));
      } };
      const N = -2, H = -3, O = -5, V = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535], P = [96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255], q = [80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5, 8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5, 24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577], Z = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], K = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112], G = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], Y = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
      function j() {
        let e2, t2, n2, i2, r2, a2;
        function s2(e3, t3, s3, o3, l2, c2, d2, u2, f2, h2, _2) {
          let w2, p2, g2, b2, x2, y2, m2, k2, v2, R2, E2, A2, S2, z2, D2;
          R2 = 0, x2 = s3;
          do {
            n2[e3[t3 + R2]]++, R2++, x2--;
          } while (0 !== x2);
          if (n2[0] == s3)
            return d2[0] = -1, u2[0] = 0, 0;
          for (k2 = u2[0], y2 = 1; 15 >= y2 && 0 === n2[y2]; y2++)
            ;
          for (m2 = y2, y2 > k2 && (k2 = y2), x2 = 15; 0 !== x2 && 0 === n2[x2]; x2--)
            ;
          for (g2 = x2, k2 > x2 && (k2 = x2), u2[0] = k2, z2 = 1 << y2; x2 > y2; y2++, z2 <<= 1)
            if (0 > (z2 -= n2[y2]))
              return H;
          if (0 > (z2 -= n2[x2]))
            return H;
          for (n2[x2] += z2, a2[1] = y2 = 0, R2 = 1, S2 = 2; 0 != --x2; )
            a2[S2] = y2 += n2[R2], S2++, R2++;
          x2 = 0, R2 = 0;
          do {
            0 !== (y2 = e3[t3 + R2]) && (_2[a2[y2]++] = x2), R2++;
          } while (++x2 < s3);
          for (s3 = a2[g2], a2[0] = x2 = 0, R2 = 0, b2 = -1, A2 = -k2, r2[0] = 0, E2 = 0, D2 = 0; g2 >= m2; m2++)
            for (w2 = n2[m2]; 0 != w2--; ) {
              for (; m2 > A2 + k2; ) {
                if (b2++, A2 += k2, D2 = g2 - A2, D2 = D2 > k2 ? k2 : D2, (p2 = 1 << (y2 = m2 - A2)) > w2 + 1 && (p2 -= w2 + 1, S2 = m2, D2 > y2))
                  for (; ++y2 < D2 && (p2 <<= 1) > n2[++S2]; )
                    p2 -= n2[S2];
                if (D2 = 1 << y2, h2[0] + D2 > 1440)
                  return H;
                r2[b2] = E2 = h2[0], h2[0] += D2, 0 !== b2 ? (a2[b2] = x2, i2[0] = y2, i2[1] = k2, y2 = x2 >>> A2 - k2, i2[2] = E2 - r2[b2 - 1] - y2, f2.set(i2, 3 * (r2[b2 - 1] + y2))) : d2[0] = E2;
              }
              for (i2[1] = m2 - A2, s3 > R2 ? _2[R2] < o3 ? (i2[0] = 256 > _2[R2] ? 0 : 96, i2[2] = _2[R2++]) : (i2[0] = c2[_2[R2] - o3] + 16 + 64, i2[2] = l2[_2[R2++] - o3]) : i2[0] = 192, p2 = 1 << m2 - A2, y2 = x2 >>> A2; D2 > y2; y2 += p2)
                f2.set(i2, 3 * (E2 + y2));
              for (y2 = 1 << m2 - 1; 0 != (x2 & y2); y2 >>>= 1)
                x2 ^= y2;
              for (x2 ^= y2, v2 = (1 << A2) - 1; (x2 & v2) != a2[b2]; )
                b2--, A2 -= k2, v2 = (1 << A2) - 1;
            }
          return 0 !== z2 && 1 != g2 ? O : 0;
        }
        function o2(s3) {
          let o3;
          for (e2 || (e2 = [], t2 = [], n2 = new Int32Array(16), i2 = [], r2 = new Int32Array(15), a2 = new Int32Array(16)), t2.length < s3 && (t2 = []), o3 = 0; s3 > o3; o3++)
            t2[o3] = 0;
          for (o3 = 0; 16 > o3; o3++)
            n2[o3] = 0;
          for (o3 = 0; 3 > o3; o3++)
            i2[o3] = 0;
          r2.set(n2.subarray(0, 15), 0), a2.set(n2.subarray(0, 16), 0);
        }
        this.inflate_trees_bits = (n3, i3, r3, a3, l2) => {
          let c2;
          return o2(19), e2[0] = 0, c2 = s2(n3, 0, 19, 19, null, null, r3, i3, a3, e2, t2), c2 == H ? l2.msg = "oversubscribed dynamic bit lengths tree" : c2 != O && 0 !== i3[0] || (l2.msg = "incomplete dynamic bit lengths tree", c2 = H), c2;
        }, this.inflate_trees_dynamic = (n3, i3, r3, a3, l2, c2, d2, u2, f2) => {
          let h2;
          return o2(288), e2[0] = 0, h2 = s2(r3, 0, n3, 257, Z, K, c2, a3, u2, e2, t2), 0 != h2 || 0 === a3[0] ? (h2 == H ? f2.msg = "oversubscribed literal/length tree" : -4 != h2 && (f2.msg = "incomplete literal/length tree", h2 = H), h2) : (o2(288), h2 = s2(r3, n3, i3, 0, G, Y, d2, l2, u2, e2, t2), 0 != h2 || 0 === l2[0] && n3 > 257 ? (h2 == H ? f2.msg = "oversubscribed distance tree" : h2 == O ? (f2.msg = "incomplete distance tree", h2 = H) : -4 != h2 && (f2.msg = "empty distance tree with lengths", h2 = H), h2) : 0);
        };
      }
      function X() {
        const e2 = this;
        let t2, n2, i2, r2, a2 = 0, s2 = 0, o2 = 0, l2 = 0, c2 = 0, d2 = 0, u2 = 0, f2 = 0, h2 = 0, _2 = 0;
        function w2(e3, t3, n3, i3, r3, a3, s3, o3) {
          let l3, c3, d3, u3, f3, h3, _3, w3, p2, g2, b2, x2, y2, m2, k2, v2;
          _3 = o3.next_in_index, w3 = o3.avail_in, f3 = s3.bitb, h3 = s3.bitk, p2 = s3.write, g2 = p2 < s3.read ? s3.read - p2 - 1 : s3.end - p2, b2 = V[e3], x2 = V[t3];
          do {
            for (; 20 > h3; )
              w3--, f3 |= (255 & o3.read_byte(_3++)) << h3, h3 += 8;
            if (l3 = f3 & b2, c3 = n3, d3 = i3, v2 = 3 * (d3 + l3), 0 !== (u3 = c3[v2]))
              for (; ; ) {
                if (f3 >>= c3[v2 + 1], h3 -= c3[v2 + 1], 0 != (16 & u3)) {
                  for (u3 &= 15, y2 = c3[v2 + 2] + (f3 & V[u3]), f3 >>= u3, h3 -= u3; 15 > h3; )
                    w3--, f3 |= (255 & o3.read_byte(_3++)) << h3, h3 += 8;
                  for (l3 = f3 & x2, c3 = r3, d3 = a3, v2 = 3 * (d3 + l3), u3 = c3[v2]; ; ) {
                    if (f3 >>= c3[v2 + 1], h3 -= c3[v2 + 1], 0 != (16 & u3)) {
                      for (u3 &= 15; u3 > h3; )
                        w3--, f3 |= (255 & o3.read_byte(_3++)) << h3, h3 += 8;
                      if (m2 = c3[v2 + 2] + (f3 & V[u3]), f3 >>= u3, h3 -= u3, g2 -= y2, m2 > p2) {
                        k2 = p2 - m2;
                        do {
                          k2 += s3.end;
                        } while (0 > k2);
                        if (u3 = s3.end - k2, y2 > u3) {
                          if (y2 -= u3, p2 - k2 > 0 && u3 > p2 - k2)
                            do {
                              s3.win[p2++] = s3.win[k2++];
                            } while (0 != --u3);
                          else
                            s3.win.set(s3.win.subarray(k2, k2 + u3), p2), p2 += u3, k2 += u3, u3 = 0;
                          k2 = 0;
                        }
                      } else
                        k2 = p2 - m2, p2 - k2 > 0 && 2 > p2 - k2 ? (s3.win[p2++] = s3.win[k2++], s3.win[p2++] = s3.win[k2++], y2 -= 2) : (s3.win.set(s3.win.subarray(k2, k2 + 2), p2), p2 += 2, k2 += 2, y2 -= 2);
                      if (p2 - k2 > 0 && y2 > p2 - k2)
                        do {
                          s3.win[p2++] = s3.win[k2++];
                        } while (0 != --y2);
                      else
                        s3.win.set(s3.win.subarray(k2, k2 + y2), p2), p2 += y2, k2 += y2, y2 = 0;
                      break;
                    }
                    if (0 != (64 & u3))
                      return o3.msg = "invalid distance code", y2 = o3.avail_in - w3, y2 = y2 > h3 >> 3 ? h3 >> 3 : y2, w3 += y2, _3 -= y2, h3 -= y2 << 3, s3.bitb = f3, s3.bitk = h3, o3.avail_in = w3, o3.total_in += _3 - o3.next_in_index, o3.next_in_index = _3, s3.write = p2, H;
                    l3 += c3[v2 + 2], l3 += f3 & V[u3], v2 = 3 * (d3 + l3), u3 = c3[v2];
                  }
                  break;
                }
                if (0 != (64 & u3))
                  return 0 != (32 & u3) ? (y2 = o3.avail_in - w3, y2 = y2 > h3 >> 3 ? h3 >> 3 : y2, w3 += y2, _3 -= y2, h3 -= y2 << 3, s3.bitb = f3, s3.bitk = h3, o3.avail_in = w3, o3.total_in += _3 - o3.next_in_index, o3.next_in_index = _3, s3.write = p2, 1) : (o3.msg = "invalid literal/length code", y2 = o3.avail_in - w3, y2 = y2 > h3 >> 3 ? h3 >> 3 : y2, w3 += y2, _3 -= y2, h3 -= y2 << 3, s3.bitb = f3, s3.bitk = h3, o3.avail_in = w3, o3.total_in += _3 - o3.next_in_index, o3.next_in_index = _3, s3.write = p2, H);
                if (l3 += c3[v2 + 2], l3 += f3 & V[u3], v2 = 3 * (d3 + l3), 0 === (u3 = c3[v2])) {
                  f3 >>= c3[v2 + 1], h3 -= c3[v2 + 1], s3.win[p2++] = c3[v2 + 2], g2--;
                  break;
                }
              }
            else
              f3 >>= c3[v2 + 1], h3 -= c3[v2 + 1], s3.win[p2++] = c3[v2 + 2], g2--;
          } while (g2 >= 258 && w3 >= 10);
          return y2 = o3.avail_in - w3, y2 = y2 > h3 >> 3 ? h3 >> 3 : y2, w3 += y2, _3 -= y2, h3 -= y2 << 3, s3.bitb = f3, s3.bitk = h3, o3.avail_in = w3, o3.total_in += _3 - o3.next_in_index, o3.next_in_index = _3, s3.write = p2, 0;
        }
        e2.init = (e3, a3, s3, o3, l3, c3) => {
          t2 = 0, u2 = e3, f2 = a3, i2 = s3, h2 = o3, r2 = l3, _2 = c3, n2 = null;
        }, e2.proc = (e3, p2, g2) => {
          let b2, x2, y2, m2, k2, v2, R2, E2 = 0, A2 = 0, S2 = 0;
          for (S2 = p2.next_in_index, m2 = p2.avail_in, E2 = e3.bitb, A2 = e3.bitk, k2 = e3.write, v2 = k2 < e3.read ? e3.read - k2 - 1 : e3.end - k2; ; )
            switch (t2) {
              case 0:
                if (v2 >= 258 && m2 >= 10 && (e3.bitb = E2, e3.bitk = A2, p2.avail_in = m2, p2.total_in += S2 - p2.next_in_index, p2.next_in_index = S2, e3.write = k2, g2 = w2(u2, f2, i2, h2, r2, _2, e3, p2), S2 = p2.next_in_index, m2 = p2.avail_in, E2 = e3.bitb, A2 = e3.bitk, k2 = e3.write, v2 = k2 < e3.read ? e3.read - k2 - 1 : e3.end - k2, 0 != g2)) {
                  t2 = 1 == g2 ? 7 : 9;
                  break;
                }
                o2 = u2, n2 = i2, s2 = h2, t2 = 1;
              case 1:
                for (b2 = o2; b2 > A2; ) {
                  if (0 === m2)
                    return e3.bitb = E2, e3.bitk = A2, p2.avail_in = m2, p2.total_in += S2 - p2.next_in_index, p2.next_in_index = S2, e3.write = k2, e3.inflate_flush(p2, g2);
                  g2 = 0, m2--, E2 |= (255 & p2.read_byte(S2++)) << A2, A2 += 8;
                }
                if (x2 = 3 * (s2 + (E2 & V[b2])), E2 >>>= n2[x2 + 1], A2 -= n2[x2 + 1], y2 = n2[x2], 0 === y2) {
                  l2 = n2[x2 + 2], t2 = 6;
                  break;
                }
                if (0 != (16 & y2)) {
                  c2 = 15 & y2, a2 = n2[x2 + 2], t2 = 2;
                  break;
                }
                if (0 == (64 & y2)) {
                  o2 = y2, s2 = x2 / 3 + n2[x2 + 2];
                  break;
                }
                if (0 != (32 & y2)) {
                  t2 = 7;
                  break;
                }
                return t2 = 9, p2.msg = "invalid literal/length code", g2 = H, e3.bitb = E2, e3.bitk = A2, p2.avail_in = m2, p2.total_in += S2 - p2.next_in_index, p2.next_in_index = S2, e3.write = k2, e3.inflate_flush(p2, g2);
              case 2:
                for (b2 = c2; b2 > A2; ) {
                  if (0 === m2)
                    return e3.bitb = E2, e3.bitk = A2, p2.avail_in = m2, p2.total_in += S2 - p2.next_in_index, p2.next_in_index = S2, e3.write = k2, e3.inflate_flush(p2, g2);
                  g2 = 0, m2--, E2 |= (255 & p2.read_byte(S2++)) << A2, A2 += 8;
                }
                a2 += E2 & V[b2], E2 >>= b2, A2 -= b2, o2 = f2, n2 = r2, s2 = _2, t2 = 3;
              case 3:
                for (b2 = o2; b2 > A2; ) {
                  if (0 === m2)
                    return e3.bitb = E2, e3.bitk = A2, p2.avail_in = m2, p2.total_in += S2 - p2.next_in_index, p2.next_in_index = S2, e3.write = k2, e3.inflate_flush(p2, g2);
                  g2 = 0, m2--, E2 |= (255 & p2.read_byte(S2++)) << A2, A2 += 8;
                }
                if (x2 = 3 * (s2 + (E2 & V[b2])), E2 >>= n2[x2 + 1], A2 -= n2[x2 + 1], y2 = n2[x2], 0 != (16 & y2)) {
                  c2 = 15 & y2, d2 = n2[x2 + 2], t2 = 4;
                  break;
                }
                if (0 == (64 & y2)) {
                  o2 = y2, s2 = x2 / 3 + n2[x2 + 2];
                  break;
                }
                return t2 = 9, p2.msg = "invalid distance code", g2 = H, e3.bitb = E2, e3.bitk = A2, p2.avail_in = m2, p2.total_in += S2 - p2.next_in_index, p2.next_in_index = S2, e3.write = k2, e3.inflate_flush(p2, g2);
              case 4:
                for (b2 = c2; b2 > A2; ) {
                  if (0 === m2)
                    return e3.bitb = E2, e3.bitk = A2, p2.avail_in = m2, p2.total_in += S2 - p2.next_in_index, p2.next_in_index = S2, e3.write = k2, e3.inflate_flush(p2, g2);
                  g2 = 0, m2--, E2 |= (255 & p2.read_byte(S2++)) << A2, A2 += 8;
                }
                d2 += E2 & V[b2], E2 >>= b2, A2 -= b2, t2 = 5;
              case 5:
                for (R2 = k2 - d2; 0 > R2; )
                  R2 += e3.end;
                for (; 0 !== a2; ) {
                  if (0 === v2 && (k2 == e3.end && 0 !== e3.read && (k2 = 0, v2 = k2 < e3.read ? e3.read - k2 - 1 : e3.end - k2), 0 === v2 && (e3.write = k2, g2 = e3.inflate_flush(p2, g2), k2 = e3.write, v2 = k2 < e3.read ? e3.read - k2 - 1 : e3.end - k2, k2 == e3.end && 0 !== e3.read && (k2 = 0, v2 = k2 < e3.read ? e3.read - k2 - 1 : e3.end - k2), 0 === v2)))
                    return e3.bitb = E2, e3.bitk = A2, p2.avail_in = m2, p2.total_in += S2 - p2.next_in_index, p2.next_in_index = S2, e3.write = k2, e3.inflate_flush(p2, g2);
                  e3.win[k2++] = e3.win[R2++], v2--, R2 == e3.end && (R2 = 0), a2--;
                }
                t2 = 0;
                break;
              case 6:
                if (0 === v2 && (k2 == e3.end && 0 !== e3.read && (k2 = 0, v2 = k2 < e3.read ? e3.read - k2 - 1 : e3.end - k2), 0 === v2 && (e3.write = k2, g2 = e3.inflate_flush(p2, g2), k2 = e3.write, v2 = k2 < e3.read ? e3.read - k2 - 1 : e3.end - k2, k2 == e3.end && 0 !== e3.read && (k2 = 0, v2 = k2 < e3.read ? e3.read - k2 - 1 : e3.end - k2), 0 === v2)))
                  return e3.bitb = E2, e3.bitk = A2, p2.avail_in = m2, p2.total_in += S2 - p2.next_in_index, p2.next_in_index = S2, e3.write = k2, e3.inflate_flush(p2, g2);
                g2 = 0, e3.win[k2++] = l2, v2--, t2 = 0;
                break;
              case 7:
                if (A2 > 7 && (A2 -= 8, m2++, S2--), e3.write = k2, g2 = e3.inflate_flush(p2, g2), k2 = e3.write, v2 = k2 < e3.read ? e3.read - k2 - 1 : e3.end - k2, e3.read != e3.write)
                  return e3.bitb = E2, e3.bitk = A2, p2.avail_in = m2, p2.total_in += S2 - p2.next_in_index, p2.next_in_index = S2, e3.write = k2, e3.inflate_flush(p2, g2);
                t2 = 8;
              case 8:
                return g2 = 1, e3.bitb = E2, e3.bitk = A2, p2.avail_in = m2, p2.total_in += S2 - p2.next_in_index, p2.next_in_index = S2, e3.write = k2, e3.inflate_flush(p2, g2);
              case 9:
                return g2 = H, e3.bitb = E2, e3.bitk = A2, p2.avail_in = m2, p2.total_in += S2 - p2.next_in_index, p2.next_in_index = S2, e3.write = k2, e3.inflate_flush(p2, g2);
              default:
                return g2 = N, e3.bitb = E2, e3.bitk = A2, p2.avail_in = m2, p2.total_in += S2 - p2.next_in_index, p2.next_in_index = S2, e3.write = k2, e3.inflate_flush(p2, g2);
            }
        }, e2.free = () => {
        };
      }
      j.inflate_trees_fixed = (e2, t2, n2, i2) => (e2[0] = 9, t2[0] = 5, n2[0] = P, i2[0] = q, 0);
      const J = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      function Q(e2, t2) {
        const n2 = this;
        let i2, r2 = 0, a2 = 0, s2 = 0, o2 = 0;
        const l2 = [0], c2 = [0], u2 = new X();
        let f2 = 0, h2 = new Int32Array(4320);
        const _2 = new j();
        n2.bitk = 0, n2.bitb = 0, n2.win = new d(t2), n2.end = t2, n2.read = 0, n2.write = 0, n2.reset = (e3, t3) => {
          t3 && (t3[0] = 0), 6 == r2 && u2.free(e3), r2 = 0, n2.bitk = 0, n2.bitb = 0, n2.read = n2.write = 0;
        }, n2.reset(e2, null), n2.inflate_flush = (e3, t3) => {
          let i3, r3, a3;
          return r3 = e3.next_out_index, a3 = n2.read, i3 = (a3 > n2.write ? n2.end : n2.write) - a3, i3 > e3.avail_out && (i3 = e3.avail_out), 0 !== i3 && t3 == O && (t3 = 0), e3.avail_out -= i3, e3.total_out += i3, e3.next_out.set(n2.win.subarray(a3, a3 + i3), r3), r3 += i3, a3 += i3, a3 == n2.end && (a3 = 0, n2.write == n2.end && (n2.write = 0), i3 = n2.write - a3, i3 > e3.avail_out && (i3 = e3.avail_out), 0 !== i3 && t3 == O && (t3 = 0), e3.avail_out -= i3, e3.total_out += i3, e3.next_out.set(n2.win.subarray(a3, a3 + i3), r3), r3 += i3, a3 += i3), e3.next_out_index = r3, n2.read = a3, t3;
        }, n2.proc = (e3, t3) => {
          let d2, w2, p2, g2, b2, x2, y2, m2;
          for (g2 = e3.next_in_index, b2 = e3.avail_in, w2 = n2.bitb, p2 = n2.bitk, x2 = n2.write, y2 = x2 < n2.read ? n2.read - x2 - 1 : n2.end - x2; ; ) {
            let k2, v2, R2, E2, A2, S2, z2, D2;
            switch (r2) {
              case 0:
                for (; 3 > p2; ) {
                  if (0 === b2)
                    return n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
                  t3 = 0, b2--, w2 |= (255 & e3.read_byte(g2++)) << p2, p2 += 8;
                }
                switch (d2 = 7 & w2, f2 = 1 & d2, d2 >>> 1) {
                  case 0:
                    w2 >>>= 3, p2 -= 3, d2 = 7 & p2, w2 >>>= d2, p2 -= d2, r2 = 1;
                    break;
                  case 1:
                    k2 = [], v2 = [], R2 = [[]], E2 = [[]], j.inflate_trees_fixed(k2, v2, R2, E2), u2.init(k2[0], v2[0], R2[0], 0, E2[0], 0), w2 >>>= 3, p2 -= 3, r2 = 6;
                    break;
                  case 2:
                    w2 >>>= 3, p2 -= 3, r2 = 3;
                    break;
                  case 3:
                    return w2 >>>= 3, p2 -= 3, r2 = 9, e3.msg = "invalid block type", t3 = H, n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
                }
                break;
              case 1:
                for (; 32 > p2; ) {
                  if (0 === b2)
                    return n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
                  t3 = 0, b2--, w2 |= (255 & e3.read_byte(g2++)) << p2, p2 += 8;
                }
                if ((~w2 >>> 16 & 65535) != (65535 & w2))
                  return r2 = 9, e3.msg = "invalid stored block lengths", t3 = H, n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
                a2 = 65535 & w2, w2 = p2 = 0, r2 = 0 !== a2 ? 2 : 0 !== f2 ? 7 : 0;
                break;
              case 2:
                if (0 === b2)
                  return n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
                if (0 === y2 && (x2 == n2.end && 0 !== n2.read && (x2 = 0, y2 = x2 < n2.read ? n2.read - x2 - 1 : n2.end - x2), 0 === y2 && (n2.write = x2, t3 = n2.inflate_flush(e3, t3), x2 = n2.write, y2 = x2 < n2.read ? n2.read - x2 - 1 : n2.end - x2, x2 == n2.end && 0 !== n2.read && (x2 = 0, y2 = x2 < n2.read ? n2.read - x2 - 1 : n2.end - x2), 0 === y2)))
                  return n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
                if (t3 = 0, d2 = a2, d2 > b2 && (d2 = b2), d2 > y2 && (d2 = y2), n2.win.set(e3.read_buf(g2, d2), x2), g2 += d2, b2 -= d2, x2 += d2, y2 -= d2, 0 != (a2 -= d2))
                  break;
                r2 = 0 !== f2 ? 7 : 0;
                break;
              case 3:
                for (; 14 > p2; ) {
                  if (0 === b2)
                    return n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
                  t3 = 0, b2--, w2 |= (255 & e3.read_byte(g2++)) << p2, p2 += 8;
                }
                if (s2 = d2 = 16383 & w2, (31 & d2) > 29 || (d2 >> 5 & 31) > 29)
                  return r2 = 9, e3.msg = "too many length or distance symbols", t3 = H, n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
                if (d2 = 258 + (31 & d2) + (d2 >> 5 & 31), !i2 || i2.length < d2)
                  i2 = [];
                else
                  for (m2 = 0; d2 > m2; m2++)
                    i2[m2] = 0;
                w2 >>>= 14, p2 -= 14, o2 = 0, r2 = 4;
              case 4:
                for (; 4 + (s2 >>> 10) > o2; ) {
                  for (; 3 > p2; ) {
                    if (0 === b2)
                      return n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
                    t3 = 0, b2--, w2 |= (255 & e3.read_byte(g2++)) << p2, p2 += 8;
                  }
                  i2[J[o2++]] = 7 & w2, w2 >>>= 3, p2 -= 3;
                }
                for (; 19 > o2; )
                  i2[J[o2++]] = 0;
                if (l2[0] = 7, d2 = _2.inflate_trees_bits(i2, l2, c2, h2, e3), 0 != d2)
                  return (t3 = d2) == H && (i2 = null, r2 = 9), n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
                o2 = 0, r2 = 5;
              case 5:
                for (; d2 = s2, 258 + (31 & d2) + (d2 >> 5 & 31) > o2; ) {
                  let a3, u3;
                  for (d2 = l2[0]; d2 > p2; ) {
                    if (0 === b2)
                      return n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
                    t3 = 0, b2--, w2 |= (255 & e3.read_byte(g2++)) << p2, p2 += 8;
                  }
                  if (d2 = h2[3 * (c2[0] + (w2 & V[d2])) + 1], u3 = h2[3 * (c2[0] + (w2 & V[d2])) + 2], 16 > u3)
                    w2 >>>= d2, p2 -= d2, i2[o2++] = u3;
                  else {
                    for (m2 = 18 == u3 ? 7 : u3 - 14, a3 = 18 == u3 ? 11 : 3; d2 + m2 > p2; ) {
                      if (0 === b2)
                        return n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
                      t3 = 0, b2--, w2 |= (255 & e3.read_byte(g2++)) << p2, p2 += 8;
                    }
                    if (w2 >>>= d2, p2 -= d2, a3 += w2 & V[m2], w2 >>>= m2, p2 -= m2, m2 = o2, d2 = s2, m2 + a3 > 258 + (31 & d2) + (d2 >> 5 & 31) || 16 == u3 && 1 > m2)
                      return i2 = null, r2 = 9, e3.msg = "invalid bit length repeat", t3 = H, n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
                    u3 = 16 == u3 ? i2[m2 - 1] : 0;
                    do {
                      i2[m2++] = u3;
                    } while (0 != --a3);
                    o2 = m2;
                  }
                }
                if (c2[0] = -1, A2 = [], S2 = [], z2 = [], D2 = [], A2[0] = 9, S2[0] = 6, d2 = s2, d2 = _2.inflate_trees_dynamic(257 + (31 & d2), 1 + (d2 >> 5 & 31), i2, A2, S2, z2, D2, h2, e3), 0 != d2)
                  return d2 == H && (i2 = null, r2 = 9), t3 = d2, n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
                u2.init(A2[0], S2[0], h2, z2[0], h2, D2[0]), r2 = 6;
              case 6:
                if (n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, 1 != (t3 = u2.proc(n2, e3, t3)))
                  return n2.inflate_flush(e3, t3);
                if (t3 = 0, u2.free(e3), g2 = e3.next_in_index, b2 = e3.avail_in, w2 = n2.bitb, p2 = n2.bitk, x2 = n2.write, y2 = x2 < n2.read ? n2.read - x2 - 1 : n2.end - x2, 0 === f2) {
                  r2 = 0;
                  break;
                }
                r2 = 7;
              case 7:
                if (n2.write = x2, t3 = n2.inflate_flush(e3, t3), x2 = n2.write, y2 = x2 < n2.read ? n2.read - x2 - 1 : n2.end - x2, n2.read != n2.write)
                  return n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
                r2 = 8;
              case 8:
                return t3 = 1, n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
              case 9:
                return t3 = H, n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
              default:
                return t3 = N, n2.bitb = w2, n2.bitk = p2, e3.avail_in = b2, e3.total_in += g2 - e3.next_in_index, e3.next_in_index = g2, n2.write = x2, n2.inflate_flush(e3, t3);
            }
          }
        }, n2.free = (e3) => {
          n2.reset(e3, null), n2.win = null, h2 = null;
        }, n2.set_dictionary = (e3, t3, i3) => {
          n2.win.set(e3.subarray(t3, t3 + i3), 0), n2.read = n2.write = i3;
        }, n2.sync_point = () => 1 == r2 ? 1 : 0;
      }
      const $ = 13, ee = [0, 0, 255, 255];
      function te() {
        const e2 = this;
        function t2(e3) {
          return e3 && e3.istate ? (e3.total_in = e3.total_out = 0, e3.msg = null, e3.istate.mode = 7, e3.istate.blocks.reset(e3, null), 0) : N;
        }
        e2.mode = 0, e2.method = 0, e2.was = [0], e2.need = 0, e2.marker = 0, e2.wbits = 0, e2.inflateEnd = (t3) => (e2.blocks && e2.blocks.free(t3), e2.blocks = null, 0), e2.inflateInit = (n2, i2) => (n2.msg = null, e2.blocks = null, 8 > i2 || i2 > 15 ? (e2.inflateEnd(n2), N) : (e2.wbits = i2, n2.istate.blocks = new Q(n2, 1 << i2), t2(n2), 0)), e2.inflate = (e3, t3) => {
          let n2, i2;
          if (!e3 || !e3.istate || !e3.next_in)
            return N;
          const r2 = e3.istate;
          for (t3 = 4 == t3 ? O : 0, n2 = O; ; )
            switch (r2.mode) {
              case 0:
                if (0 === e3.avail_in)
                  return n2;
                if (n2 = t3, e3.avail_in--, e3.total_in++, 8 != (15 & (r2.method = e3.read_byte(e3.next_in_index++)))) {
                  r2.mode = $, e3.msg = "unknown compression method", r2.marker = 5;
                  break;
                }
                if (8 + (r2.method >> 4) > r2.wbits) {
                  r2.mode = $, e3.msg = "invalid win size", r2.marker = 5;
                  break;
                }
                r2.mode = 1;
              case 1:
                if (0 === e3.avail_in)
                  return n2;
                if (n2 = t3, e3.avail_in--, e3.total_in++, i2 = 255 & e3.read_byte(e3.next_in_index++), ((r2.method << 8) + i2) % 31 != 0) {
                  r2.mode = $, e3.msg = "incorrect header check", r2.marker = 5;
                  break;
                }
                if (0 == (32 & i2)) {
                  r2.mode = 7;
                  break;
                }
                r2.mode = 2;
              case 2:
                if (0 === e3.avail_in)
                  return n2;
                n2 = t3, e3.avail_in--, e3.total_in++, r2.need = (255 & e3.read_byte(e3.next_in_index++)) << 24 & 4278190080, r2.mode = 3;
              case 3:
                if (0 === e3.avail_in)
                  return n2;
                n2 = t3, e3.avail_in--, e3.total_in++, r2.need += (255 & e3.read_byte(e3.next_in_index++)) << 16 & 16711680, r2.mode = 4;
              case 4:
                if (0 === e3.avail_in)
                  return n2;
                n2 = t3, e3.avail_in--, e3.total_in++, r2.need += (255 & e3.read_byte(e3.next_in_index++)) << 8 & 65280, r2.mode = 5;
              case 5:
                return 0 === e3.avail_in ? n2 : (n2 = t3, e3.avail_in--, e3.total_in++, r2.need += 255 & e3.read_byte(e3.next_in_index++), r2.mode = 6, 2);
              case 6:
                return r2.mode = $, e3.msg = "need dictionary", r2.marker = 0, N;
              case 7:
                if (n2 = r2.blocks.proc(e3, n2), n2 == H) {
                  r2.mode = $, r2.marker = 0;
                  break;
                }
                if (0 == n2 && (n2 = t3), 1 != n2)
                  return n2;
                n2 = t3, r2.blocks.reset(e3, r2.was), r2.mode = 12;
              case 12:
                return e3.avail_in = 0, 1;
              case $:
                return H;
              default:
                return N;
            }
        }, e2.inflateSetDictionary = (e3, t3, n2) => {
          let i2 = 0, r2 = n2;
          if (!e3 || !e3.istate || 6 != e3.istate.mode)
            return N;
          const a2 = e3.istate;
          return r2 < 1 << a2.wbits || (r2 = (1 << a2.wbits) - 1, i2 = n2 - r2), a2.blocks.set_dictionary(t3, i2, r2), a2.mode = 7, 0;
        }, e2.inflateSync = (e3) => {
          let n2, i2, r2, a2, s2;
          if (!e3 || !e3.istate)
            return N;
          const o2 = e3.istate;
          if (o2.mode != $ && (o2.mode = $, o2.marker = 0), 0 === (n2 = e3.avail_in))
            return O;
          for (i2 = e3.next_in_index, r2 = o2.marker; 0 !== n2 && 4 > r2; )
            e3.read_byte(i2) == ee[r2] ? r2++ : r2 = 0 !== e3.read_byte(i2) ? 0 : 4 - r2, i2++, n2--;
          return e3.total_in += i2 - e3.next_in_index, e3.next_in_index = i2, e3.avail_in = n2, o2.marker = r2, 4 != r2 ? H : (a2 = e3.total_in, s2 = e3.total_out, t2(e3), e3.total_in = a2, e3.total_out = s2, o2.mode = 7, 0);
        }, e2.inflateSyncPoint = (e3) => e3 && e3.istate && e3.istate.blocks ? e3.istate.blocks.sync_point() : N;
      }
      function ne() {
      }
      ne.prototype = { inflateInit: function(e2) {
        const t2 = this;
        return t2.istate = new te(), e2 || (e2 = 15), t2.istate.inflateInit(t2, e2);
      }, inflate: function(e2) {
        const t2 = this;
        return t2.istate ? t2.istate.inflate(t2, e2) : N;
      }, inflateEnd: function() {
        const e2 = this;
        if (!e2.istate)
          return N;
        const t2 = e2.istate.inflateEnd(e2);
        return e2.istate = null, t2;
      }, inflateSync: function() {
        const e2 = this;
        return e2.istate ? e2.istate.inflateSync(e2) : N;
      }, inflateSetDictionary: function(e2, t2) {
        const n2 = this;
        return n2.istate ? n2.istate.inflateSetDictionary(n2, e2, t2) : N;
      }, read_byte: function(e2) {
        return this.next_in[e2];
      }, read_buf: function(e2, t2) {
        return this.next_in.subarray(e2, e2 + t2);
      } };
      const ie = { chunkSize: 524288, maxWorkers: "undefined" != typeof navigator && navigator.hardwareConcurrency || 2, terminateWorkerTimeout: 5e3, useWebWorkers: true, workerScripts: void 0 }, re = n.assign({}, ie);
      function ae() {
        return re;
      }
      function se(e2) {
        if (void 0 !== e2.baseURL && (re.baseURL = e2.baseURL), void 0 !== e2.chunkSize && (re.chunkSize = e2.chunkSize), void 0 !== e2.maxWorkers && (re.maxWorkers = e2.maxWorkers), void 0 !== e2.terminateWorkerTimeout && (re.terminateWorkerTimeout = e2.terminateWorkerTimeout), void 0 !== e2.useWebWorkers && (re.useWebWorkers = e2.useWebWorkers), void 0 !== e2.Deflate && (re.Deflate = e2.Deflate), void 0 !== e2.Inflate && (re.Inflate = e2.Inflate), void 0 !== e2.workerScripts) {
          if (e2.workerScripts.deflate) {
            if (!t.isArray(e2.workerScripts.deflate))
              throw new c("workerScripts.deflate must be an array");
            re.workerScripts || (re.workerScripts = {}), re.workerScripts.deflate = e2.workerScripts.deflate;
          }
          if (e2.workerScripts.inflate) {
            if (!t.isArray(e2.workerScripts.inflate))
              throw new c("workerScripts.inflate must be an array");
            re.workerScripts || (re.workerScripts = {}), re.workerScripts.inflate = e2.workerScripts.inflate;
          }
        }
      }
      const oe = [];
      for (let e2 = 0; 256 > e2; e2++) {
        let t2 = e2;
        for (let e3 = 0; 8 > e3; e3++)
          1 & t2 ? t2 = t2 >>> 1 ^ 3988292384 : t2 >>>= 1;
        oe[e2] = t2;
      }
      class le {
        constructor(e2) {
          this.crc = e2 || -1;
        }
        append(e2) {
          let t2 = 0 | this.crc;
          for (let n2 = 0, i2 = 0 | e2.length; i2 > n2; n2++)
            t2 = t2 >>> 8 ^ oe[255 & (t2 ^ e2[n2])];
          this.crc = t2;
        }
        get() {
          return ~this.crc;
        }
      }
      function ce(e2) {
        if (void 0 === p) {
          const t2 = new d((e2 = unescape(encodeURIComponent(e2))).length);
          for (let n2 = 0; n2 < t2.length; n2++)
            t2[n2] = e2.charCodeAt(n2);
          return t2;
        }
        return new p().encode(e2);
      }
      const de = { concat(e2, t2) {
        if (0 === e2.length || 0 === t2.length)
          return e2.concat(t2);
        const n2 = e2[e2.length - 1], i2 = de.getPartial(n2);
        return 32 === i2 ? e2.concat(t2) : de._shiftRight(t2, i2, 0 | n2, e2.slice(0, e2.length - 1));
      }, bitLength(e2) {
        const t2 = e2.length;
        if (0 === t2)
          return 0;
        const n2 = e2[t2 - 1];
        return 32 * (t2 - 1) + de.getPartial(n2);
      }, clamp(e2, t2) {
        if (32 * e2.length < t2)
          return e2;
        const n2 = (e2 = e2.slice(0, a.ceil(t2 / 32))).length;
        return t2 &= 31, n2 > 0 && t2 && (e2[n2 - 1] = de.partial(t2, e2[n2 - 1] & 2147483648 >> t2 - 1, 1)), e2;
      }, partial: (e2, t2, n2) => 32 === e2 ? t2 : (n2 ? 0 | t2 : t2 << 32 - e2) + 1099511627776 * e2, getPartial: (e2) => a.round(e2 / 1099511627776) || 32, _shiftRight(e2, t2, n2, i2) {
        for (void 0 === i2 && (i2 = []); t2 >= 32; t2 -= 32)
          i2.push(n2), n2 = 0;
        if (0 === t2)
          return i2.concat(e2);
        for (let r3 = 0; r3 < e2.length; r3++)
          i2.push(n2 | e2[r3] >>> t2), n2 = e2[r3] << 32 - t2;
        const r2 = e2.length ? e2[e2.length - 1] : 0, a2 = de.getPartial(r2);
        return i2.push(de.partial(t2 + a2 & 31, t2 + a2 > 32 ? n2 : i2.pop(), 1)), i2;
      } }, ue = { bytes: { fromBits(e2) {
        const t2 = de.bitLength(e2) / 8, n2 = new d(t2);
        let i2;
        for (let r2 = 0; t2 > r2; r2++)
          0 == (3 & r2) && (i2 = e2[r2 / 4]), n2[r2] = i2 >>> 24, i2 <<= 8;
        return n2;
      }, toBits(e2) {
        const t2 = [];
        let n2, i2 = 0;
        for (n2 = 0; n2 < e2.length; n2++)
          i2 = i2 << 8 | e2[n2], 3 == (3 & n2) && (t2.push(i2), i2 = 0);
        return 3 & n2 && t2.push(de.partial(8 * (3 & n2), i2)), t2;
      } } }, fe = { sha1: function(e2) {
        e2 ? (this._h = e2._h.slice(0), this._buffer = e2._buffer.slice(0), this._length = e2._length) : this.reset();
      } };
      fe.sha1.prototype = { blockSize: 512, reset: function() {
        const e2 = this;
        return e2._h = this._init.slice(0), e2._buffer = [], e2._length = 0, e2;
      }, update: function(e2) {
        const t2 = this;
        "string" == typeof e2 && (e2 = ue.utf8String.toBits(e2));
        const n2 = t2._buffer = de.concat(t2._buffer, e2), i2 = t2._length, r2 = t2._length = i2 + de.bitLength(e2);
        if (r2 > 9007199254740991)
          throw new c("Cannot hash more than 2^53 - 1 bits");
        const a2 = new f(n2);
        let s2 = 0;
        for (let e3 = t2.blockSize + i2 - (t2.blockSize + i2 & t2.blockSize - 1); r2 >= e3; e3 += t2.blockSize)
          t2._block(a2.subarray(16 * s2, 16 * (s2 + 1))), s2 += 1;
        return n2.splice(0, 16 * s2), t2;
      }, finalize: function() {
        const e2 = this;
        let t2 = e2._buffer;
        const n2 = e2._h;
        t2 = de.concat(t2, [de.partial(1, 1)]);
        for (let e3 = t2.length + 2; 15 & e3; e3++)
          t2.push(0);
        for (t2.push(a.floor(e2._length / 4294967296)), t2.push(0 | e2._length); t2.length; )
          e2._block(t2.splice(0, 16));
        return e2.reset(), n2;
      }, _init: [1732584193, 4023233417, 2562383102, 271733878, 3285377520], _key: [1518500249, 1859775393, 2400959708, 3395469782], _f: (e2, t2, n2, i2) => e2 > 19 ? e2 > 39 ? e2 > 59 ? e2 > 79 ? void 0 : t2 ^ n2 ^ i2 : t2 & n2 | t2 & i2 | n2 & i2 : t2 ^ n2 ^ i2 : t2 & n2 | ~t2 & i2, _S: (e2, t2) => t2 << e2 | t2 >>> 32 - e2, _block: function(e2) {
        const n2 = this, i2 = n2._h, r2 = t(80);
        for (let t2 = 0; 16 > t2; t2++)
          r2[t2] = e2[t2];
        let s2 = i2[0], o2 = i2[1], l2 = i2[2], c2 = i2[3], d2 = i2[4];
        for (let e3 = 0; 79 >= e3; e3++) {
          16 > e3 || (r2[e3] = n2._S(1, r2[e3 - 3] ^ r2[e3 - 8] ^ r2[e3 - 14] ^ r2[e3 - 16]));
          const t2 = n2._S(5, s2) + n2._f(e3, o2, l2, c2) + d2 + r2[e3] + n2._key[a.floor(e3 / 20)] | 0;
          d2 = c2, c2 = l2, l2 = n2._S(30, o2), o2 = s2, s2 = t2;
        }
        i2[0] = i2[0] + s2 | 0, i2[1] = i2[1] + o2 | 0, i2[2] = i2[2] + l2 | 0, i2[3] = i2[3] + c2 | 0, i2[4] = i2[4] + d2 | 0;
      } };
      const he = { getRandomValues(e2) {
        const t2 = new f(e2.buffer), n2 = (e3) => {
          let t3 = 987654321;
          const n3 = 4294967295;
          return () => (t3 = 36969 * (65535 & t3) + (t3 >> 16) & n3, (((t3 << 16) + (e3 = 18e3 * (65535 & e3) + (e3 >> 16) & n3) & n3) / 4294967296 + 0.5) * (a.random() > 0.5 ? 1 : -1));
        };
        for (let i2, r2 = 0; r2 < e2.length; r2 += 4) {
          const e3 = n2(4294967296 * (i2 || a.random()));
          i2 = 987654071 * e3(), t2[r2 / 4] = 4294967296 * e3() | 0;
        }
        return e2;
      } }, _e = { importKey: (e2) => new _e.hmacSha1(ue.bytes.toBits(e2)), pbkdf2(e2, t2, n2, i2) {
        if (n2 = n2 || 1e4, 0 > i2 || 0 > n2)
          throw new c("invalid params to pbkdf2");
        const r2 = 1 + (i2 >> 5) << 2;
        let a2, s2, o2, l2, d2;
        const u2 = new ArrayBuffer(r2), f2 = new h(u2);
        let _2 = 0;
        const w2 = de;
        for (t2 = ue.bytes.toBits(t2), d2 = 1; (r2 || 1) > _2; d2++) {
          for (a2 = s2 = e2.encrypt(w2.concat(t2, [d2])), o2 = 1; n2 > o2; o2++)
            for (s2 = e2.encrypt(s2), l2 = 0; l2 < s2.length; l2++)
              a2[l2] ^= s2[l2];
          for (o2 = 0; (r2 || 1) > _2 && o2 < a2.length; o2++)
            f2.setInt32(_2, a2[o2]), _2 += 4;
        }
        return u2.slice(0, i2 / 8);
      }, hmacSha1: class {
        constructor(e2) {
          const t2 = this, n2 = t2._hash = fe.sha1, i2 = [[], []], r2 = n2.prototype.blockSize / 32;
          t2._baseHash = [new n2(), new n2()], e2.length > r2 && (e2 = n2.hash(e2));
          for (let t3 = 0; r2 > t3; t3++)
            i2[0][t3] = 909522486 ^ e2[t3], i2[1][t3] = 1549556828 ^ e2[t3];
          t2._baseHash[0].update(i2[0]), t2._baseHash[1].update(i2[1]), t2._resultHash = new n2(t2._baseHash[0]);
        }
        reset() {
          const e2 = this;
          e2._resultHash = new e2._hash(e2._baseHash[0]), e2._updated = false;
        }
        update(e2) {
          this._updated = true, this._resultHash.update(e2);
        }
        digest() {
          const e2 = this, t2 = e2._resultHash.finalize(), n2 = new e2._hash(e2._baseHash[1]).update(t2).finalize();
          return e2.reset(), n2;
        }
        encrypt(e2) {
          if (this._updated)
            throw new c("encrypt on already updated hmac called!");
          return this.update(e2), this.digest(e2);
        }
      } }, we = "Invalid pasword", pe = 16, ge = { name: "PBKDF2" }, be = n.assign({ hash: { name: "HMAC" } }, ge), xe = n.assign({ iterations: 1e3, hash: { name: "SHA-1" } }, ge), ye = ["deriveBits"], me = [8, 12, 16], ke = [16, 24, 32], ve = 10, Re = [0, 0, 0, 0], Ee = void 0 !== y, Ae = Ee && void 0 !== y.subtle, Se = ue.bytes, ze = class {
        constructor(e2) {
          const t2 = this;
          t2._tables = [[[], [], [], [], []], [[], [], [], [], []]], t2._tables[0][0][0] || t2._precompute();
          const n2 = t2._tables[0][4], i2 = t2._tables[1], r2 = e2.length;
          let a2, s2, o2, l2 = 1;
          if (4 !== r2 && 6 !== r2 && 8 !== r2)
            throw new c("invalid aes key size");
          for (t2._key = [s2 = e2.slice(0), o2 = []], a2 = r2; 4 * r2 + 28 > a2; a2++) {
            let e3 = s2[a2 - 1];
            (a2 % r2 == 0 || 8 === r2 && a2 % r2 == 4) && (e3 = n2[e3 >>> 24] << 24 ^ n2[e3 >> 16 & 255] << 16 ^ n2[e3 >> 8 & 255] << 8 ^ n2[255 & e3], a2 % r2 == 0 && (e3 = e3 << 8 ^ e3 >>> 24 ^ l2 << 24, l2 = l2 << 1 ^ 283 * (l2 >> 7))), s2[a2] = s2[a2 - r2] ^ e3;
          }
          for (let e3 = 0; a2; e3++, a2--) {
            const t3 = s2[3 & e3 ? a2 : a2 - 4];
            o2[e3] = 4 >= a2 || 4 > e3 ? t3 : i2[0][n2[t3 >>> 24]] ^ i2[1][n2[t3 >> 16 & 255]] ^ i2[2][n2[t3 >> 8 & 255]] ^ i2[3][n2[255 & t3]];
          }
        }
        encrypt(e2) {
          return this._crypt(e2, 0);
        }
        decrypt(e2) {
          return this._crypt(e2, 1);
        }
        _precompute() {
          const e2 = this._tables[0], t2 = this._tables[1], n2 = e2[4], i2 = t2[4], r2 = [], a2 = [];
          let s2, o2, l2, c2;
          for (let e3 = 0; 256 > e3; e3++)
            a2[(r2[e3] = e3 << 1 ^ 283 * (e3 >> 7)) ^ e3] = e3;
          for (let d2 = s2 = 0; !n2[d2]; d2 ^= o2 || 1, s2 = a2[s2] || 1) {
            let a3 = s2 ^ s2 << 1 ^ s2 << 2 ^ s2 << 3 ^ s2 << 4;
            a3 = a3 >> 8 ^ 255 & a3 ^ 99, n2[d2] = a3, i2[a3] = d2, c2 = r2[l2 = r2[o2 = r2[d2]]];
            let u2 = 16843009 * c2 ^ 65537 * l2 ^ 257 * o2 ^ 16843008 * d2, f2 = 257 * r2[a3] ^ 16843008 * a3;
            for (let n3 = 0; 4 > n3; n3++)
              e2[n3][d2] = f2 = f2 << 24 ^ f2 >>> 8, t2[n3][a3] = u2 = u2 << 24 ^ u2 >>> 8;
          }
          for (let n3 = 0; 5 > n3; n3++)
            e2[n3] = e2[n3].slice(0), t2[n3] = t2[n3].slice(0);
        }
        _crypt(e2, t2) {
          if (4 !== e2.length)
            throw new c("invalid aes block size");
          const n2 = this._key[t2], i2 = n2.length / 4 - 2, r2 = [0, 0, 0, 0], a2 = this._tables[t2], s2 = a2[0], o2 = a2[1], l2 = a2[2], d2 = a2[3], u2 = a2[4];
          let f2, h2, _2, w2 = e2[0] ^ n2[0], p2 = e2[t2 ? 3 : 1] ^ n2[1], g2 = e2[2] ^ n2[2], b2 = e2[t2 ? 1 : 3] ^ n2[3], x2 = 4;
          for (let e3 = 0; i2 > e3; e3++)
            f2 = s2[w2 >>> 24] ^ o2[p2 >> 16 & 255] ^ l2[g2 >> 8 & 255] ^ d2[255 & b2] ^ n2[x2], h2 = s2[p2 >>> 24] ^ o2[g2 >> 16 & 255] ^ l2[b2 >> 8 & 255] ^ d2[255 & w2] ^ n2[x2 + 1], _2 = s2[g2 >>> 24] ^ o2[b2 >> 16 & 255] ^ l2[w2 >> 8 & 255] ^ d2[255 & p2] ^ n2[x2 + 2], b2 = s2[b2 >>> 24] ^ o2[w2 >> 16 & 255] ^ l2[p2 >> 8 & 255] ^ d2[255 & g2] ^ n2[x2 + 3], x2 += 4, w2 = f2, p2 = h2, g2 = _2;
          for (let e3 = 0; 4 > e3; e3++)
            r2[t2 ? 3 & -e3 : e3] = u2[w2 >>> 24] << 24 ^ u2[p2 >> 16 & 255] << 16 ^ u2[g2 >> 8 & 255] << 8 ^ u2[255 & b2] ^ n2[x2++], f2 = w2, w2 = p2, p2 = g2, g2 = b2, b2 = f2;
          return r2;
        }
      }, De = class {
        constructor(e2, t2) {
          this._prf = e2, this._initIv = t2, this._iv = t2;
        }
        reset() {
          this._iv = this._initIv;
        }
        update(e2) {
          return this.calculate(this._prf, e2, this._iv);
        }
        incWord(e2) {
          if (255 == (e2 >> 24 & 255)) {
            let t2 = e2 >> 16 & 255, n2 = e2 >> 8 & 255, i2 = 255 & e2;
            255 === t2 ? (t2 = 0, 255 === n2 ? (n2 = 0, 255 === i2 ? i2 = 0 : ++i2) : ++n2) : ++t2, e2 = 0, e2 += t2 << 16, e2 += n2 << 8, e2 += i2;
          } else
            e2 += 1 << 24;
          return e2;
        }
        incCounter(e2) {
          0 === (e2[0] = this.incWord(e2[0])) && (e2[1] = this.incWord(e2[1]));
        }
        calculate(e2, t2, n2) {
          let i2;
          if (!(i2 = t2.length))
            return [];
          const r2 = de.bitLength(t2);
          for (let r3 = 0; i2 > r3; r3 += 4) {
            this.incCounter(n2);
            const i3 = e2.encrypt(n2);
            t2[r3] ^= i3[0], t2[r3 + 1] ^= i3[1], t2[r3 + 2] ^= i3[2], t2[r3 + 3] ^= i3[3];
          }
          return de.clamp(t2, r2);
        }
      }, Fe = _e.hmacSha1;
      class Te {
        constructor(e2, t2, i2) {
          n.assign(this, { password: e2, signed: t2, strength: i2 - 1, pendingInput: new d(0) });
        }
        async append(e2) {
          const n2 = this;
          if (n2.password) {
            const i2 = Ie(e2, 0, me[n2.strength] + 2);
            await (async (e3, t2, n3) => {
              await Be(e3, n3, Ie(t2, 0, me[e3.strength]));
              const i3 = Ie(t2, me[e3.strength]), r2 = e3.keys.passwordVerification;
              if (r2[0] != i3[0] || r2[1] != i3[1])
                throw new c(we);
            })(n2, i2, n2.password), n2.password = null, n2.aesCtrGladman = new De(new ze(n2.keys.key), t.from(Re)), n2.hmac = new Fe(n2.keys.authentication), e2 = Ie(e2, me[n2.strength] + 2);
          }
          return Ce(n2, e2, new d(e2.length - ve - (e2.length - ve) % pe), 0, ve, true);
        }
        flush() {
          const e2 = this, t2 = e2.pendingInput, n2 = Ie(t2, 0, t2.length - ve), i2 = Ie(t2, t2.length - ve);
          let r2 = new d(0);
          if (n2.length) {
            const t3 = Se.toBits(n2);
            e2.hmac.update(t3);
            const i3 = e2.aesCtrGladman.update(t3);
            r2 = Se.fromBits(i3);
          }
          let a2 = true;
          if (e2.signed) {
            const t3 = Ie(Se.fromBits(e2.hmac.digest()), 0, ve);
            for (let e3 = 0; ve > e3; e3++)
              t3[e3] != i2[e3] && (a2 = false);
          }
          return { valid: a2, data: r2 };
        }
      }
      class Ue {
        constructor(e2, t2) {
          n.assign(this, { password: e2, strength: t2 - 1, pendingInput: new d(0) });
        }
        async append(e2) {
          const n2 = this;
          let i2 = new d(0);
          n2.password && (i2 = await (async (e3, t2) => {
            const n3 = (i3 = new d(me[e3.strength]), Ee && "function" == typeof y.getRandomValues ? y.getRandomValues(i3) : he.getRandomValues(i3));
            var i3;
            return await Be(e3, t2, n3), We(n3, e3.keys.passwordVerification);
          })(n2, n2.password), n2.password = null, n2.aesCtrGladman = new De(new ze(n2.keys.key), t.from(Re)), n2.hmac = new Fe(n2.keys.authentication));
          const r2 = new d(i2.length + e2.length - e2.length % pe);
          return r2.set(i2, 0), Ce(n2, e2, r2, i2.length, 0);
        }
        flush() {
          const e2 = this;
          let t2 = new d(0);
          if (e2.pendingInput.length) {
            const n3 = e2.aesCtrGladman.update(Se.toBits(e2.pendingInput));
            e2.hmac.update(n3), t2 = Se.fromBits(n3);
          }
          const n2 = Ie(Se.fromBits(e2.hmac.digest()), 0, ve);
          return { data: We(t2, n2), signature: n2 };
        }
      }
      function Ce(e2, t2, n2, i2, r2, a2) {
        const s2 = t2.length - r2;
        let o2;
        for (e2.pendingInput.length && (t2 = We(e2.pendingInput, t2), n2 = ((e3, t3) => {
          if (t3 && t3 > e3.length) {
            const n3 = e3;
            (e3 = new d(t3)).set(n3, 0);
          }
          return e3;
        })(n2, s2 - s2 % pe)), o2 = 0; s2 - pe >= o2; o2 += pe) {
          const r3 = Se.toBits(Ie(t2, o2, o2 + pe));
          a2 && e2.hmac.update(r3);
          const s3 = e2.aesCtrGladman.update(r3);
          a2 || e2.hmac.update(s3), n2.set(Se.fromBits(s3), o2 + i2);
        }
        return e2.pendingInput = Ie(t2, o2), n2;
      }
      async function Be(e2, t2, i2) {
        const r2 = ce(t2), a2 = await ((e3, t3, n2, i3, r3) => Ee && Ae && "function" == typeof y.subtle.importKey ? y.subtle.importKey("raw", t3, n2, false, r3) : _e.importKey(t3))(0, r2, be, 0, ye), s2 = await (async (e3, t3, n2) => Ee && Ae && "function" == typeof y.subtle.deriveBits ? await y.subtle.deriveBits(e3, t3, n2) : _e.pbkdf2(t3, e3.salt, xe.iterations, n2))(n.assign({ salt: i2 }, xe), a2, 8 * (2 * ke[e2.strength] + 2)), o2 = new d(s2);
        e2.keys = { key: Se.toBits(Ie(o2, 0, ke[e2.strength])), authentication: Se.toBits(Ie(o2, ke[e2.strength], 2 * ke[e2.strength])), passwordVerification: Ie(o2, 2 * ke[e2.strength]) };
      }
      function We(e2, t2) {
        let n2 = e2;
        return e2.length + t2.length && (n2 = new d(e2.length + t2.length), n2.set(e2, 0), n2.set(t2, e2.length)), n2;
      }
      function Ie(e2, t2, n2) {
        return e2.subarray(t2, n2);
      }
      class Me {
        constructor(e2, t2) {
          n.assign(this, { password: e2, passwordVerification: t2 }), Oe(this, e2);
        }
        append(e2) {
          const t2 = this;
          if (t2.password) {
            const n2 = Ne(t2, e2.subarray(0, 12));
            if (t2.password = null, n2[11] != t2.passwordVerification)
              throw new c(we);
            e2 = e2.subarray(12);
          }
          return Ne(t2, e2);
        }
        flush() {
          return { valid: true, data: new d(0) };
        }
      }
      class Le {
        constructor(e2, t2) {
          n.assign(this, { password: e2, passwordVerification: t2 }), Oe(this, e2);
        }
        append(e2) {
          const t2 = this;
          let n2, i2;
          if (t2.password) {
            t2.password = null;
            const r2 = y.getRandomValues(new d(12));
            r2[11] = t2.passwordVerification, n2 = new d(e2.length + r2.length), n2.set(He(t2, r2), 0), i2 = 12;
          } else
            n2 = new d(e2.length), i2 = 0;
          return n2.set(He(t2, e2), i2), n2;
        }
        flush() {
          return { data: new d(0) };
        }
      }
      function Ne(e2, t2) {
        const n2 = new d(t2.length);
        for (let i2 = 0; i2 < t2.length; i2++)
          n2[i2] = Pe(e2) ^ t2[i2], Ve(e2, n2[i2]);
        return n2;
      }
      function He(e2, t2) {
        const n2 = new d(t2.length);
        for (let i2 = 0; i2 < t2.length; i2++)
          n2[i2] = Pe(e2) ^ t2[i2], Ve(e2, t2[i2]);
        return n2;
      }
      function Oe(e2, t2) {
        e2.keys = [305419896, 591751049, 878082192], e2.crcKey0 = new le(e2.keys[0]), e2.crcKey2 = new le(e2.keys[2]);
        for (let n2 = 0; n2 < t2.length; n2++)
          Ve(e2, t2.charCodeAt(n2));
      }
      function Ve(e2, t2) {
        e2.crcKey0.append([t2]), e2.keys[0] = ~e2.crcKey0.get(), e2.keys[1] = Ze(e2.keys[1] + qe(e2.keys[0])), e2.keys[1] = Ze(a.imul(e2.keys[1], 134775813) + 1), e2.crcKey2.append([e2.keys[1] >>> 24]), e2.keys[2] = ~e2.crcKey2.get();
      }
      function Pe(e2) {
        const t2 = 2 | e2.keys[2];
        return qe(a.imul(t2, 1 ^ t2) >>> 8);
      }
      function qe(e2) {
        return 255 & e2;
      }
      function Ze(e2) {
        return 4294967295 & e2;
      }
      const Ke = "deflate", Ge = "inflate", Ye = "Invalid signature";
      class je {
        constructor(e2, { signature: t2, password: i2, signed: r2, compressed: a2, zipCrypto: s2, passwordVerification: o2, encryptionStrength: l2 }, { chunkSize: c2 }) {
          const d2 = !!i2;
          n.assign(this, { signature: t2, encrypted: d2, signed: r2, compressed: a2, inflate: a2 && new e2({ chunkSize: c2 }), crc32: r2 && new le(), zipCrypto: s2, decrypt: d2 && s2 ? new Me(i2, o2) : new Te(i2, r2, l2) });
        }
        async append(e2) {
          const t2 = this;
          return t2.encrypted && e2.length && (e2 = await t2.decrypt.append(e2)), t2.compressed && e2.length && (e2 = await t2.inflate.append(e2)), (!t2.encrypted || t2.zipCrypto) && t2.signed && e2.length && t2.crc32.append(e2), e2;
        }
        async flush() {
          const e2 = this;
          let t2, n2 = new d(0);
          if (e2.encrypted) {
            const t3 = e2.decrypt.flush();
            if (!t3.valid)
              throw new c(Ye);
            n2 = t3.data;
          }
          if ((!e2.encrypted || e2.zipCrypto) && e2.signed) {
            const n3 = new h(new d(4).buffer);
            if (t2 = e2.crc32.get(), n3.setUint32(0, t2), e2.signature != n3.getUint32(0, false))
              throw new c(Ye);
          }
          return e2.compressed && (n2 = await e2.inflate.append(n2) || new d(0), await e2.inflate.flush()), { data: n2, signature: t2 };
        }
      }
      class Xe {
        constructor(e2, { encrypted: t2, signed: i2, compressed: r2, level: a2, zipCrypto: s2, password: o2, passwordVerification: l2, encryptionStrength: c2 }, { chunkSize: d2 }) {
          n.assign(this, { encrypted: t2, signed: i2, compressed: r2, deflate: r2 && new e2({ level: a2 || 5, chunkSize: d2 }), crc32: i2 && new le(), zipCrypto: s2, encrypt: t2 && s2 ? new Le(o2, l2) : new Ue(o2, c2) });
        }
        async append(e2) {
          const t2 = this;
          let n2 = e2;
          return t2.compressed && e2.length && (n2 = await t2.deflate.append(e2)), t2.encrypted && n2.length && (n2 = await t2.encrypt.append(n2)), (!t2.encrypted || t2.zipCrypto) && t2.signed && e2.length && t2.crc32.append(e2), n2;
        }
        async flush() {
          const e2 = this;
          let t2, n2 = new d(0);
          if (e2.compressed && (n2 = await e2.deflate.flush() || new d(0)), e2.encrypted) {
            n2 = await e2.encrypt.append(n2);
            const i2 = e2.encrypt.flush();
            t2 = i2.signature;
            const r2 = new d(n2.length + i2.data.length);
            r2.set(n2, 0), r2.set(i2.data, n2.length), n2 = r2;
          }
          return e2.encrypted && !e2.zipCrypto || !e2.signed || (t2 = e2.crc32.get()), { data: n2, signature: t2 };
        }
      }
      const Je = "init", Qe = "append", $e = "flush";
      let et = true;
      var tt = (e2, t2, i2, r2, a2, s2, o2) => (n.assign(e2, { busy: true, codecConstructor: t2, options: n.assign({}, i2), scripts: o2, terminate() {
        e2.worker && !e2.busy && (e2.worker.terminate(), e2.interface = null);
      }, onTaskFinished() {
        e2.busy = false, a2(e2);
      } }), s2 ? ((e3, t3) => {
        let n2;
        const i3 = { type: "module" };
        if (!e3.interface) {
          if (et)
            try {
              e3.worker = r3({}, t3.baseURL);
            } catch (n3) {
              et = false, e3.worker = r3(i3, t3.baseURL);
            }
          else
            e3.worker = r3(i3, t3.baseURL);
          e3.worker.addEventListener("message", (t4) => {
            const i4 = t4.data;
            if (n2) {
              const t5 = i4.error, r4 = i4.type;
              if (t5) {
                const i5 = new c(t5.message);
                i5.stack = t5.stack, n2.reject(i5), n2 = null, e3.onTaskFinished();
              } else if (r4 == Je || r4 == $e || r4 == Qe) {
                const t6 = i4.data;
                r4 == $e ? (n2.resolve({ data: new d(t6), signature: i4.signature }), n2 = null, e3.onTaskFinished()) : n2.resolve(t6 && new d(t6));
              }
            }
          }, false), e3.interface = { append: (e4) => a3({ type: Qe, data: e4 }), flush: () => a3({ type: $e }), abort() {
            e3.onTaskFinished();
          } };
        }
        return e3.interface;
        function r3(t4, n3) {
          let i4, r4;
          i4 = e3.scripts[0], "function" == typeof i4 && (i4 = i4());
          try {
            r4 = new l(i4, n3);
          } catch (e4) {
            r4 = i4;
          }
          return new Worker(r4, t4);
        }
        async function a3(i4) {
          if (!n2) {
            const n3 = e3.options, i5 = e3.scripts.slice(1);
            await s3({ scripts: i5, type: Je, options: n3, config: { chunkSize: t3.chunkSize } });
          }
          return s3(i4);
        }
        function s3(t4) {
          const i4 = e3.worker, r4 = new w((e4, t5) => n2 = { resolve: e4, reject: t5 });
          try {
            if (t4.data)
              try {
                t4.data = t4.data.buffer, i4.postMessage(t4, [t4.data]);
              } catch (e4) {
                i4.postMessage(t4);
              }
            else
              i4.postMessage(t4);
          } catch (t5) {
            n2.reject(t5), n2 = null, e3.onTaskFinished();
          }
          return r4;
        }
      })(e2, r2) : ((e3, t3) => {
        const n2 = ((e4, t4, n3) => t4.codecType.startsWith(Ke) ? new Xe(e4, t4, n3) : t4.codecType.startsWith(Ge) ? new je(e4, t4, n3) : void 0)(e3.codecConstructor, e3.options, t3);
        return { async append(t4) {
          try {
            return await n2.append(t4);
          } catch (t5) {
            throw e3.onTaskFinished(), t5;
          }
        }, async flush() {
          try {
            return await n2.flush();
          } finally {
            e3.onTaskFinished();
          }
        }, abort() {
          e3.onTaskFinished();
        } };
      })(e2, r2));
      let nt = [];
      const it = [];
      function rt(e2, t2, n2) {
        const i2 = !(!t2.compressed && !t2.signed && !t2.encrypted) && (t2.useWebWorkers || void 0 === t2.useWebWorkers && n2.useWebWorkers), r2 = i2 && n2.workerScripts ? n2.workerScripts[t2.codecType] : [];
        if (nt.length < n2.maxWorkers) {
          const s2 = {};
          return nt.push(s2), tt(s2, e2, t2, n2, a2, i2, r2);
        }
        {
          const s2 = nt.find((e3) => !e3.busy);
          return s2 ? (at(s2), tt(s2, e2, t2, n2, a2, i2, r2)) : new w((n3) => it.push({ resolve: n3, codecConstructor: e2, options: t2, webWorker: i2, scripts: r2 }));
        }
        function a2(e3) {
          if (it.length) {
            const [{ resolve: t3, codecConstructor: i3, options: r3, webWorker: s2, scripts: o2 }] = it.splice(0, 1);
            t3(tt(e3, i3, r3, n2, a2, s2, o2));
          } else
            e3.worker ? (at(e3), Number.isFinite(n2.terminateWorkerTimeout) && n2.terminateWorkerTimeout >= 0 && (e3.terminateTimeout = setTimeout(() => {
              nt = nt.filter((t3) => t3 != e3), e3.terminate();
            }, n2.terminateWorkerTimeout))) : nt = nt.filter((t3) => t3 != e3);
        }
      }
      function at(e2) {
        e2.terminateTimeout && (clearTimeout(e2.terminateTimeout), e2.terminateTimeout = null);
      }
      const st = "Abort error";
      async function ot(e2, t2, n2, i2, r2, s2, o2) {
        const l2 = a.max(s2.chunkSize, 64);
        return async function s3(c2 = 0, d2 = 0) {
          const u2 = o2.signal, f2 = r2();
          if (f2 > c2) {
            lt(u2, e2);
            const r3 = await t2.readUint8Array(c2 + i2, a.min(l2, f2 - c2)), h2 = r3.length;
            lt(u2, e2);
            const _2 = await e2.append(r3);
            if (lt(u2, e2), d2 += await ct(n2, _2), o2.onprogress)
              try {
                o2.onprogress(c2 + h2, f2);
              } catch (e3) {
              }
            return s3(c2 + l2, d2);
          }
          {
            const t3 = await e2.flush();
            return d2 += await ct(n2, t3.data), { signature: t3.signature, length: d2 };
          }
        }();
      }
      function lt(e2, t2) {
        if (e2 && e2.aborted)
          throw t2.abort(), new c(st);
      }
      async function ct(e2, t2) {
        return t2.length && await e2.writeUint8Array(t2), t2.length;
      }
      const dt = "HTTP error ", ut = "HTTP Range not supported", ft = "Reader is not seekable", ht = "text/plain", _t = "GET";
      class wt {
        constructor() {
          this.size = 0;
        }
        init() {
          this.initialized = true;
        }
      }
      class pt extends wt {
      }
      class gt extends wt {
        writeUint8Array(e2) {
          this.size += e2.length;
        }
      }
      class bt extends pt {
        constructor(e2) {
          super(), this.blob = e2, this.size = e2.size;
        }
        async readUint8Array(e2, t2) {
          if (this.blob.arrayBuffer)
            return new d(await this.blob.slice(e2, e2 + t2).arrayBuffer());
          {
            const n2 = new b();
            return new w((i2, r2) => {
              n2.onload = (e3) => i2(new d(e3.target.result)), n2.onerror = () => r2(n2.error), n2.readAsArrayBuffer(this.blob.slice(e2, e2 + t2));
            });
          }
        }
      }
      class xt extends gt {
        constructor(e2) {
          super(), this.contentType = e2, this.arrayBuffersMaxlength = 8, yt(this);
        }
        writeUint8Array(e2) {
          super.writeUint8Array(e2), this.arrayBuffers.length == this.arrayBuffersMaxlength && mt(this), this.arrayBuffers.push(e2.buffer);
        }
        getData() {
          return this.blob || (this.arrayBuffers.length && mt(this), this.blob = this.pendingBlob, yt(this)), this.blob;
        }
      }
      function yt(e2) {
        e2.pendingBlob = new _([], { type: e2.contentType }), e2.arrayBuffers = [];
      }
      function mt(e2) {
        e2.pendingBlob = new _([e2.pendingBlob, ...e2.arrayBuffers], { type: e2.contentType }), e2.arrayBuffers = [];
      }
      class kt extends pt {
        constructor(e2, t2) {
          super(), this.url = e2, this.preventHeadRequest = t2.preventHeadRequest, this.useRangeHeader = t2.useRangeHeader, this.forceRangeRequests = t2.forceRangeRequests, this.options = n.assign({}, t2), delete this.options.preventHeadRequest, delete this.options.useRangeHeader, delete this.options.forceRangeRequests, delete this.options.useXHR;
        }
        async init() {
          super.init(), await Rt(this, Ut, zt);
        }
        readUint8Array(e2, t2) {
          return Et(this, e2, t2, Ut, zt);
        }
      }
      class vt extends pt {
        constructor(e2, t2) {
          super(), this.url = e2, this.preventHeadRequest = t2.preventHeadRequest, this.useRangeHeader = t2.useRangeHeader, this.forceRangeRequests = t2.forceRangeRequests, this.options = t2;
        }
        async init() {
          super.init(), await Rt(this, Ct, Dt);
        }
        readUint8Array(e2, t2) {
          return Et(this, e2, t2, Ct, Dt);
        }
      }
      async function Rt(e2, t2, n2) {
        if (((e3) => {
          if (void 0 !== x) {
            const t3 = x.createElement("a");
            return t3.href = e3, "http:" == t3.protocol || "https:" == t3.protocol;
          }
          return /^https?:\/\//i.test(e3);
        })(e2.url) && (e2.useRangeHeader || e2.forceRangeRequests)) {
          const i2 = await t2(_t, e2, At(e2));
          if (!e2.forceRangeRequests && "bytes" != i2.headers.get("Accept-Ranges"))
            throw new c(ut);
          {
            let r2;
            const a2 = i2.headers.get("Content-Range");
            if (a2) {
              const e3 = a2.trim().split(/\s*\/\s*/);
              if (e3.length) {
                const t3 = e3[1];
                t3 && "*" != t3 && (r2 = Number(t3));
              }
            }
            void 0 === r2 ? await Tt(e2, t2, n2) : e2.size = r2;
          }
        } else
          await Tt(e2, t2, n2);
      }
      async function Et(e2, t2, n2, i2, r2) {
        if (e2.useRangeHeader || e2.forceRangeRequests) {
          const r3 = await i2(_t, e2, At(e2, t2, n2));
          if (206 != r3.status)
            throw new c(ut);
          return new d(await r3.arrayBuffer());
        }
        return e2.data || await r2(e2, e2.options), new d(e2.data.subarray(t2, t2 + n2));
      }
      function At(e2, t2 = 0, i2 = 1) {
        return n.assign({}, St(e2), { Range: "bytes=" + t2 + "-" + (t2 + i2 - 1) });
      }
      function St(e2) {
        const t2 = e2.options.headers;
        if (t2)
          return Symbol.iterator in t2 ? n.fromEntries(t2) : t2;
      }
      async function zt(e2) {
        await Ft(e2, Ut);
      }
      async function Dt(e2) {
        await Ft(e2, Ct);
      }
      async function Ft(e2, t2) {
        const n2 = await t2(_t, e2, St(e2));
        e2.data = new d(await n2.arrayBuffer()), e2.size || (e2.size = e2.data.length);
      }
      async function Tt(e2, t2, n2) {
        if (e2.preventHeadRequest)
          await n2(e2, e2.options);
        else {
          const i2 = (await t2("HEAD", e2, St(e2))).headers.get("Content-Length");
          i2 ? e2.size = Number(i2) : await n2(e2, e2.options);
        }
      }
      async function Ut(e2, { options: t2, url: i2 }, r2) {
        const a2 = await fetch(i2, n.assign({}, t2, { method: e2, headers: r2 }));
        if (400 > a2.status)
          return a2;
        throw new c(dt + (a2.statusText || a2.status));
      }
      function Ct(e2, { url: t2 }, i2) {
        return new w((r2, a2) => {
          const s2 = new XMLHttpRequest();
          if (s2.addEventListener("load", () => {
            if (400 > s2.status) {
              const e3 = [];
              s2.getAllResponseHeaders().trim().split(/[\r\n]+/).forEach((t3) => {
                const n2 = t3.trim().split(/\s*:\s*/);
                n2[0] = n2[0].trim().replace(/^[a-z]|-[a-z]/g, (e4) => e4.toUpperCase()), e3.push(n2);
              }), r2({ status: s2.status, arrayBuffer: () => s2.response, headers: new o(e3) });
            } else
              a2(new c(dt + (s2.statusText || s2.status)));
          }, false), s2.addEventListener("error", (e3) => a2(e3.detail.error), false), s2.open(e2, t2), i2)
            for (const e3 of n.entries(i2))
              s2.setRequestHeader(e3[0], e3[1]);
          s2.responseType = "arraybuffer", s2.send();
        });
      }
      class Bt extends pt {
        constructor(e2, t2 = {}) {
          super(), this.url = e2, t2.useXHR ? this.reader = new vt(e2, t2) : this.reader = new kt(e2, t2);
        }
        set size(e2) {
        }
        get size() {
          return this.reader.size;
        }
        async init() {
          super.init(), await this.reader.init();
        }
        readUint8Array(e2, t2) {
          return this.reader.readUint8Array(e2, t2);
        }
      }
      const Wt = 4294967295, It = 65535, Mt = 67324752, Lt = 33639248, Nt = 101075792, Ht = 117853008, Ot = 21589, Vt = 2048, Pt = "/", qt = new s(2107, 11, 31), Zt = new s(1980, 0, 1), Kt = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ".split("");
      function Gt(e2, t2) {
        if (t2 && "cp437" == t2.trim().toLowerCase())
          return ((e3) => {
            let t3 = "";
            for (let n2 = 0; n2 < e3.length; n2++)
              t3 += Kt[e3[n2]];
            return t3;
          })(e2);
        if (void 0 === g) {
          const t3 = new b();
          return new w((n2, i2) => {
            t3.onload = (e3) => n2(e3.target.result), t3.onerror = () => i2(t3.error), t3.readAsText(new _([e2]));
          });
        }
        return new g(t2).decode(e2);
      }
      const Yt = ["filename", "rawFilename", "directory", "encrypted", "compressedSize", "uncompressedSize", "lastModDate", "rawLastModDate", "comment", "rawComment", "signature", "extraField", "rawExtraField", "bitFlag", "extraFieldZip64", "extraFieldUnicodePath", "extraFieldUnicodeComment", "extraFieldAES", "filenameUTF8", "commentUTF8", "offset", "zip64", "compressionMethod", "extraFieldNTFS", "lastAccessDate", "creationDate", "extraFieldExtendedTimestamp", "version", "versionMadeBy", "msDosCompatible", "internalFileAttribute", "externalFileAttribute"];
      class jt {
        constructor(e2) {
          Yt.forEach((t2) => this[t2] = e2[t2]);
        }
      }
      const Xt = "File format is not recognized", Jt = "End of central directory not found", Qt = "End of Zip64 central directory not found", $t = "End of Zip64 central directory locator not found", en = "Central directory header not found", tn = "Local file header not found", nn = "Zip64 extra field not found", rn = "File contains encrypted entry", an = "Encryption method not supported", sn = "Compression method not supported", on = "utf-8", ln = "cp437", cn = ["uncompressedSize", "compressedSize", "offset"];
      class dn {
        constructor(e2, t2, i2) {
          n.assign(this, { reader: e2, config: t2, options: i2 });
        }
        async getData(e2, t2, n2 = {}) {
          const i2 = this, { reader: r2, offset: a2, extraFieldAES: s2, compressionMethod: o2, config: l2, bitFlag: d2, signature: u2, rawLastModDate: f2, compressedSize: h2 } = i2, _2 = i2.localDirectory = {};
          r2.initialized || await r2.init();
          let w2 = await kn(r2, a2, 30);
          const p2 = mn(w2);
          let g2 = _n(i2, n2, "password");
          if (g2 = g2 && g2.length && g2, s2 && 99 != s2.originalCompressionMethod)
            throw new c(sn);
          if (0 != o2 && 8 != o2)
            throw new c(sn);
          if (xn(p2, 0) != Mt)
            throw new c(tn);
          un(_2, p2, 4), w2 = await kn(r2, a2, 30 + _2.filenameLength + _2.extraFieldLength), _2.rawExtraField = w2.subarray(30 + _2.filenameLength), await fn(i2, _2, p2, 4), t2.lastAccessDate = _2.lastAccessDate, t2.creationDate = _2.creationDate;
          const b2 = i2.encrypted && _2.encrypted, x2 = b2 && !s2;
          if (b2) {
            if (!x2 && void 0 === s2.strength)
              throw new c(an);
            if (!g2)
              throw new c(rn);
          }
          const y2 = await rt(l2.Inflate, { codecType: Ge, password: g2, zipCrypto: x2, encryptionStrength: s2 && s2.strength, signed: _n(i2, n2, "checkSignature"), passwordVerification: x2 && (d2.dataDescriptor ? f2 >>> 8 & 255 : u2 >>> 24 & 255), signature: u2, compressed: 0 != o2, encrypted: b2, useWebWorkers: _n(i2, n2, "useWebWorkers") }, l2);
          e2.initialized || await e2.init();
          const m2 = _n(i2, n2, "signal"), k2 = a2 + 30 + _2.filenameLength + _2.extraFieldLength;
          return await ot(y2, r2, e2, k2, () => h2, l2, { onprogress: n2.onprogress, signal: m2 }), e2.getData();
        }
      }
      function un(e2, t2, i2) {
        const r2 = e2.rawBitFlag = bn(t2, i2 + 2), a2 = 1 == (1 & r2), s2 = xn(t2, i2 + 6);
        n.assign(e2, { encrypted: a2, version: bn(t2, i2), bitFlag: { level: (6 & r2) >> 1, dataDescriptor: 8 == (8 & r2), languageEncodingFlag: (r2 & Vt) == Vt }, rawLastModDate: s2, lastModDate: wn(s2), filenameLength: bn(t2, i2 + 22), extraFieldLength: bn(t2, i2 + 24) });
      }
      async function fn(e2, t2, i2, r2) {
        const l2 = t2.rawExtraField, u2 = t2.extraField = new o(), f2 = mn(new d(l2));
        let h2 = 0;
        try {
          for (; h2 < l2.length; ) {
            const e3 = bn(f2, h2), t3 = bn(f2, h2 + 2);
            u2.set(e3, { type: e3, data: l2.slice(h2 + 4, h2 + 4 + t3) }), h2 += 4 + t3;
          }
        } catch (e3) {
        }
        const _2 = bn(i2, r2 + 4);
        t2.signature = xn(i2, r2 + 10), t2.uncompressedSize = xn(i2, r2 + 18), t2.compressedSize = xn(i2, r2 + 14);
        const w2 = u2.get(1);
        w2 && (((e3, t3) => {
          t3.zip64 = true;
          const n2 = mn(e3.data);
          e3.values = [];
          for (let t4 = 0; t4 < a.floor(e3.data.length / 8); t4++)
            e3.values.push(yn(n2, 0 + 8 * t4));
          const i3 = cn.filter((e4) => t3[e4] == Wt);
          for (let t4 = 0; t4 < i3.length; t4++)
            e3[i3[t4]] = e3.values[t4];
          cn.forEach((n3) => {
            if (t3[n3] == Wt) {
              if (void 0 === e3[n3])
                throw new c(nn);
              t3[n3] = e3[n3];
            }
          });
        })(w2, t2), t2.extraFieldZip64 = w2);
        const p2 = u2.get(28789);
        p2 && (await hn(p2, "filename", "rawFilename", t2, e2), t2.extraFieldUnicodePath = p2);
        const g2 = u2.get(25461);
        g2 && (await hn(g2, "comment", "rawComment", t2, e2), t2.extraFieldUnicodeComment = g2);
        const b2 = u2.get(39169);
        b2 ? (((e3, t3, n2) => {
          const i3 = mn(e3.data);
          e3.vendorVersion = gn(i3, 0), e3.vendorId = gn(i3, 2);
          const r3 = gn(i3, 4);
          e3.strength = r3, e3.originalCompressionMethod = n2, t3.compressionMethod = e3.compressionMethod = bn(i3, 5);
        })(b2, t2, _2), t2.extraFieldAES = b2) : t2.compressionMethod = _2;
        const x2 = u2.get(10);
        x2 && (((e3, t3) => {
          const i3 = mn(e3.data);
          let r3, a2 = 4;
          try {
            for (; a2 < e3.data.length && !r3; ) {
              const t4 = bn(i3, a2), n2 = bn(i3, a2 + 2);
              1 == t4 && (r3 = e3.data.slice(a2 + 4, a2 + 4 + n2)), a2 += 4 + n2;
            }
          } catch (e4) {
          }
          try {
            if (r3 && 24 == r3.length) {
              const i4 = mn(r3), a3 = i4.getBigUint64(0, true), s2 = i4.getBigUint64(8, true), o2 = i4.getBigUint64(16, true);
              n.assign(e3, { rawLastModDate: a3, rawLastAccessDate: s2, rawCreationDate: o2 });
              const l3 = { lastModDate: pn(a3), lastAccessDate: pn(s2), creationDate: pn(o2) };
              n.assign(e3, l3), n.assign(t3, l3);
            }
          } catch (e4) {
          }
        })(x2, t2), t2.extraFieldNTFS = x2);
        const y2 = u2.get(Ot);
        y2 && (((e3, t3) => {
          const n2 = mn(e3.data), i3 = gn(n2, 0), r3 = [], a2 = [];
          1 == (1 & i3) && (r3.push("lastModDate"), a2.push("rawLastModDate")), 2 == (2 & i3) && (r3.push("lastAccessDate"), a2.push("rawLastAccessDate")), 4 == (4 & i3) && (r3.push("creationDate"), a2.push("rawCreationDate"));
          let o2 = 1;
          r3.forEach((i4, r4) => {
            if (e3.data.length >= o2 + 4) {
              const l3 = xn(n2, o2);
              t3[i4] = e3[i4] = new s(1e3 * l3);
              const c2 = a2[r4];
              e3[c2] = l3;
            }
            o2 += 4;
          });
        })(y2, t2), t2.extraFieldExtendedTimestamp = y2);
      }
      async function hn(e2, t2, n2, i2, r2) {
        const a2 = mn(e2.data);
        e2.version = gn(a2, 0), e2.signature = xn(a2, 1);
        const s2 = new le();
        s2.append(r2[n2]);
        const o2 = mn(new d(4));
        o2.setUint32(0, s2.get(), true), e2[t2] = await Gt(e2.data.subarray(5)), e2.valid = !r2.bitFlag.languageEncodingFlag && e2.signature == xn(o2, 0), e2.valid && (i2[t2] = e2[t2], i2[t2 + "UTF8"] = true);
      }
      function _n(e2, t2, n2) {
        return void 0 === t2[n2] ? e2.options[n2] : t2[n2];
      }
      function wn(e2) {
        const t2 = (4294901760 & e2) >> 16, n2 = 65535 & e2;
        try {
          return new s(1980 + ((65024 & t2) >> 9), ((480 & t2) >> 5) - 1, 31 & t2, (63488 & n2) >> 11, (2016 & n2) >> 5, 2 * (31 & n2), 0);
        } catch (e3) {
        }
      }
      function pn(e2) {
        return new s(Number(e2 / r(1e4) - r(116444736e5)));
      }
      function gn(e2, t2) {
        return e2.getUint8(t2);
      }
      function bn(e2, t2) {
        return e2.getUint16(t2, true);
      }
      function xn(e2, t2) {
        return e2.getUint32(t2, true);
      }
      function yn(e2, t2) {
        return Number(e2.getBigUint64(t2, true));
      }
      function mn(e2) {
        return new h(e2.buffer);
      }
      function kn(e2, t2, n2) {
        return e2.readUint8Array(t2, n2);
      }
      const vn = "File already exists", Rn = "Zip file comment exceeds 64KB", En = "File entry comment exceeds 64KB", An = "File entry name exceeds 64KB", Sn = "Version exceeds 65535", zn = "The strength must equal 1, 2, or 3", Dn = "Extra field type exceeds 65535", Fn = "Extra field data exceeds 64KB", Tn = "Zip64 is not supported", Un = new d([7, 0, 2, 0, 65, 69, 3, 0, 0]);
      let Cn = 0;
      function Bn(e2, t2, n2) {
        if (e2.arrayBuffer)
          return t2 || n2 ? e2.slice(t2, n2).arrayBuffer() : e2.arrayBuffer();
        {
          const i2 = new b();
          return new w((r2, a2) => {
            i2.onload = (e3) => r2(e3.target.result), i2.onerror = () => a2(i2.error), i2.readAsArrayBuffer(t2 || n2 ? e2.slice(t2, n2) : e2);
          });
        }
      }
      function Wn(e2) {
        if (e2)
          return (r(e2.getTime()) + r(116444736e5)) * r(1e4);
      }
      function In(e2, t2, n2) {
        return void 0 === t2[n2] ? e2.options[n2] : t2[n2];
      }
      function Mn(e2, t2, n2) {
        e2.setUint8(t2, n2);
      }
      function Ln(e2, t2, n2) {
        e2.setUint16(t2, n2, true);
      }
      function Nn(e2, t2, n2) {
        e2.setUint32(t2, n2, true);
      }
      function Hn(e2, t2, n2) {
        e2.setBigUint64(t2, n2, true);
      }
      function On(e2, t2, n2) {
        e2.set(t2, n2);
      }
      function Vn(e2) {
        return new h(e2.buffer);
      }
      se({ Deflate: function(e2) {
        const t2 = new L(), n2 = (i2 = e2 && e2.chunkSize ? e2.chunkSize : 65536) + 5 * (a.floor(i2 / 16383) + 1);
        var i2;
        const r2 = new d(n2);
        let s2 = e2 ? e2.level : -1;
        void 0 === s2 && (s2 = -1), t2.deflateInit(s2), t2.next_out = r2, this.append = (e3, i3) => {
          let a2, s3, o2 = 0, l2 = 0, u2 = 0;
          const f2 = [];
          if (e3.length) {
            t2.next_in_index = 0, t2.next_in = e3, t2.avail_in = e3.length;
            do {
              if (t2.next_out_index = 0, t2.avail_out = n2, a2 = t2.deflate(0), 0 != a2)
                throw new c("deflating: " + t2.msg);
              t2.next_out_index && (t2.next_out_index == n2 ? f2.push(new d(r2)) : f2.push(r2.slice(0, t2.next_out_index))), u2 += t2.next_out_index, i3 && t2.next_in_index > 0 && t2.next_in_index != o2 && (i3(t2.next_in_index), o2 = t2.next_in_index);
            } while (t2.avail_in > 0 || 0 === t2.avail_out);
            return f2.length > 1 ? (s3 = new d(u2), f2.forEach((e4) => {
              s3.set(e4, l2), l2 += e4.length;
            })) : s3 = f2[0] || new d(0), s3;
          }
        }, this.flush = () => {
          let e3, i3, a2 = 0, s3 = 0;
          const o2 = [];
          do {
            if (t2.next_out_index = 0, t2.avail_out = n2, e3 = t2.deflate(4), 1 != e3 && 0 != e3)
              throw new c("deflating: " + t2.msg);
            n2 - t2.avail_out > 0 && o2.push(r2.slice(0, t2.next_out_index)), s3 += t2.next_out_index;
          } while (t2.avail_in > 0 || 0 === t2.avail_out);
          return t2.deflateEnd(), i3 = new d(s3), o2.forEach((e4) => {
            i3.set(e4, a2), a2 += e4.length;
          }), i3;
        };
      }, Inflate: function(e2) {
        const t2 = new ne(), n2 = e2 && e2.chunkSize ? a.floor(2 * e2.chunkSize) : 131072, i2 = new d(n2);
        let r2 = false;
        t2.inflateInit(), t2.next_out = i2, this.append = (e3, a2) => {
          const s2 = [];
          let o2, l2, u2 = 0, f2 = 0, h2 = 0;
          if (0 !== e3.length) {
            t2.next_in_index = 0, t2.next_in = e3, t2.avail_in = e3.length;
            do {
              if (t2.next_out_index = 0, t2.avail_out = n2, 0 !== t2.avail_in || r2 || (t2.next_in_index = 0, r2 = true), o2 = t2.inflate(0), r2 && o2 === O) {
                if (0 !== t2.avail_in)
                  throw new c("inflating: bad input");
              } else if (0 !== o2 && 1 !== o2)
                throw new c("inflating: " + t2.msg);
              if ((r2 || 1 === o2) && t2.avail_in === e3.length)
                throw new c("inflating: bad input");
              t2.next_out_index && (t2.next_out_index === n2 ? s2.push(new d(i2)) : s2.push(i2.slice(0, t2.next_out_index))), h2 += t2.next_out_index, a2 && t2.next_in_index > 0 && t2.next_in_index != u2 && (a2(t2.next_in_index), u2 = t2.next_in_index);
            } while (t2.avail_in > 0 || 0 === t2.avail_out);
            return s2.length > 1 ? (l2 = new d(h2), s2.forEach((e4) => {
              l2.set(e4, f2), f2 += e4.length;
            })) : l2 = s2[0] || new d(0), l2;
          }
        }, this.flush = () => {
          t2.inflateEnd();
        };
      } }), e.BlobReader = bt, e.BlobWriter = xt, e.Data64URIReader = class extends pt {
        constructor(e2) {
          super(), this.dataURI = e2;
          let t2 = e2.length;
          for (; "=" == e2.charAt(t2 - 1); )
            t2--;
          this.dataStart = e2.indexOf(",") + 1, this.size = a.floor(0.75 * (t2 - this.dataStart));
        }
        readUint8Array(e2, t2) {
          const n2 = new d(t2), i2 = 4 * a.floor(e2 / 3), r2 = atob(this.dataURI.substring(i2 + this.dataStart, 4 * a.ceil((e2 + t2) / 3) + this.dataStart)), s2 = e2 - 3 * a.floor(i2 / 4);
          for (let e3 = s2; s2 + t2 > e3; e3++)
            n2[e3 - s2] = r2.charCodeAt(e3);
          return n2;
        }
      }, e.Data64URIWriter = class extends gt {
        constructor(e2) {
          super(), this.data = "data:" + (e2 || "") + ";base64,", this.pending = [];
        }
        writeUint8Array(e2) {
          super.writeUint8Array(e2);
          let t2 = 0, n2 = this.pending;
          const r2 = this.pending.length;
          for (this.pending = "", t2 = 0; t2 < 3 * a.floor((r2 + e2.length) / 3) - r2; t2++)
            n2 += i.fromCharCode(e2[t2]);
          for (; t2 < e2.length; t2++)
            this.pending += i.fromCharCode(e2[t2]);
          n2.length > 2 ? this.data += m(n2) : this.pending = n2;
        }
        getData() {
          return this.data + m(this.pending);
        }
      }, e.ERR_ABORT = st, e.ERR_BAD_FORMAT = Xt, e.ERR_CENTRAL_DIRECTORY_NOT_FOUND = en, e.ERR_DUPLICATED_NAME = vn, e.ERR_ENCRYPTED = rn, e.ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND = $t, e.ERR_EOCDR_NOT_FOUND = Jt, e.ERR_EOCDR_ZIP64_NOT_FOUND = Qt, e.ERR_EXTRAFIELD_ZIP64_NOT_FOUND = nn, e.ERR_HTTP_RANGE = ut, e.ERR_INVALID_COMMENT = Rn, e.ERR_INVALID_ENCRYPTION_STRENGTH = zn, e.ERR_INVALID_ENTRY_COMMENT = En, e.ERR_INVALID_ENTRY_NAME = An, e.ERR_INVALID_EXTRAFIELD_DATA = Fn, e.ERR_INVALID_EXTRAFIELD_TYPE = Dn, e.ERR_INVALID_PASSWORD = we, e.ERR_INVALID_SIGNATURE = Ye, e.ERR_INVALID_VERSION = Sn, e.ERR_LOCAL_FILE_HEADER_NOT_FOUND = tn, e.ERR_NOT_SEEKABLE_READER = ft, e.ERR_UNSUPPORTED_COMPRESSION = sn, e.ERR_UNSUPPORTED_ENCRYPTION = an, e.ERR_UNSUPPORTED_FORMAT = Tn, e.HttpRangeReader = class extends Bt {
        constructor(e2, t2 = {}) {
          t2.useRangeHeader = true, super(e2, t2);
        }
      }, e.HttpReader = Bt, e.ReadableStreamReader = class {
        constructor(e2) {
          this.readableStream = e2, this.reader = e2.getReader(), this.size = 1 / 0, this.index = 0, this.currentSize = 0, this.pendingValue = new d();
        }
        init() {
          this.initialized = true;
        }
        async readUint8Array(e2, t2) {
          if (this.index != e2)
            throw new c(ft);
          let n2, i2 = new d(t2), r2 = 0;
          do {
            const e3 = await this.reader.read();
            let { value: a2 } = e3;
            if (n2 = e3.done, a2 ? this.currentSize += a2.length : (a2 = this.pendingValue, this.pendingValue = new d()), this.pendingValue.length) {
              const e4 = new d(this.pendingValue.length + a2.length);
              e4.set(this.pendingValue), e4.set(a2, this.pendingValue.length), this.pendingValue = new d(), a2 = e4;
            }
            r2 + a2.length > t2 ? (i2.set(a2.subarray(0, t2), r2), this.pendingValue = a2.subarray(t2), r2 += t2) : (i2.set(a2, r2), r2 += a2.length);
          } while (t2 > r2 && !n2);
          return n2 && this.size == 1 / 0 && (this.size = this.currentSize), this.size < t2 && (i2 = i2.slice(0, this.size), t2 = this.size), this.index += t2, i2;
        }
      }, e.Reader = pt, e.TextReader = class extends pt {
        constructor(e2) {
          super(), this.blobReader = new bt(new _([e2], { type: ht }));
        }
        init() {
          super.init(), this.blobReader.init(), this.size = this.blobReader.size;
        }
        readUint8Array(e2, t2) {
          return this.blobReader.readUint8Array(e2, t2);
        }
      }, e.TextWriter = class extends gt {
        constructor(e2) {
          super(), this.encoding = e2, this.blob = new _([], { type: ht });
        }
        writeUint8Array(e2) {
          super.writeUint8Array(e2), this.blob = new _([this.blob, e2.buffer], { type: ht });
        }
        getData() {
          if (this.blob.text)
            return this.blob.text();
          {
            const e2 = new b();
            return new w((t2, n2) => {
              e2.onload = (e3) => t2(e3.target.result), e2.onerror = () => n2(e2.error), e2.readAsText(this.blob, this.encoding);
            });
          }
        }
      }, e.Uint8ArrayReader = class extends pt {
        constructor(e2) {
          super(), this.array = e2, this.size = e2.length;
        }
        readUint8Array(e2, t2) {
          return this.array.slice(e2, e2 + t2);
        }
      }, e.Uint8ArrayWriter = class extends gt {
        constructor() {
          super(), this.array = new d(0);
        }
        writeUint8Array(e2) {
          super.writeUint8Array(e2);
          const t2 = this.array;
          this.array = new d(t2.length + e2.length), this.array.set(t2), this.array.set(e2, t2.length);
        }
        getData() {
          return this.array;
        }
      }, e.WritableStreamWriter = class extends gt {
        constructor(e2) {
          super(), this.writableStream = e2, this.writer = e2.getWriter();
        }
        async writeUint8Array(e2) {
          return await this.writer.ready, this.writer.write(e2);
        }
        async getData() {
          return await this.writer.ready, await this.writer.close(), this.writableStream;
        }
      }, e.Writer = gt, e.ZipReader = class {
        constructor(e2, t2 = {}) {
          n.assign(this, { reader: e2, options: t2, config: ae() });
        }
        async *getEntriesGenerator(e2 = {}) {
          const t2 = this, i2 = t2.reader;
          if (i2.initialized || await i2.init(), 22 > i2.size)
            throw new c(Xt);
          const r2 = await (async (e3, t3, n2) => {
            const i3 = new d(4);
            return mn(i3).setUint32(0, 101010256, true), await r3(22) || await r3(a.min(1048582, n2));
            async function r3(t4) {
              const r4 = n2 - t4, a2 = await kn(e3, r4, t4);
              for (let e4 = a2.length - 22; e4 >= 0; e4--)
                if (a2[e4] == i3[0] && a2[e4 + 1] == i3[1] && a2[e4 + 2] == i3[2] && a2[e4 + 3] == i3[3])
                  return { offset: r4 + e4, buffer: a2.slice(e4, e4 + 22).buffer };
            }
          })(i2, 0, i2.size);
          if (!r2)
            throw new c(Jt);
          const s2 = mn(r2);
          let o2 = xn(s2, 12), l2 = xn(s2, 16), u2 = bn(s2, 8), f2 = 0;
          if (l2 == Wt || o2 == Wt || u2 == It) {
            const e3 = mn(await kn(i2, r2.offset - 20, 20));
            if (xn(e3, 0) != Ht)
              throw new c(Qt);
            l2 = yn(e3, 8);
            let t3 = await kn(i2, l2, 56), n2 = mn(t3);
            const a2 = r2.offset - 20 - 56;
            if (xn(n2, 0) != Nt && l2 != a2) {
              const e4 = l2;
              l2 = a2, f2 = l2 - e4, t3 = await kn(i2, l2, 56), n2 = mn(t3);
            }
            if (xn(n2, 0) != Nt)
              throw new c($t);
            u2 = yn(n2, 32), o2 = yn(n2, 40), l2 -= o2;
          }
          if (0 > l2 || l2 >= i2.size)
            throw new c(Xt);
          let h2 = 0, _2 = await kn(i2, l2, o2), p2 = mn(_2);
          if (o2) {
            const e3 = r2.offset - o2;
            if (xn(p2, h2) != Lt && l2 != e3) {
              const t3 = l2;
              l2 = e3, f2 = l2 - t3, _2 = await kn(i2, l2, o2), p2 = mn(_2);
            }
          }
          if (0 > l2 || l2 >= i2.size)
            throw new c(Xt);
          for (let r3 = 0; u2 > r3; r3++) {
            const a2 = new dn(i2, t2.config, t2.options);
            if (xn(p2, h2) != Lt)
              throw new c(en);
            un(a2, p2, h2 + 6);
            const s3 = !!a2.bitFlag.languageEncodingFlag, o3 = h2 + 46, l3 = o3 + a2.filenameLength, d2 = l3 + a2.extraFieldLength, g2 = bn(p2, h2 + 4), b2 = 0 == (0 & g2);
            n.assign(a2, { versionMadeBy: g2, msDosCompatible: b2, compressedSize: 0, uncompressedSize: 0, commentLength: bn(p2, h2 + 32), directory: b2 && 16 == (16 & gn(p2, h2 + 38)), offset: xn(p2, h2 + 42) + f2, internalFileAttribute: xn(p2, h2 + 34), externalFileAttribute: xn(p2, h2 + 38), rawFilename: _2.subarray(o3, l3), filenameUTF8: s3, commentUTF8: s3, rawExtraField: _2.subarray(l3, d2) });
            const x2 = d2 + a2.commentLength;
            a2.rawComment = _2.subarray(d2, x2);
            const y2 = _n(t2, e2, "filenameEncoding"), m2 = _n(t2, e2, "commentEncoding"), [k2, v2] = await w.all([Gt(a2.rawFilename, a2.filenameUTF8 ? on : y2 || ln), Gt(a2.rawComment, a2.commentUTF8 ? on : m2 || ln)]);
            a2.filename = k2, a2.comment = v2, !a2.directory && a2.filename.endsWith(Pt) && (a2.directory = true), await fn(a2, a2, p2, h2 + 6);
            const R2 = new jt(a2);
            if (R2.getData = (e3, t3) => a2.getData(e3, R2, t3), h2 = x2, e2.onprogress)
              try {
                e2.onprogress(r3 + 1, u2, new jt(a2));
              } catch (e3) {
              }
            yield R2;
          }
          return true;
        }
        async getEntries(e2 = {}) {
          const t2 = [], n2 = this.getEntriesGenerator(e2);
          let i2 = n2.next();
          for (; !(await i2).done; )
            t2.push((await i2).value), i2 = n2.next();
          return t2;
        }
        async close() {
        }
      }, e.ZipWriter = class {
        constructor(e2, t2 = {}) {
          n.assign(this, { writer: e2, options: t2, config: ae(), files: new o(), offset: e2.size, pendingCompressedSize: 0, pendingEntries: [], pendingAddFileCalls: /* @__PURE__ */ new Set() });
        }
        async add(e2 = "", i2, o2 = {}) {
          const l2 = this;
          if (Cn >= l2.config.maxWorkers)
            return new w((t2, n2) => l2.pendingEntries.push({ name: e2, reader: i2, options: o2, resolve: t2, reject: n2 }));
          {
            let _2;
            Cn++;
            try {
              return _2 = (async (e3, i3, o3, l3) => {
                if (i3 = i3.trim(), l3.directory && !i3.endsWith(Pt) ? i3 += Pt : l3.directory = i3.endsWith(Pt), e3.files.has(i3))
                  throw new c(vn);
                const _3 = ce(i3);
                if (_3.length > It)
                  throw new c(An);
                const p2 = l3.comment || "", g2 = ce(p2);
                if (g2.length > It)
                  throw new c(En);
                const b2 = e3.options.version || l3.version || 0;
                if (b2 > It)
                  throw new c(Sn);
                const x2 = e3.options.versionMadeBy || l3.versionMadeBy || 20;
                if (x2 > It)
                  throw new c(Sn);
                const y2 = In(e3, l3, "lastModDate") || new s(), m2 = In(e3, l3, "lastAccessDate"), k2 = In(e3, l3, "creationDate"), v2 = In(e3, l3, "password"), R2 = In(e3, l3, "encryptionStrength") || 3, E2 = In(e3, l3, "zipCrypto");
                if (void 0 !== v2 && void 0 !== R2 && (1 > R2 || R2 > 3))
                  throw new c(zn);
                let A2 = new d(0);
                const S2 = l3.extraField;
                if (S2) {
                  let e4 = 0, t2 = 0;
                  S2.forEach((t3) => e4 += 4 + t3.length), A2 = new d(e4), S2.forEach((e5, n2) => {
                    if (n2 > It)
                      throw new c(Dn);
                    if (e5.length > It)
                      throw new c(Fn);
                    On(A2, new u([n2]), t2), On(A2, new u([e5.length]), t2 + 2), On(A2, e5, t2 + 4), t2 += 4 + e5.length;
                  });
                }
                let z2 = In(e3, l3, "extendedTimestamp");
                void 0 === z2 && (z2 = true);
                let D2 = 0, F2 = In(e3, l3, "keepOrder");
                void 0 === F2 && (F2 = true);
                let T2 = 0, U2 = In(e3, l3, "msDosCompatible");
                void 0 === U2 && (U2 = true);
                const C2 = In(e3, l3, "internalFileAttribute") || 0, B2 = In(e3, l3, "externalFileAttribute") || 0;
                o3 && (o3.initialized || await o3.init(), T2 = o3.size, D2 = ((e4) => e4 + 5 * (a.floor(e4 / 16383) + 1))(T2));
                let W2 = l3.zip64 || e3.options.zip64 || false;
                if (e3.offset + e3.pendingCompressedSize >= Wt || T2 >= Wt || D2 >= Wt) {
                  if (false === l3.zip64 || false === e3.options.zip64 || !F2)
                    throw new c(Tn);
                  W2 = true;
                }
                e3.pendingCompressedSize += D2, await w.resolve();
                const I2 = In(e3, l3, "level"), M2 = In(e3, l3, "useWebWorkers"), L2 = In(e3, l3, "bufferedWrite");
                let N2 = In(e3, l3, "dataDescriptor"), H2 = In(e3, l3, "dataDescriptorSignature");
                const O2 = In(e3, l3, "signal");
                void 0 === N2 && (N2 = true), N2 && void 0 === H2 && (H2 = false);
                const V2 = await (async (e4, i4, s2, o4) => {
                  const l4 = e4.files, u2 = e4.writer, _4 = t.from(l4.values()).pop();
                  let p3, g3, b3, x3 = {};
                  l4.set(i4, x3);
                  try {
                    let y3, m3, k3;
                    if (o4.keepOrder && (y3 = _4 && _4.lock), x3.lock = k3 = new w((e5) => b3 = e5), o4.bufferedWrite || e4.lockWrite || !o4.dataDescriptor ? (m3 = new xt(), m3.init(), p3 = true) : (e4.lockWrite = new w((e5) => g3 = e5), u2.initialized || await u2.init(), m3 = u2), x3 = await (async (e5, t2, i5, s3) => {
                      const { rawFilename: o5, lastAccessDate: l5, creationDate: c2, password: u3, level: h2, zip64: _5, zipCrypto: w2, dataDescriptor: p4, dataDescriptorSignature: g4, directory: b4, version: x4, versionMadeBy: y4, rawComment: m4, rawExtraField: k4, useWebWorkers: v3, onprogress: R3, signal: E3, encryptionStrength: A3, extendedTimestamp: S3, msDosCompatible: z3, internalFileAttribute: D3, externalFileAttribute: F3 } = s3, T3 = !(!u3 || !u3.length), U3 = 0 !== h2 && !b4;
                      let C3, B3, W3;
                      if (T3 && !w2) {
                        C3 = new d(Un.length + 2);
                        const e6 = Vn(C3);
                        Ln(e6, 0, 39169), On(C3, Un, 2), Mn(e6, 8, A3);
                      } else
                        C3 = new d(0);
                      if (S3) {
                        W3 = new d(9 + (l5 ? 4 : 0) + (c2 ? 4 : 0));
                        const e6 = Vn(W3);
                        Ln(e6, 0, Ot), Ln(e6, 2, W3.length - 4), Mn(e6, 4, 1 + (l5 ? 2 : 0) + (c2 ? 4 : 0)), Nn(e6, 5, a.floor(s3.lastModDate.getTime() / 1e3)), l5 && Nn(e6, 9, a.floor(l5.getTime() / 1e3)), c2 && Nn(e6, 13, a.floor(c2.getTime() / 1e3));
                        try {
                          B3 = new d(36);
                          const e7 = Vn(B3), t3 = Wn(s3.lastModDate);
                          Ln(e7, 0, 10), Ln(e7, 2, 32), Ln(e7, 8, 1), Ln(e7, 10, 24), Hn(e7, 12, t3), Hn(e7, 20, Wn(l5) || t3), Hn(e7, 28, Wn(c2) || t3);
                        } catch (e7) {
                          B3 = new d(0);
                        }
                      } else
                        B3 = W3 = new d(0);
                      const I3 = { version: x4 || 20, versionMadeBy: y4, zip64: _5, directory: !!b4, filenameUTF8: true, rawFilename: o5, commentUTF8: true, rawComment: m4, rawExtraFieldZip64: new d(_5 ? 28 : 0), rawExtraFieldExtendedTimestamp: W3, rawExtraFieldNTFS: B3, rawExtraFieldAES: C3, rawExtraField: k4, extendedTimestamp: S3, msDosCompatible: z3, internalFileAttribute: D3, externalFileAttribute: F3 };
                      let M3 = I3.uncompressedSize = 0, L3 = Vt;
                      p4 && (L3 |= 8);
                      let N3 = 0;
                      U3 && (N3 = 8), _5 && (I3.version = I3.version > 45 ? I3.version : 45), T3 && (L3 |= 1, w2 || (I3.version = I3.version > 51 ? I3.version : 51, N3 = 99, U3 && (I3.rawExtraFieldAES[9] = 8))), I3.compressionMethod = N3;
                      const H3 = I3.headerArray = new d(26), O3 = Vn(H3);
                      Ln(O3, 0, I3.version), Ln(O3, 2, L3), Ln(O3, 4, N3);
                      const V3 = new f(1), P2 = Vn(V3);
                      let q2;
                      q2 = s3.lastModDate < Zt ? Zt : s3.lastModDate > qt ? qt : s3.lastModDate, Ln(P2, 0, (q2.getHours() << 6 | q2.getMinutes()) << 5 | q2.getSeconds() / 2), Ln(P2, 2, (q2.getFullYear() - 1980 << 4 | q2.getMonth() + 1) << 5 | q2.getDate());
                      const Z2 = V3[0];
                      Nn(O3, 6, Z2), Ln(O3, 22, o5.length);
                      const K2 = C3.length + W3.length + B3.length + I3.rawExtraField.length;
                      Ln(O3, 24, K2);
                      const G2 = new d(30 + o5.length + K2);
                      let Y2;
                      Nn(Vn(G2), 0, Mt), On(G2, H3, 4), On(G2, o5, 30), On(G2, C3, 30 + o5.length), On(G2, W3, 30 + o5.length + C3.length), On(G2, B3, 30 + o5.length + C3.length + W3.length), On(G2, I3.rawExtraField, 30 + o5.length + C3.length + W3.length + B3.length);
                      let j2 = 0;
                      if (e5) {
                        const n2 = await rt(i5.Deflate, { codecType: Ke, level: h2, password: u3, encryptionStrength: A3, zipCrypto: T3 && w2, passwordVerification: T3 && w2 && Z2 >> 8 & 255, signed: true, compressed: U3, encrypted: T3, useWebWorkers: v3 }, i5);
                        await t2.writeUint8Array(G2), I3.dataWritten = true, Y2 = await ot(n2, e5, t2, 0, () => e5.size, i5, { onprogress: R3, signal: E3 }), M3 = I3.uncompressedSize = e5.size, j2 = Y2.length;
                      } else
                        await t2.writeUint8Array(G2), I3.dataWritten = true;
                      let X2, J2 = new d(0), Q2 = 0;
                      if (p4 && (J2 = new d(_5 ? g4 ? 24 : 20 : g4 ? 16 : 12), X2 = Vn(J2), g4 && (Q2 = 4, Nn(X2, 0, 134695760))), e5) {
                        const e6 = Y2.signature;
                        if (T3 && !w2 || void 0 === e6 || (Nn(O3, 10, e6), I3.signature = e6, p4 && Nn(X2, Q2, e6)), _5) {
                          const e7 = Vn(I3.rawExtraFieldZip64);
                          Ln(e7, 0, 1), Ln(e7, 2, 24), Nn(O3, 14, Wt), Hn(e7, 12, r(j2)), Nn(O3, 18, Wt), Hn(e7, 4, r(M3)), p4 && (Hn(X2, Q2 + 4, r(j2)), Hn(X2, Q2 + 12, r(M3)));
                        } else
                          Nn(O3, 14, j2), Nn(O3, 18, M3), p4 && (Nn(X2, Q2 + 4, j2), Nn(X2, Q2 + 8, M3));
                      }
                      p4 && await t2.writeUint8Array(J2);
                      const $2 = G2.length + j2 + J2.length;
                      return n.assign(I3, { compressedSize: j2, lastModDate: q2, rawLastModDate: Z2, creationDate: c2, lastAccessDate: l5, encrypted: T3, length: $2 }), I3;
                    })(s2, m3, e4.config, o4), x3.lock = k3, l4.set(i4, x3), x3.filename = i4, p3) {
                      let n2 = 0;
                      const i5 = m3.getData();
                      let r2;
                      await w.all([e4.lockWrite, y3]);
                      do {
                        r2 = t.from(l4.values()).find((e5) => e5.writingBufferedData), r2 && await r2.lock;
                      } while (r2 && r2.lock);
                      if (x3.writingBufferedData = true, !o4.dataDescriptor) {
                        const e5 = 26, t2 = await Bn(i5, 0, e5), r3 = new h(t2);
                        x3.encrypted && !o4.zipCrypto || Nn(r3, 14, x3.signature), x3.zip64 ? (Nn(r3, 18, Wt), Nn(r3, 22, Wt)) : (Nn(r3, 18, x3.compressedSize), Nn(r3, 22, x3.uncompressedSize)), await u2.writeUint8Array(new d(t2)), n2 = e5;
                      }
                      await (async (e5, t2, n3 = 0) => {
                        const i6 = 536870912;
                        await async function r3() {
                          if (n3 < t2.size) {
                            const a2 = await Bn(t2, n3, n3 + i6);
                            await e5.writeUint8Array(new d(a2)), n3 += i6, await r3();
                          }
                        }();
                      })(u2, i5, n2), delete x3.writingBufferedData;
                    }
                    if (x3.offset = e4.offset, x3.zip64)
                      Hn(Vn(x3.rawExtraFieldZip64), 20, r(x3.offset));
                    else if (x3.offset >= Wt)
                      throw new c(Tn);
                    return e4.offset += x3.length, x3;
                  } catch (t2) {
                    throw (p3 && x3.writingBufferedData || !p3 && x3.dataWritten) && (t2.corruptedEntry = e4.hasCorruptedEntries = true, x3.uncompressedSize && (e4.offset += x3.uncompressedSize)), l4.delete(i4), t2;
                  } finally {
                    b3(), g3 && g3();
                  }
                })(e3, i3, o3, n.assign({}, l3, { rawFilename: _3, rawComment: g2, version: b2, versionMadeBy: x2, lastModDate: y2, lastAccessDate: m2, creationDate: k2, rawExtraField: A2, zip64: W2, password: v2, level: I2, useWebWorkers: M2, encryptionStrength: R2, extendedTimestamp: z2, zipCrypto: E2, bufferedWrite: L2, keepOrder: F2, dataDescriptor: N2, dataDescriptorSignature: H2, signal: O2, msDosCompatible: U2, internalFileAttribute: C2, externalFileAttribute: B2 }));
                return D2 && (e3.pendingCompressedSize -= D2), n.assign(V2, { name: i3, comment: p2, extraField: S2 }), new jt(V2);
              })(l2, e2, i2, o2), this.pendingAddFileCalls.add(_2), await _2;
            } finally {
              this.pendingAddFileCalls.delete(_2), Cn--;
              const e3 = l2.pendingEntries.shift();
              e3 && l2.add(e3.name, e3.reader, e3.options).then(e3.resolve).catch(e3.reject);
            }
          }
        }
        async close(e2 = new d(0), n2 = {}) {
          for (; this.pendingAddFileCalls.size; )
            await w.all(t.from(this.pendingAddFileCalls));
          return await (async (e3, n3, i2) => {
            const s2 = e3.writer, o2 = e3.files;
            let l2 = 0, u2 = 0, f2 = e3.offset, h2 = o2.size;
            for (const [, e4] of o2)
              u2 += 46 + e4.rawFilename.length + e4.rawComment.length + e4.rawExtraFieldZip64.length + e4.rawExtraFieldAES.length + e4.rawExtraFieldExtendedTimestamp.length + e4.rawExtraFieldNTFS.length + e4.rawExtraField.length;
            let _2 = i2.zip64 || e3.options.zip64 || false;
            if (f2 >= Wt || u2 >= Wt || h2 >= It) {
              if (false === i2.zip64 || false === e3.options.zip64)
                throw new c(Tn);
              _2 = true;
            }
            const w2 = new d(u2 + (_2 ? 98 : 22)), p2 = Vn(w2);
            if (n3 && n3.length) {
              if (n3.length > It)
                throw new c(Rn);
              Ln(p2, l2 + 20, n3.length);
            }
            for (const [e4, n4] of t.from(o2.values()).entries()) {
              const { rawFilename: t2, rawExtraFieldZip64: r2, rawExtraFieldAES: s3, rawExtraField: c2, rawComment: u3, versionMadeBy: f3, headerArray: h3, directory: _3, zip64: g2, msDosCompatible: b2, internalFileAttribute: x2, externalFileAttribute: y2 } = n4;
              let m2, k2;
              if (n4.extendedTimestamp) {
                k2 = n4.rawExtraFieldNTFS, m2 = new d(9);
                const e5 = Vn(m2);
                Ln(e5, 0, Ot), Ln(e5, 2, m2.length - 4), Mn(e5, 4, 1), Nn(e5, 5, a.floor(n4.lastModDate.getTime() / 1e3));
              } else
                k2 = m2 = new d(0);
              const v2 = r2.length + s3.length + m2.length + k2.length + c2.length;
              if (Nn(p2, l2, Lt), Ln(p2, l2 + 4, f3), On(w2, h3, l2 + 6), Ln(p2, l2 + 30, v2), Ln(p2, l2 + 32, u3.length), Nn(p2, l2 + 34, x2), y2 ? Nn(p2, l2 + 38, y2) : _3 && b2 && Mn(p2, l2 + 38, 16), Nn(p2, l2 + 42, g2 ? Wt : n4.offset), On(w2, t2, l2 + 46), On(w2, r2, l2 + 46 + t2.length), On(w2, s3, l2 + 46 + t2.length + r2.length), On(w2, m2, l2 + 46 + t2.length + r2.length + s3.length), On(w2, k2, l2 + 46 + t2.length + r2.length + s3.length + m2.length), On(w2, c2, l2 + 46 + t2.length + r2.length + s3.length + m2.length + k2.length), On(w2, u3, l2 + 46 + t2.length + v2), l2 += 46 + t2.length + v2 + u3.length, i2.onprogress)
                try {
                  i2.onprogress(e4 + 1, o2.size, new jt(n4));
                } catch (e5) {
                }
            }
            _2 && (Nn(p2, l2, Nt), Hn(p2, l2 + 4, r(44)), Ln(p2, l2 + 12, 45), Ln(p2, l2 + 14, 45), Hn(p2, l2 + 24, r(h2)), Hn(p2, l2 + 32, r(h2)), Hn(p2, l2 + 40, r(u2)), Hn(p2, l2 + 48, r(f2)), Nn(p2, l2 + 56, Ht), Hn(p2, l2 + 64, r(f2) + r(u2)), Nn(p2, l2 + 72, 1), h2 = It, f2 = Wt, u2 = Wt, l2 += 76), Nn(p2, l2, 101010256), Ln(p2, l2 + 8, h2), Ln(p2, l2 + 10, h2), Nn(p2, l2 + 12, u2), Nn(p2, l2 + 16, f2), await s2.writeUint8Array(w2), n3 && n3.length && await s2.writeUint8Array(n3);
          })(this, e2, n2), this.writer.getData();
        }
      }, e.configure = se, e.getMimeType = () => "application/octet-stream", e.terminateWorkers = () => {
        nt.forEach((e2) => {
          at(e2), e2.terminate();
        });
      }, n.defineProperty(e, "__esModule", { value: true });
    });
  }
});
export default require_zip_no_worker_min();
//# sourceMappingURL=@zip__js_zip__js_dist_zip-no-worker__min__js.js.map
