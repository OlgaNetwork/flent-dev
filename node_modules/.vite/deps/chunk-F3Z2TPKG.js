import {
  DOMSerializer,
  EditorState,
  Fragment,
  InputRule,
  Node as Node2,
  NodeSelection,
  Plugin,
  Selection,
  Slice
} from "./chunk-ZRMAPHIN.js";

// .yarn/__virtual__/prosemirror-utils-bangle-virtual-4dbba9a319/5/Users/ted/.yarn/berry/cache/prosemirror-utils-bangle-npm-0.0.4-afcf52a725-10c0.zip/node_modules/prosemirror-utils-bangle/src/transforms.js
var removeParentNodeOfType = (nodeType) => (tr) => {
  const parent = findParentNodeOfType(nodeType)(tr.selection);
  if (parent) {
    return removeNodeAtPos(parent.pos)(tr);
  }
  return tr;
};
var replaceParentNodeOfType = (nodeType, content) => (tr) => {
  if (!Array.isArray(nodeType)) {
    nodeType = [nodeType];
  }
  for (let i = 0, count = nodeType.length; i < count; i++) {
    const parent = findParentNodeOfType(nodeType[i])(tr.selection);
    if (parent) {
      const newTr = replaceNodeAtPos(parent.pos, content)(tr);
      if (newTr !== tr) {
        return newTr;
      }
    }
  }
  return tr;
};
var removeSelectedNode = (tr) => {
  if (isNodeSelection(tr.selection)) {
    const from = tr.selection.$from.pos;
    const to = tr.selection.$to.pos;
    return cloneTr(tr.delete(from, to));
  }
  return tr;
};
var replaceSelectedNode = (content) => (tr) => {
  if (isNodeSelection(tr.selection)) {
    const { $from, $to } = tr.selection;
    if (content instanceof Fragment && $from.parent.canReplace($from.index(), $from.indexAfter(), content) || $from.parent.canReplaceWith(
      $from.index(),
      $from.indexAfter(),
      content.type
    )) {
      return cloneTr(
        tr.replaceWith($from.pos, $to.pos, content).setSelection(new NodeSelection(tr.doc.resolve($from.pos)))
      );
    }
  }
  return tr;
};
var setTextSelection = (position, dir = 1) => (tr) => {
  const nextSelection = Selection.findFrom(tr.doc.resolve(position), dir, true);
  if (nextSelection) {
    return tr.setSelection(nextSelection);
  }
  return tr;
};
var isSelectableNode = (node) => node.type && node.type.spec.selectable;
var shouldSelectNode = (node) => isSelectableNode(node) && node.type.isLeaf;
var setSelection = (node, pos, tr) => {
  if (shouldSelectNode(node)) {
    return tr.setSelection(new NodeSelection(tr.doc.resolve(pos)));
  }
  return setTextSelection(pos)(tr);
};
var safeInsert = (content, position, tryToReplace) => (tr) => {
  const hasPosition = typeof position === "number";
  const { $from } = tr.selection;
  const $insertPos = hasPosition ? tr.doc.resolve(position) : isNodeSelection(tr.selection) ? tr.doc.resolve($from.pos + 1) : $from;
  const { parent } = $insertPos;
  if (isNodeSelection(tr.selection) && tryToReplace) {
    const oldTr = tr;
    tr = replaceSelectedNode(content)(tr);
    if (oldTr !== tr) {
      return tr;
    }
  }
  if (isEmptyParagraph(parent)) {
    const oldTr = tr;
    tr = replaceParentNodeOfType(parent.type, content)(tr);
    if (oldTr !== tr) {
      const pos = isSelectableNode(content) ? (
        // for selectable node, selection position would be the position of the replaced parent
        $insertPos.before($insertPos.depth)
      ) : $insertPos.pos;
      return setSelection(content, pos, tr);
    }
  }
  if (canInsert($insertPos, content)) {
    tr.insert($insertPos.pos, content);
    const pos = hasPosition ? $insertPos.pos : isSelectableNode(content) ? (
      // for atom nodes selection position after insertion is the previous pos
      tr.selection.$anchor.pos - 1
    ) : tr.selection.$anchor.pos;
    return cloneTr(setSelection(content, pos, tr));
  }
  for (let i = $insertPos.depth; i > 0; i--) {
    const pos = $insertPos.after(i);
    const $pos = tr.doc.resolve(pos);
    if (canInsert($pos, content)) {
      tr.insert(pos, content);
      return cloneTr(setSelection(content, pos, tr));
    }
  }
  return tr;
};
var setParentNodeMarkup = (nodeType, type, attrs, marks) => (tr) => {
  const parent = findParentNodeOfType(nodeType)(tr.selection);
  if (parent) {
    return cloneTr(
      tr.setNodeMarkup(
        parent.pos,
        type,
        Object.assign({}, parent.node.attrs, attrs),
        marks
      )
    );
  }
  return tr;
};
var selectParentNodeOfType = (nodeType) => (tr) => {
  if (!isNodeSelection(tr.selection)) {
    const parent = findParentNodeOfType(nodeType)(tr.selection);
    if (parent) {
      return cloneTr(tr.setSelection(NodeSelection.create(tr.doc, parent.pos)));
    }
  }
  return tr;
};
var removeNodeBefore = (tr) => {
  const position = findPositionOfNodeBefore(tr.selection);
  if (typeof position === "number") {
    return removeNodeAtPos(position)(tr);
  }
  return tr;
};

// .yarn/__virtual__/prosemirror-utils-bangle-virtual-4dbba9a319/5/Users/ted/.yarn/berry/cache/prosemirror-utils-bangle-npm-0.0.4-afcf52a725-10c0.zip/node_modules/prosemirror-utils-bangle/src/helpers.js
var isNodeSelection = (selection) => {
  return selection instanceof NodeSelection;
};
var equalNodeType = (nodeType, node) => {
  return Array.isArray(nodeType) && nodeType.indexOf(node.type) > -1 || node.type === nodeType;
};
var cloneTr = (tr) => {
  return Object.assign(Object.create(tr), tr).setTime(Date.now());
};
var replaceNodeAtPos = (position, content) => (tr) => {
  const node = tr.doc.nodeAt(position);
  const $pos = tr.doc.resolve(position);
  if (canReplace($pos, content)) {
    tr = tr.replaceWith(position, position + node.nodeSize, content);
    const start = tr.selection.$from.pos - 1;
    tr = setTextSelection(Math.max(start, 0), -1)(tr);
    tr = setTextSelection(tr.selection.$from.start())(tr);
    return cloneTr(tr);
  }
  return tr;
};
var canReplace = ($pos, content) => {
  const node = $pos.node($pos.depth);
  return node && node.type.validContent(
    content instanceof Fragment ? content : Fragment.from(content)
  );
};
var removeNodeAtPos = (position) => (tr) => {
  const node = tr.doc.nodeAt(position);
  return cloneTr(tr.delete(position, position + node.nodeSize));
};
var canInsert = ($pos, content) => {
  const index = $pos.index();
  if (content instanceof Fragment) {
    return $pos.parent.canReplace(index, index, content);
  } else if (content instanceof Node2) {
    return $pos.parent.canReplaceWith(index, index, content.type);
  }
  return false;
};
var isEmptyParagraph = (node) => {
  return !node || node.type.name === "paragraph" && node.nodeSize === 2;
};

// .yarn/__virtual__/prosemirror-utils-bangle-virtual-4dbba9a319/5/Users/ted/.yarn/berry/cache/prosemirror-utils-bangle-npm-0.0.4-afcf52a725-10c0.zip/node_modules/prosemirror-utils-bangle/src/selection.js
var findParentNode = (predicate) => ({ $from }) => findParentNodeClosestToPos($from, predicate);
var findParentNodeClosestToPos = ($pos, predicate) => {
  for (let i = $pos.depth; i > 0; i--) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
};
var findParentDomRef = (predicate, domAtPos) => (selection) => {
  const parent = findParentNode(predicate)(selection);
  if (parent) {
    return findDomRefAtPos(parent.pos, domAtPos);
  }
};
var hasParentNode = (predicate) => (selection) => {
  return !!findParentNode(predicate)(selection);
};
var findParentNodeOfType = (nodeType) => (selection) => {
  return findParentNode((node) => equalNodeType(nodeType, node))(selection);
};
var findParentNodeOfTypeClosestToPos = ($pos, nodeType) => {
  return findParentNodeClosestToPos(
    $pos,
    (node) => equalNodeType(nodeType, node)
  );
};
var hasParentNodeOfType = (nodeType) => (selection) => {
  return hasParentNode((node) => equalNodeType(nodeType, node))(selection);
};
var findParentDomRefOfType = (nodeType, domAtPos) => (selection) => {
  return findParentDomRef((node) => equalNodeType(nodeType, node), domAtPos)(
    selection
  );
};
var findSelectedNodeOfType = (nodeType) => (selection) => {
  if (isNodeSelection(selection)) {
    const { node, $from } = selection;
    if (equalNodeType(nodeType, node)) {
      return { node, pos: $from.pos, depth: $from.depth };
    }
  }
};
var findPositionOfNodeBefore = (selection) => {
  const { nodeBefore } = selection.$from;
  const maybeSelection = Selection.findFrom(selection.$from, -1);
  if (maybeSelection && nodeBefore) {
    const parent = findParentNodeOfType(nodeBefore.type)(maybeSelection);
    if (parent) {
      return parent.pos;
    }
    return maybeSelection.$from.pos;
  }
};
var findDomRefAtPos = (position, domAtPos) => {
  const dom = domAtPos(position);
  const node = dom.node.childNodes[dom.offset];
  if (dom.node.nodeType === Node.TEXT_NODE) {
    return dom.node.parentNode;
  }
  if (!node || node.nodeType === Node.TEXT_NODE) {
    return dom.node;
  }
  return node;
};

// .yarn/__virtual__/prosemirror-utils-bangle-virtual-4dbba9a319/5/Users/ted/.yarn/berry/cache/prosemirror-utils-bangle-npm-0.0.4-afcf52a725-10c0.zip/node_modules/prosemirror-utils-bangle/src/node.js
var flatten = (node, descend = true) => {
  if (!node) {
    throw new Error('Invalid "node" parameter');
  }
  const result = [];
  node.descendants((child, pos) => {
    result.push({ node: child, pos });
    if (!descend) {
      return false;
    }
  });
  return result;
};
var findChildren = (node, predicate, descend) => {
  if (!node) {
    throw new Error('Invalid "node" parameter');
  } else if (!predicate) {
    throw new Error('Invalid "predicate" parameter');
  }
  return flatten(node, descend).filter((child) => predicate(child.node));
};
var findTextNodes = (node, descend) => {
  return findChildren(node, (child) => child.isText, descend);
};
var findInlineNodes = (node, descend) => {
  return findChildren(node, (child) => child.isInline, descend);
};
var findBlockNodes = (node, descend) => {
  return findChildren(node, (child) => child.isBlock, descend);
};
var findChildrenByAttr = (node, predicate, descend) => {
  return findChildren(node, (child) => !!predicate(child.attrs), descend);
};
var findChildrenByType = (node, nodeType, descend) => {
  return findChildren(node, (child) => child.type === nodeType, descend);
};
var findChildrenByMark = (node, markType, descend) => {
  return findChildren(node, (child) => markType.isInSet(child.marks), descend);
};
var contains = (node, nodeType) => {
  return !!findChildrenByType(node, nodeType).length;
};

// .yarn/__virtual__/@bangle.dev-utils-virtual-72745470c3/5/Users/ted/.yarn/berry/cache/@bangle.dev-utils-npm-0.32.0-ea437e90b3-10c0.zip/node_modules/@bangle.dev/utils/dist/index.js
var browser = {
  mac: false,
  ie: false,
  ie_version: 0,
  gecko: false,
  chrome: false,
  chrome_version: 0,
  android: false,
  ios: false,
  webkit: false
};
if (typeof navigator !== "undefined" && typeof document !== "undefined") {
  const ieEdge = /Edge\/(\d+)/.exec(navigator.userAgent);
  const ieUpTo10 = /MSIE \d/.test(navigator.userAgent);
  const ie11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  browser.mac = /Mac/.test(navigator.platform);
  let ie = browser.ie = !!(ieUpTo10 || ie11up || ieEdge);
  browser.ie_version = ieUpTo10 ? (
    // @ts-ignore TS doesn't understand browser quirks
    document.documentMode || 6
  ) : ie11up ? +ie11up[1] : ieEdge ? +ieEdge[1] : null;
  browser.gecko = !ie && /gecko\/\d/i.test(navigator.userAgent);
  browser.chrome = !ie && /Chrome\//.test(navigator.userAgent);
  browser.chrome_version = parseInt((navigator.userAgent.match(/Chrome\/(\d{2})/) || [])[1] || "0", 10);
  browser.android = /Android \d/.test(navigator.userAgent);
  browser.ios = !ie && /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  browser.webkit = !ie && !!document.documentElement && "WebkitAppearance" in document.documentElement.style;
}
var isChromeWithSelectionBug = browser.chrome && !browser.android && browser.chrome_version >= 58;
var copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
var canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
var changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
var changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", {
    ...toStringDescriptor,
    value: newToString
  });
};
function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
}
function debounceFn(inputFunction, options = {}) {
  if (typeof inputFunction !== "function") {
    throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
  }
  const { wait = 0, maxWait = Number.POSITIVE_INFINITY, before = false, after = true } = options;
  if (!before && !after) {
    throw new Error("Both `before` and `after` are false, function wouldn't be called.");
  }
  let timeout;
  let maxTimeout;
  let result;
  const debouncedFunction = function(...arguments_) {
    const context = this;
    const later = () => {
      timeout = void 0;
      if (maxTimeout) {
        clearTimeout(maxTimeout);
        maxTimeout = void 0;
      }
      if (after) {
        result = inputFunction.apply(context, arguments_);
      }
    };
    const maxLater = () => {
      maxTimeout = void 0;
      if (timeout) {
        clearTimeout(timeout);
        timeout = void 0;
      }
      if (after) {
        result = inputFunction.apply(context, arguments_);
      }
    };
    const shouldCallNow = before && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (maxWait > 0 && maxWait !== Number.POSITIVE_INFINITY && !maxTimeout) {
      maxTimeout = setTimeout(maxLater, maxWait);
    }
    if (shouldCallNow) {
      result = inputFunction.apply(context, arguments_);
    }
    return result;
  };
  mimicFunction(debouncedFunction, inputFunction);
  debouncedFunction.cancel = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
    if (maxTimeout) {
      clearTimeout(maxTimeout);
      maxTimeout = void 0;
    }
  };
  return debouncedFunction;
}
var nodeEnv = void 0;
try {
  nodeEnv = "development";
} catch (err) {
}
var APP_ENV = nodeEnv;
var isProdEnv = nodeEnv === "production";
var isTestEnv = nodeEnv === "test";
function assertNotUndefined(value, message) {
  if (value === void 0) {
    throw new Error(`assertion failed: ${message}`);
  }
}
function weakCache(fn) {
  const cache = /* @__PURE__ */ new WeakMap();
  return (arg) => {
    let value = cache.get(arg);
    if (value) {
      return value;
    }
    value = fn(arg);
    cache.set(arg, value);
    return value;
  };
}
function compose(func, ...funcs) {
  const allFuncs = [func, ...funcs];
  return function composed(raw) {
    return allFuncs.reduceRight((prev, func2) => func2(prev), raw);
  };
}
var MatchType = class {
  constructor(start, end, match, _sourceString) {
    this.start = start;
    this.end = end;
    this.match = match;
    this._sourceString = _sourceString;
  }
  get subString() {
    return this._sourceString.slice(this.start, this.end);
  }
};
function matchAllPlus(regexp, str) {
  const result = [];
  let prevElementEnd = 0;
  let match;
  while (match = regexp.exec(str)) {
    const curStart = match.index;
    const curEnd = curStart + match[0].length;
    if (prevElementEnd !== curStart) {
      result.push(new MatchType(prevElementEnd, curStart, false, str));
    }
    result.push(new MatchType(curStart, curEnd, true, str));
    prevElementEnd = curEnd;
  }
  if (result.length === 0) {
    return [new MatchType(0, str.length, false, str)];
  }
  const lastItemEnd = result[result.length - 1] && result[result.length - 1].end;
  if (lastItemEnd && lastItemEnd !== str.length) {
    result.push(new MatchType(lastItemEnd, str.length, false, str));
  }
  return result;
}
function uuid(len = 10) {
  return Math.random().toString(36).substring(2, 15).slice(0, len);
}
function abortableSetTimeout(callback, signal, ms) {
  const timer = setTimeout(callback, ms);
  signal.addEventListener("abort", () => {
    clearTimeout(timer);
  }, { once: true });
}
function getIdleCallback(cb) {
  if (typeof window !== "undefined" && window.requestIdleCallback) {
    return window.requestIdleCallback(cb);
  }
  var t = Date.now();
  return setTimeout(function() {
    cb({
      didTimeout: false,
      timeRemaining: function() {
        return Math.max(0, 50 - (Date.now() - t));
      }
    });
  }, 1);
}
function cancelablePromise(promise) {
  let hasCanceled = false;
  const wrappedPromise = new Promise((resolve, reject) => promise.then((val) => hasCanceled ? reject({ isCanceled: true }) : resolve(val)).catch((error) => hasCanceled ? reject({ isCanceled: true }) : reject(error)));
  return {
    promise: wrappedPromise,
    cancel() {
      hasCanceled = true;
    }
  };
}
function sleep(t = 20) {
  return new Promise((res) => setTimeout(res, t));
}
function objectMapValues(obj, map) {
  return Object.fromEntries(Object.entries(obj).map(([key, value]) => {
    return [key, map(value, key)];
  }));
}
function objectFilter(obj, cb) {
  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {
    return cb(value, key);
  }));
}
function createObject(entries) {
  return Object.fromEntries(entries.filter((e) => e[0] != null));
}
function serialExecuteQueue() {
  let prev = Promise.resolve();
  return {
    add(cb) {
      return new Promise((resolve, reject) => {
        const run = async () => {
          try {
            const result = await cb();
            return {
              rejected: false,
              value: result
            };
          } catch (e) {
            return {
              rejected: true,
              value: e
            };
          }
        };
        prev = prev.then(() => {
          return run().then(({ value, rejected }) => {
            if (rejected) {
              reject(value);
            } else {
              resolve(value);
            }
          });
        });
      });
    }
  };
}
function simpleLRU(size) {
  let array = [];
  let removeItems = () => {
    while (array.length > size) {
      array.shift();
    }
  };
  return {
    entries() {
      return array.slice(0);
    },
    remove(key) {
      array = array.filter((item) => item.key !== key);
    },
    clear() {
      array = [];
    },
    get(key) {
      let result = array.find((item) => item.key === key);
      if (result) {
        this.set(key, result.value);
        return result.value;
      }
      return void 0;
    },
    set(key, value) {
      this.remove(key);
      array.push({ key, value });
      removeItems();
    }
  };
}
function domEventListener(element, type, listener, options) {
  element.addEventListener(type, listener, options);
  return () => {
    element.removeEventListener(type, listener, options);
  };
}
function rafSchedule(fn) {
  let lastArgs = [];
  let frameId = null;
  const wrapperFn = (...args) => {
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(() => {
      frameId = null;
      fn(...lastArgs);
    });
  };
  wrapperFn.cancel = () => {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
}
var bangleWarn = isTestEnv || isProdEnv ? () => {
} : console.warn.bind(console, "Warning in bangle.js:");
function domSerializationHelpers(name, { tag = "div", content, ignoreAttrs = [], parsingPriority = 51 } = {}) {
  const serializer = (node) => JSON.stringify(objectFilter(node.attrs || {}, (_value, key) => !ignoreAttrs.includes(key)));
  return {
    toDOM: (node) => {
      const domSpec = [
        tag,
        {
          "data-bangle-name": name,
          "data-bangle-attrs": serializer(node)
        }
      ];
      if (content !== void 0) {
        if (typeof content === "function") {
          domSpec.push(content(node));
        } else {
          domSpec.push(content);
        }
      }
      return domSpec;
    },
    parseDOM: [
      {
        priority: parsingPriority,
        tag: `${tag}[data-bangle-name="${name}"]`,
        getAttrs: (dom) => {
          const attrs = dom.getAttribute("data-bangle-attrs");
          if (!attrs) {
            return {};
          }
          return JSON.parse(attrs);
        }
      }
    ]
  };
}
function createElement(spec) {
  const { dom, contentDOM } = DOMSerializer.renderSpec(window.document, spec);
  if (contentDOM) {
    throw new Error("createElement does not support creating contentDOM");
  }
  return dom;
}
var Either = class _Either {
  static flatMap(either, rightFn) {
    if (_Either.isLeft(either)) {
      return _Either.left(either.left);
    } else if (_Either.isRight(either)) {
      return rightFn(either.right, { left: _Either.left });
    }
    throw new Error("Either.flatMap: unknown type");
  }
  static fold(either, leftFn, rightFn) {
    if (_Either.isLeft(either)) {
      return _Either.left(leftFn(either.left));
    } else if (_Either.isRight(either)) {
      return _Either.right(rightFn(either.right));
    }
    throw new Error("Either.fold: unknown type");
  }
  static isLeft(either) {
    return either.type === "left";
  }
  static isRight(either) {
    return either.type === "right";
  }
  static left(value) {
    return { left: value, right: void 0, type: "left" };
  }
  static map(either, rightFn) {
    return _Either.fold(either, (left) => left, rightFn);
  }
  static mapLeft(either, leftFn) {
    return _Either.fold(either, leftFn, (right) => right);
  }
  static right(value) {
    return {
      left: void 0,
      right: value,
      type: "right"
    };
  }
  static unwrap(either) {
    if (_Either.isLeft(either)) {
      return [either.left, void 0];
    } else if (_Either.isRight(either)) {
      return [void 0, either.right];
    }
    throw new Error("Either.unwrap: unknown type");
  }
  static value(either) {
    if (_Either.isLeft(either)) {
      return either.left;
    } else if (_Either.isRight(either)) {
      return either.right;
    }
    throw new Error("Either.value: unknown type");
  }
};
var Emitter = class {
  constructor() {
    this._callbacks = {};
  }
  // If fn is not provided, all event listeners for that event will be removed.
  destroy() {
    this._callbacks = {};
  }
  emit(event, data) {
    const callbacks = this._callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback(data));
    }
    return this;
  }
  // If neither is provided, all event listeners will be removed.
  off(event, fn) {
    if (!arguments.length) {
      this._callbacks = {};
    } else {
      const callbacks = this._callbacks ? this._callbacks[event] : null;
      if (callbacks) {
        if (fn) {
          this._callbacks[event] = callbacks.filter((cb) => cb !== fn);
        } else {
          this._callbacks[event] = [];
        }
      }
    }
    return this;
  }
  // Add an event listener for given event
  on(event, fn) {
    if (!this._callbacks[event]) {
      this._callbacks[event] = [];
    }
    this._callbacks[event].push(fn);
    return this;
  }
};
function getMarksBetween(start, end, state) {
  let marks = [];
  state.doc.nodesBetween(start, end, (node, pos) => {
    marks = [
      ...marks,
      ...node.marks.map((mark) => ({
        start: pos,
        end: pos + node.nodeSize,
        mark
      }))
    ];
  });
  return marks;
}
function markInputRule(regexp, markType) {
  return new InputRule(regexp, (state, match, start, end) => {
    const { tr } = state;
    const m = match.length - 1;
    let markEnd = end;
    let markStart = start;
    const matchMths = match[m];
    const firstMatch = match[0];
    const mathOneBeforeM = match[m - 1];
    if (matchMths != null && firstMatch != null && mathOneBeforeM != null) {
      const matchStart = start + firstMatch.indexOf(mathOneBeforeM);
      const matchEnd = matchStart + mathOneBeforeM.length - 1;
      const textStart = matchStart + mathOneBeforeM.lastIndexOf(matchMths);
      const textEnd = textStart + matchMths.length;
      const excludedMarks = getMarksBetween(start, end, state).filter((item) => {
        return item.mark.type.excludes(markType);
      }).filter((item) => item.end > matchStart);
      if (excludedMarks.length) {
        return null;
      }
      if (textEnd < matchEnd) {
        tr.delete(textEnd, matchEnd);
      }
      if (textStart > matchStart) {
        tr.delete(matchStart, textStart);
      }
      markStart = matchStart;
      markEnd = markStart + matchMths.length;
    }
    tr.addMark(markStart, markEnd, markType.create());
    tr.removeStoredMark(markType);
    return tr;
  });
}
function markPasteRule(regexp, type, getAttrs) {
  const handler = (fragment, parent) => {
    const nodes = [];
    fragment.forEach((child) => {
      if (child.isText) {
        const { text, marks } = child;
        let pos = 0;
        let match;
        const isLink = !!marks.filter((x) => x.type.name === "link")[0];
        while (!isLink && (match = regexp.exec(text)) !== null) {
          if (parent && parent.type.allowsMarkType(type) && match[1]) {
            const start = match.index;
            const end = start + match[0].length;
            const textStart = start + match[0].indexOf(match[1]);
            const textEnd = textStart + match[1].length;
            const attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
            if (start > 0) {
              nodes.push(child.cut(pos, start));
            }
            nodes.push(child.cut(textStart, textEnd).mark(type.create(attrs).addToSet(child.marks)));
            pos = end;
          }
        }
        if (pos < text.length) {
          nodes.push(child.cut(pos));
        }
      } else {
        nodes.push(child.copy(handler(child.content, child)));
      }
    });
    return Fragment.fromArray(nodes);
  };
  return new Plugin({
    props: {
      transformPasted: (slice) => new Slice(handler(slice.content), slice.openStart, slice.openEnd)
    }
  });
}
var counter = 0;
var unique = Math.random();
var ObjectUID = class extends WeakMap {
  get(obj) {
    let uid = super.get(obj);
    if (uid) {
      return uid;
    }
    uid = (counter++).toString() + "-" + unique;
    this.set(obj, uid);
    return uid;
  }
};
var objectUid = new ObjectUID();
var GapCursorSelection = class extends Selection {
};
function rafCommandExec(view, command) {
  requestAnimationFrame(() => {
    command(view.state, view.dispatch, view);
  });
}
function filter(predicates, cmd) {
  return (state, dispatch, view) => {
    if (cmd == null) {
      return false;
    }
    if (!Array.isArray(predicates)) {
      predicates = [predicates];
    }
    if (predicates.some((pred) => !pred(state, view))) {
      return false;
    }
    return cmd(state, dispatch, view) || false;
  };
}
function isMarkActiveInSelection(type) {
  return (state) => {
    const { from, $from, to, empty } = state.selection;
    if (empty) {
      return Boolean(type.isInSet(state.tr.storedMarks || $from.marks()));
    }
    return Boolean(state.doc.rangeHasMark(from, to, type));
  };
}
var validPos = (pos, doc) => Number.isInteger(pos) && pos >= 0 && pos < doc.content.size;
var validListParent = (type, schemaNodes) => {
  const { bulletList, orderedList } = schemaNodes;
  return [bulletList, orderedList].includes(type);
};
function getMarkAttrs(editorState, type) {
  const { from, to } = editorState.selection;
  let marks = [];
  editorState.doc.nodesBetween(from, to, (node) => {
    marks = [...marks, ...node.marks];
  });
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  return mark ? mark.attrs : {};
}
function nodeIsActive(state, type, attrs = {}) {
  const predicate = (node2) => node2.type === type;
  const node = findSelectedNodeOfType(type)(state.selection) || findParentNode(predicate)(state.selection);
  if (!Object.keys(attrs).length || !node) {
    return !!node;
  }
  return node.node.hasMarkup(type, { ...node.node.attrs, ...attrs });
}
function hasVisibleContent(node) {
  const isInlineNodeHasVisibleContent = (inlineNode) => {
    return inlineNode.isText ? !!inlineNode.textContent.trim() : inlineNode.type.name !== "hardBreak";
  };
  if (node.isInline) {
    return isInlineNodeHasVisibleContent(node);
  } else if (node.isBlock && (node.isLeaf || node.isAtom)) {
    return true;
  } else if (!node.childCount) {
    return false;
  }
  for (let index = 0; index < node.childCount; index++) {
    const child = node.child(index);
    if (hasVisibleContent(child)) {
      return true;
    }
  }
  return false;
}
function isNodeEmpty(node) {
  if (node && node.textContent) {
    return false;
  }
  if (!node || !node.childCount || node.childCount === 1 && isEmptyParagraph2(node.firstChild)) {
    return true;
  }
  const block = [];
  const nonBlock = [];
  node.forEach((child) => {
    child.isInline ? nonBlock.push(child) : block.push(child);
  });
  return !nonBlock.length && !block.filter((childNode) => !!childNode.childCount && !(childNode.childCount === 1 && isEmptyParagraph2(childNode.firstChild)) || childNode.isAtom).length;
}
function isEmptyDocument(node) {
  const nodeChild = node.content.firstChild;
  if (node.childCount !== 1 || !nodeChild) {
    return false;
  }
  return nodeChild.type.name === "paragraph" && !nodeChild.childCount && nodeChild.nodeSize === 2 && (!nodeChild.marks || nodeChild.marks.length === 0);
}
function isEmptyParagraph2(node) {
  return !node || node.type.name === "paragraph" && !node.textContent && !node.childCount;
}
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating) {
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0) {
        return $pos.doc.resolve($pos.before(i + 1));
      }
      if ($pos.node(i).type.spec.isolating) {
        break;
      }
    }
  }
  return null;
}
function isRangeOfType(doc, $from, $to, nodeType) {
  return getAncestorNodesBetween(doc, $from, $to).filter((node) => node.type !== nodeType).length === 0;
}
function getAncestorNodesBetween(doc, $from, $to) {
  const nodes = [];
  const maxDepth = findAncestorPosition(doc, $from).depth;
  let current = doc.resolve($from.start(maxDepth));
  while (current.pos <= $to.start($to.depth)) {
    const depth = Math.min(current.depth, maxDepth);
    const node = current.node(depth);
    if (node) {
      nodes.push(node);
    }
    if (depth === 0) {
      break;
    }
    let next = doc.resolve(current.after(depth));
    if (next.start(depth) >= doc.nodeSize - 2) {
      break;
    }
    if (next.depth !== current.depth) {
      next = doc.resolve(next.pos + 2);
    }
    if (next.depth) {
      current = doc.resolve(next.start(next.depth));
    } else {
      current = doc.resolve(next.end(next.depth));
    }
  }
  return nodes;
}
function findAncestorPosition(doc, pos) {
  const nestableBlocks = ["blockquote", "bulletList", "orderedList"];
  if (pos.depth === 1) {
    return pos;
  }
  let node = pos.node(pos.depth);
  let newPos = pos;
  while (pos.depth >= 1) {
    pos = doc.resolve(pos.before(pos.depth));
    node = pos.node(pos.depth);
    if (node && nestableBlocks.indexOf(node.type.name) !== -1) {
      newPos = pos;
    }
  }
  return newPos;
}
var isEmptySelectionAtStart = (state) => {
  const { empty, $from } = state.selection;
  return empty && ($from.parentOffset === 0 || state.selection instanceof GapCursorSelection);
};
var sanitiseSelectionMarksForWrapping = (state, newParentType) => {
  let tr = null;
  let { from, to } = state.tr.selection;
  state.doc.nodesBetween(from, to, (node, pos, parent) => {
    if (node.isText || pos < from || pos > to || !parent) {
      return true;
    }
    node.marks.forEach((mark) => {
      if (!parent.type.allowsMarkType(mark.type) || newParentType && !newParentType.allowsMarkType(mark.type)) {
        const filteredMarks = node.marks.filter((m) => m.type !== mark.type);
        const position = pos > 0 ? pos - 1 : 0;
        let targetNode = state.doc.nodeAt(position);
        if (!targetNode || targetNode.isText) {
          return;
        }
        tr = (tr || state.tr).setNodeMarkup(position, void 0, node.attrs, filteredMarks);
      }
    });
    return;
  }, from);
  return tr;
};
var getListLiftTarget = (type, schema, resPos) => {
  let target = resPos.depth;
  const { bulletList, orderedList } = schema.nodes;
  let listItem = type;
  if (!listItem) {
    ({ listItem } = schema.nodes);
  }
  for (let i = resPos.depth; i > 0; i--) {
    const node = resPos.node(i);
    if (node.type === bulletList || node.type === orderedList) {
      target = i;
    }
    if (node.type !== bulletList && node.type !== orderedList && node.type !== listItem) {
      break;
    }
  }
  return target - 1;
};
function mapChildren(node, callback) {
  const array = [];
  for (let i = 0; i < node.childCount; i++) {
    array.push(callback(node.child(i), i, node instanceof Fragment ? node : node.content));
  }
  return array;
}
var isFirstChildOfParent = (state) => {
  const { $from } = state.selection;
  return $from.depth > 1 ? state.selection instanceof GapCursorSelection && $from.parentOffset === 0 || $from.index($from.depth - 1) === 0 : true;
};
function mapSlice(slice, callback) {
  const fragment = mapFragment(slice.content, callback);
  return new Slice(fragment, slice.openStart, slice.openEnd);
}
function mapFragment(content, callback, parent) {
  const children = [];
  for (let i = 0, size = content.childCount; i < size; i++) {
    const node = content.child(i);
    const transformed = node.isLeaf ? callback(node, parent, i) : callback(node.copy(mapFragment(node.content, callback, node)), parent, i);
    if (transformed) {
      if (transformed instanceof Fragment) {
        children.push(...getFragmentBackingArray(transformed));
      } else if (Array.isArray(transformed)) {
        children.push(...transformed);
      } else {
        children.push(transformed);
      }
    }
  }
  return Fragment.fromArray(children);
}
function getFragmentBackingArray(fragment) {
  return fragment.content;
}
function insertEmpty(type, placement = "above", nestable = false, attrs) {
  const isAbove = placement === "above";
  const depth = nestable ? -1 : void 0;
  return (state, dispatch) => {
    const insertPos = isAbove ? state.selection.$from.before(depth) : state.selection.$from.after(depth);
    const nodeToInsert = type.createAndFill(attrs);
    const tr = state.tr;
    let newTr = safeInsert(nodeToInsert, insertPos)(state.tr);
    if (tr === newTr) {
      return false;
    }
    if (dispatch) {
      dispatch(newTr.scrollIntoView());
    }
    return true;
  };
}
function findFirstMarkPosition(mark, doc, from, to) {
  let markPos = { start: -1, end: -1 };
  doc.nodesBetween(from, to, (node, pos) => {
    if (markPos.start > -1) {
      return false;
    }
    if (markPos.start === -1 && mark.isInSet(node.marks)) {
      markPos = {
        start: pos,
        end: pos + Math.max(node.textContent.length, 1)
      };
    }
    return;
  });
  return markPos;
}
function valuePlugin(key, value) {
  return new Plugin({
    key,
    state: {
      init() {
        return value;
      },
      apply(_, v) {
        return v;
      }
    }
  });
}
function toHTMLString(state) {
  const div = document.createElement("div");
  const fragment = DOMSerializer.fromSchema(state.schema).serializeFragment(state.doc.content);
  div.appendChild(fragment);
  return div.innerHTML;
}
function extendDispatch(dispatch, tapTr) {
  return dispatch && ((tr) => {
    if (tr.isGeneric) {
      tapTr(tr);
    }
    dispatch(tr);
  });
}
function getNodeType(arg, name) {
  const nodeType = arg instanceof EditorState ? arg.schema.nodes[name] : arg.nodes[name];
  assertNotUndefined(nodeType, `nodeType ${name} not found`);
  return nodeType;
}
function getParaNodeType(arg) {
  const nodeType = arg instanceof EditorState ? arg.schema.nodes["paragraph"] : arg.nodes["paragraph"];
  assertNotUndefined(nodeType, `nodeType paragraph not found`);
  return nodeType;
}

export {
  removeParentNodeOfType,
  replaceParentNodeOfType,
  removeSelectedNode,
  replaceSelectedNode,
  setTextSelection,
  safeInsert,
  setParentNodeMarkup,
  selectParentNodeOfType,
  removeNodeBefore,
  isNodeSelection,
  canInsert,
  findParentNode,
  findParentNodeClosestToPos,
  findParentDomRef,
  hasParentNode,
  findParentNodeOfType,
  findParentNodeOfTypeClosestToPos,
  hasParentNodeOfType,
  findParentDomRefOfType,
  findSelectedNodeOfType,
  findPositionOfNodeBefore,
  findDomRefAtPos,
  flatten,
  findChildren,
  findTextNodes,
  findInlineNodes,
  findBlockNodes,
  findChildrenByAttr,
  findChildrenByType,
  findChildrenByMark,
  contains,
  browser,
  isChromeWithSelectionBug,
  debounceFn,
  APP_ENV,
  isProdEnv,
  isTestEnv,
  assertNotUndefined,
  weakCache,
  compose,
  matchAllPlus,
  uuid,
  abortableSetTimeout,
  getIdleCallback,
  cancelablePromise,
  sleep,
  objectMapValues,
  objectFilter,
  createObject,
  serialExecuteQueue,
  simpleLRU,
  domEventListener,
  rafSchedule,
  bangleWarn,
  domSerializationHelpers,
  createElement,
  Either,
  Emitter,
  markInputRule,
  markPasteRule,
  ObjectUID,
  objectUid,
  GapCursorSelection,
  rafCommandExec,
  filter,
  isMarkActiveInSelection,
  validPos,
  validListParent,
  getMarkAttrs,
  nodeIsActive,
  hasVisibleContent,
  isNodeEmpty,
  isEmptyDocument,
  isEmptyParagraph2 as isEmptyParagraph,
  findCutBefore,
  isRangeOfType,
  getAncestorNodesBetween,
  findAncestorPosition,
  isEmptySelectionAtStart,
  sanitiseSelectionMarksForWrapping,
  getListLiftTarget,
  mapChildren,
  isFirstChildOfParent,
  mapSlice,
  mapFragment,
  getFragmentBackingArray,
  insertEmpty,
  findFirstMarkPosition,
  valuePlugin,
  toHTMLString,
  extendDispatch,
  getNodeType,
  getParaNodeType
};
//# sourceMappingURL=chunk-F3Z2TPKG.js.map
