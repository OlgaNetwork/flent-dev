import {
  domSerializationHelpers
} from "./chunk-HNOPRNJR.js";
import "./chunk-F3Z2TPKG.js";
import "./chunk-ZRMAPHIN.js";
import "./chunk-NVKSN2QT.js";
import "./chunk-AUZ3RYOM.js";

// .yarn/__virtual__/@bangle.dev-markdown-front-matter-virtual-654838ab1f/5/Users/ted/.yarn/berry/cache/@bangle.dev-markdown-front-matter-npm-0.32.0-e98f99cbe4-10c0.zip/node_modules/@bangle.dev/markdown-front-matter/dist/index.js
var spec = specFactory;
var name = "markdownFrontMatter";
function specFactory() {
  const spec2 = {
    type: "node",
    name,
    schema: {
      group: "frontMatter",
      atom: true,
      isolating: true,
      attrs: {
        data: {
          default: ""
        }
      }
    },
    markdown: {
      toMarkdown(state, node) {
        state.write("---\n");
        state.text(node.attrs["data"], false);
        state.write("\n---");
        state.closeBlock(node);
      },
      parseMarkdown: {
        front_matter: {
          block: name,
          getAttrs: (tok) => {
            if (typeof tok.meta === "string") {
              return { data: tok.meta };
            }
            return null;
          },
          noCloseToken: true
        }
      }
    }
  };
  spec2.schema = {
    ...spec2.schema,
    ...domSerializationHelpers(name, {
      tag: "div",
      content: (node) => node.attrs["data"],
      parsingPriority: 52
    })
  };
  return spec2;
}
var markdownFrontMatter = Object.freeze({
  __proto__: null,
  spec
});
function frontMatterPlugin(md, cb = (arg) => {
}) {
  var min_markers = 3, marker_str = "-", marker_char = marker_str.charCodeAt(0), marker_len = marker_str.length;
  function frontMatter(state, startLine, endLine, silent) {
    var pos, nextLine, marker_count, token, old_parent, old_line_max, start_content, auto_closed = false, start = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
    if (startLine !== 0 || marker_char !== state.src.charCodeAt(0)) {
      return false;
    }
    for (pos = start + 1; pos <= max; pos++) {
      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {
        start_content = pos + 1;
        break;
      }
    }
    marker_count = Math.floor((pos - start) / marker_len);
    if (marker_count < min_markers) {
      return false;
    }
    pos -= (pos - start) % marker_len;
    if (silent) {
      return true;
    }
    nextLine = startLine;
    for (; ; ) {
      nextLine++;
      if (nextLine >= endLine) {
        break;
      }
      if (state.src.slice(start, max) === "...") {
        break;
      }
      start = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      if (start < max && state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      if (marker_char !== state.src.charCodeAt(start)) {
        continue;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        continue;
      }
      for (pos = start + 1; pos <= max; pos++) {
        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {
          break;
        }
      }
      if (Math.floor((pos - start) / marker_len) < marker_count) {
        continue;
      }
      pos -= (pos - start) % marker_len;
      pos = state.skipSpaces(pos);
      if (pos < max) {
        continue;
      }
      auto_closed = true;
      break;
    }
    old_parent = state.parentType;
    old_line_max = state.lineMax;
    state.parentType = "container";
    state.lineMax = nextLine;
    token = state.push("front_matter", null, 0);
    token.hidden = true;
    token.markup = state.src.slice(startLine, pos);
    token.block = true;
    token.map = [startLine, pos];
    token.meta = state.src.slice(start_content, start - 1);
    state.parentType = old_parent;
    state.lineMax = old_line_max;
    state.line = nextLine + (auto_closed ? 1 : 0);
    cb(token.meta);
    return true;
  }
  md.block.ruler.before("fence", "front_matter", frontMatter, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  });
}
export {
  frontMatterPlugin as frontMatterMarkdownItPlugin,
  markdownFrontMatter
};
//# sourceMappingURL=@bangle__dev_markdown-front-matter.js.map
