import {
  arrow_default,
  createPopper,
  flip_default,
  offset_default,
  popperOffsets_default,
  preventOverflow_default
} from "./chunk-7TIGO2NG.js";
import {
  assertNotUndefined,
  bangleWarn,
  createObject,
  filter,
  findFirstMarkPosition,
  isChromeWithSelectionBug,
  safeInsert
} from "./chunk-F3Z2TPKG.js";
import {
  DOMSerializer,
  Fragment,
  InputRule,
  Node,
  NodeSelection,
  Plugin,
  PluginKey,
  Selection,
  TextSelection,
  keymap
} from "./chunk-ZRMAPHIN.js";

// .yarn/__virtual__/@bangle.dev-tooltip-virtual-a36c7c7d14/5/Users/ted/.yarn/berry/cache/@bangle.dev-tooltip-npm-0.32.0-1525bd9cfd-10c0.zip/node_modules/@bangle.dev/tooltip/dist/index.js
function createTooltipDOM(tooltipDOMSpec = [
  "div",
  {
    class: "bangle-tooltip",
    role: "tooltip"
  },
  [
    "div",
    {
      class: "bangle-tooltip-content"
    },
    0
  ]
], arrow = false) {
  const { dom, contentDOM } = DOMSerializer.renderSpec(window.document, tooltipDOMSpec);
  if (arrow && !dom.querySelector(".bangle-tooltip-arrow")) {
    const arrowElement = DOMSerializer.renderSpec(window.document, [
      "div",
      {
        "class": "bangle-tooltip-arrow",
        "data-popper-arrow": ""
      }
    ]);
    dom.appendChild(arrowElement.dom);
  }
  return { dom, contentDOM };
}
var plugins$2 = tooltipPlacement;
var rem = typeof window === "undefined" ? 12 : parseFloat(getComputedStyle(document.documentElement).fontSize);
function tooltipPlacement({ stateKey, renderOpts: { tooltipDOMSpec, placement = "top", getReferenceElement, getScrollContainer = (view) => {
  return view.dom.parentElement;
}, onUpdateTooltip = (_state, _dispatch, _view) => {
}, onHideTooltip = (_state, _dispatch, _view) => {
}, tooltipOffset = () => {
  return [0, 0.5 * rem];
}, fallbackPlacements = ["bottom", "top"], customPopperModifiers } }) {
  const plugin = new Plugin({
    view: (view) => {
      return new TooltipPlacementView(view);
    }
  });
  class TooltipPlacementView {
    constructor(view) {
      this.popperInstance = null;
      this._view = view;
      const { dom: tooltipDOM } = createTooltipDOM(tooltipDOMSpec);
      this._tooltip = tooltipDOM;
      this._scrollContainerDOM = getScrollContainer(view);
      this._view.dom.parentNode.appendChild(this._tooltip);
      const pluginState = stateKey.getState(view.state);
      validateState(pluginState);
      if (pluginState.show) {
        this._showTooltip();
        return;
      }
    }
    destroy() {
      if (this.popperInstance) {
        this.popperInstance.destroy();
        this.popperInstance = null;
      }
      this._view.dom.parentNode.removeChild(this._tooltip);
    }
    update(view, prevState) {
      const pluginState = stateKey.getState(view.state);
      if (pluginState === stateKey.getState(prevState)) {
        return;
      }
      if (pluginState.show) {
        onUpdateTooltip.call(this, view.state, view.dispatch, view);
        this._showTooltip();
      } else {
        this._hideTooltip();
      }
    }
    _createPopperInstance(view) {
      if (this.popperInstance) {
        return;
      }
      const showTooltipArrow = this._tooltip.querySelector("[data-popper-arrow]");
      const defaultModifiers = [
        offset_default,
        preventOverflow_default,
        flip_default,
        {
          name: "offset",
          options: {
            offset: (popperState) => {
              return tooltipOffset(popperState);
            }
          }
        },
        {
          name: "flip",
          options: {
            fallbackPlacements,
            padding: 10
          }
        },
        {
          name: "preventOverflow",
          options: {
            boundary: this._scrollContainerDOM
          }
        },
        popperOffsets_default,
        showTooltipArrow ? arrow_default : void 0,
        showTooltipArrow ? {
          name: "arrow",
          options: {
            element: showTooltipArrow
          }
        } : void 0
      ].filter(Boolean);
      this.popperInstance = createPopper(getReferenceElement(view, this._tooltip, this._scrollContainerDOM), this._tooltip, {
        placement,
        modifiers: customPopperModifiers ? customPopperModifiers(view, this._tooltip, this._scrollContainerDOM, defaultModifiers) : defaultModifiers
      });
      onUpdateTooltip.call(this, view.state, view.dispatch, view);
    }
    _hideTooltip() {
      if (this.popperInstance) {
        this._tooltip.removeAttribute("data-show");
        this.popperInstance.destroy();
        this.popperInstance = null;
        onHideTooltip.call(this, this._view.state, this._view.dispatch, this._view);
      }
    }
    _showTooltip() {
      this._tooltip.setAttribute("data-show", "");
      this._createPopperInstance(this._view);
      this.popperInstance.update();
    }
  }
  return plugin;
}
function validateState(state) {
  if (typeof state.show !== "boolean") {
    bangleWarn(`Tooltip must be controlled by a plugin having a boolean field "show" in its state, but received the state=`, state);
    throw new Error('"show" field required.');
  }
}
var tooltipPlacement$1 = Object.freeze({
  __proto__: null,
  plugins: plugins$2
});
var plugins$1 = selectionTooltip;
var commands$1 = {
  updateSelectionTooltipType,
  hideSelectionTooltip,
  queryIsSelectionTooltipActive,
  querySelectionTooltipType
};
var log = () => {
};
function selectionTooltip({ key = new PluginKey("selectionTooltipPlugin"), calculateType = (state, _prevType) => {
  return state.selection.empty ? null : "default";
}, tooltipRenderOpts = {} }) {
  return () => {
    const tooltipDOMSpec = createTooltipDOM(tooltipRenderOpts.tooltipDOMSpec);
    return [
      selectionTooltipState({
        key,
        tooltipDOMSpec,
        calculateType
      }),
      selectionTooltipController({ stateKey: key }),
      plugins$2({
        stateKey: key,
        renderOpts: {
          ...tooltipRenderOpts,
          getReferenceElement: getSelectionReferenceElement,
          tooltipDOMSpec
        }
      })
    ];
  };
}
function selectionTooltipState({ key, calculateType, tooltipDOMSpec }) {
  return new Plugin({
    key,
    state: {
      init: (_, state) => {
        const type = calculateType(state, null);
        return {
          type,
          tooltipContentDOM: tooltipDOMSpec.contentDOM,
          // For tooltipPlacement plugin
          show: typeof type === "string",
          // helpers
          calculateType
        };
      },
      apply: (tr, pluginState) => {
        const meta = tr.getMeta(key);
        if (meta === void 0) {
          return pluginState;
        }
        if (meta.type == null && pluginState.type == null) {
          return pluginState;
        }
        log("update tooltip state to ", meta.type);
        return {
          ...pluginState,
          type: meta.type,
          show: typeof meta.type === "string"
        };
      }
    }
  });
}
function selectionTooltipController({ stateKey }) {
  let mouseDown = false;
  return new Plugin({
    props: {
      handleDOMEvents: {
        mousedown: (_view, _event) => {
          mouseDown = true;
          return false;
        },
        mouseup: (view, _event) => {
          mouseDown = false;
          _syncTooltipOnUpdate(stateKey)(view.state, view.dispatch, view);
          return false;
        }
      }
    },
    view() {
      return {
        update(view, lastState) {
          const state = view.state;
          if (mouseDown || lastState === state) {
            return;
          }
          if (lastState && lastState.doc.eq(state.doc) && lastState.selection.eq(state.selection)) {
            return;
          }
          return _syncTooltipOnUpdate(stateKey)(view.state, view.dispatch, view);
        }
      };
    }
  });
}
function getSelectionReferenceElement(view) {
  return {
    getBoundingClientRect: () => {
      const { selection } = view.state;
      let { head, from } = selection;
      const pos = selection instanceof NodeSelection ? from : head;
      const start = view.coordsAtPos(pos);
      let { top, bottom, left, right } = start;
      let width = right - left;
      if (selection instanceof NodeSelection) {
        const domNode = view.nodeDOM(pos);
        width = domNode ? domNode.clientWidth : width;
      }
      return {
        width,
        height: bottom - top,
        top,
        right,
        bottom,
        left
      };
    }
  };
}
function _syncTooltipOnUpdate(key) {
  return (state, dispatch, view) => {
    const tooltipState = key.getState(state);
    const newType = tooltipState.calculateType(state, tooltipState.type);
    if (typeof newType === "string") {
      return updateSelectionTooltipType(key, newType)(state, dispatch, view);
    }
    if (newType == null && tooltipState.type != null) {
      return hideSelectionTooltip(key)(state, dispatch, view);
    }
    return false;
  };
}
function updateSelectionTooltipType(key, type) {
  return (state, dispatch, _view) => {
    if (dispatch) {
      dispatch(state.tr.setMeta(key, { type }).setMeta("addToHistory", false));
    }
    return true;
  };
}
function hideSelectionTooltip(key) {
  return (state, dispatch, _view) => {
    if (dispatch) {
      dispatch(state.tr.setMeta(key, { type: null }).setMeta("addToHistory", false));
    }
    return true;
  };
}
function queryIsSelectionTooltipActive(key) {
  return (state) => {
    const pluginState = key.getState(state);
    return pluginState && typeof pluginState.type === "string" ? true : false;
  };
}
function querySelectionTooltipType(key) {
  return (state) => {
    const pluginState = key.getState(state);
    return pluginState && pluginState.type;
  };
}
var selectionTooltip$1 = Object.freeze({
  __proto__: null,
  plugins: plugins$1,
  commands: commands$1,
  _syncTooltipOnUpdate,
  updateSelectionTooltipType,
  hideSelectionTooltip,
  queryIsSelectionTooltipActive,
  querySelectionTooltipType
});
var leafNodeReplacementCharacter = "ï¿¼";
function triggerInputRule(schema, markName, trigger) {
  const regexStart = new RegExp(`(^|[.!?\\s${leafNodeReplacementCharacter}])(${escapeRegExp(trigger)})$`);
  const startRule = new InputRule(regexStart, (editorState, match) => {
    const trigger2 = match[3] || match[2];
    if (!trigger2) {
      return null;
    }
    const mark = schema.mark(markName, { trigger: trigger2 });
    const { tr, selection } = editorState;
    if (trigger2.length > 1) {
      const textSelection = TextSelection.create(tr.doc, selection.from, selection.from - trigger2.length + 1);
      tr.setSelection(textSelection);
    }
    const marks = selection.$from.marks();
    return tr.replaceSelectionWith(schema.text(trigger2, [mark, ...marks]), false);
  });
  return startRule;
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reHasRegExpChar = RegExp(reRegExpChar.source);
function escapeRegExp(string) {
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string || "";
}
var spec = specFactory;
var plugins = pluginsFactory;
var commands = {
  queryTriggerText,
  queryIsSuggestTooltipActive,
  replaceSuggestMarkWith,
  incrementSuggestTooltipCounter,
  decrementSuggestTooltipCounter,
  resetSuggestTooltipCounter
};
var defaultKeys = {
  select: "Enter",
  up: "ArrowUp",
  down: "ArrowDown",
  hide: "Escape",
  right: void 0,
  left: void 0
};
function specFactory({ markName, trigger, markColor = "#005893" }) {
  return {
    name: markName,
    type: "mark",
    schema: {
      inclusive: true,
      excludes: "_",
      group: "suggestTriggerMarks",
      parseDOM: [{ tag: `span[data-${markName}]` }],
      toDOM: (mark) => {
        return [
          "span",
          {
            "data-bangle-name": markName,
            "data-suggest-trigger": mark.attrs["trigger"],
            "style": `color: ${markColor}`
          }
        ];
      },
      attrs: {
        trigger: { default: trigger }
      }
    },
    markdown: {
      toMarkdown: {
        open: "",
        close: "",
        mixable: true
      }
    }
  };
}
function pluginsFactory({ key = new PluginKey("suggest_tooltip"), markName, trigger, tooltipRenderOpts, keybindings = defaultKeys, onEnter = (state, dispatch, view) => {
  return removeSuggestMark(key)(state, dispatch, view);
}, onArrowDown = incrementSuggestTooltipCounter(key), onArrowUp = decrementSuggestTooltipCounter(key), onEscape = (state, dispatch, view) => {
  return removeSuggestMark(key)(state, dispatch, view);
}, onArrowLeft, onArrowRight }) {
  return ({ schema }) => {
    const isActiveCheck = queryIsSuggestTooltipActive(key);
    return [
      new Plugin({
        key,
        state: {
          init(_, _state) {
            return {
              trigger,
              markName,
              triggerText: "",
              show: false,
              counter: 0
            };
          },
          apply(tr, pluginState, _oldState, newState) {
            const meta = tr.getMeta(key);
            if (meta === void 0) {
              return pluginState;
            }
            if (meta.type === "RENDER_TOOLTIP") {
              return {
                ...pluginState,
                // Cannot use queryTriggerText because it relies on
                // reading the pluginState which will not be there in newState.
                triggerText: getTriggerText(newState, markName, trigger),
                show: true
              };
            }
            if (meta.type === "HIDE_TOOLTIP") {
              if (pluginState.show === false) {
                return pluginState;
              }
              return {
                ...pluginState,
                triggerText: "",
                show: false,
                counter: 0
              };
            }
            if (meta.type === "INCREMENT_COUNTER") {
              return { ...pluginState, counter: pluginState.counter + 1 };
            }
            if (meta.type === "RESET_COUNTER") {
              return { ...pluginState, counter: 0 };
            }
            if (meta.type === "UPDATE_COUNTER") {
              return { ...pluginState, counter: meta.value };
            }
            if (meta.type === "DECREMENT_COUNTER") {
              return { ...pluginState, counter: pluginState.counter - 1 };
            }
            throw new Error("Unknown type");
          }
        }
      }),
      plugins$2({
        stateKey: key,
        renderOpts: {
          ...tooltipRenderOpts,
          getReferenceElement: referenceElement((state) => {
            const markType = schema.marks[markName];
            assertNotUndefined(markType, `markType ${markName} not found`);
            const { selection } = state;
            return findFirstMarkPosition(markType, state.doc, selection.from - 1, selection.to);
          })
        }
      }),
      triggerInputRule(schema, markName, trigger),
      tooltipController({
        trigger,
        markName,
        key
      }),
      keybindings && keymap(createObject([
        [keybindings.select, filter(isActiveCheck, onEnter)],
        [keybindings.up, filter(isActiveCheck, onArrowUp)],
        [keybindings.down, filter(isActiveCheck, onArrowDown)],
        [keybindings.left, filter(isActiveCheck, onArrowLeft)],
        [keybindings.right, filter(isActiveCheck, onArrowRight)],
        [keybindings.hide, filter(isActiveCheck, onEscape)]
      ]))
    ];
  };
}
function referenceElement(getActiveMarkPos) {
  return (view, _tooltipDOM, _scrollContainerDOM) => {
    return {
      getBoundingClientRect: () => {
        let state = view.state;
        const markPos = getActiveMarkPos(state);
        const startPos = markPos.start > -1 ? markPos.start + 1 : 0;
        const start = view.coordsAtPos(startPos);
        const end = view.coordsAtPos(markPos.end > -1 ? markPos.end : startPos);
        let { left, right } = start;
        let { top, bottom } = end;
        const x = left;
        const y = top;
        const width = right - left;
        const height = bottom - top;
        return new DOMRect(x, y, width, height);
      }
    };
  };
}
function tooltipController({ key, trigger, markName }) {
  return new Plugin({
    view() {
      return {
        update: (view, lastState) => {
          const { state } = view;
          if (lastState === state || !state.selection.empty) {
            return;
          }
          const markType = state.schema.marks[markName];
          assertNotUndefined(markType, `markType ${markName} not found`);
          if (lastState.doc.eq(state.doc) && state.selection.eq(lastState && lastState.selection) && // This is a shorthand for checking if the stored mark  of `markType`
          // has changed within the last step. If it has we need to update the state
          isStoredMark(state, markType) === isStoredMark(lastState, markType)) {
            return;
          }
          const isMarkActive = isSuggestMarkActive(markName)(state);
          if (isMarkActive && !doesQueryHaveTrigger(state, markType, trigger)) {
            removeSuggestMark(key)(state, view.dispatch, view);
            return;
          }
          if (!isMarkActive) {
            if (key.getState(state).show === true) {
              hideSuggestionsTooltip(key)(view.state, view.dispatch, view);
            }
            return;
          }
          renderSuggestionsTooltip(key)(view.state, view.dispatch, view);
          return;
        }
      };
    }
  });
}
function isStoredMark(state, markType) {
  return state && state.storedMarks && markType.isInSet(state.storedMarks);
}
function isSuggestMarkActive(markName) {
  return (state) => {
    const { from, to } = state.selection;
    const markType = state.schema.marks[markName];
    assertNotUndefined(markType, `markType ${markName} not found`);
    return state.doc.rangeHasMark(from - 1, to, markType);
  };
}
function doesQueryHaveTrigger(state, markType, trigger) {
  const { nodeBefore } = state.selection.$from;
  if (!nodeBefore) {
    return false;
  }
  const suggestMark = markType.isInSet(nodeBefore.marks || []);
  if (!suggestMark) {
    return false;
  }
  const textContent = nodeBefore.textContent || "";
  return textContent.includes(trigger);
}
function renderSuggestionsTooltip(key) {
  return (state, dispatch, _view) => {
    if (dispatch) {
      dispatch(state.tr.setMeta(key, { type: "RENDER_TOOLTIP" }).setMeta("addToHistory", false));
    }
    return true;
  };
}
function hideSuggestionsTooltip(key) {
  return (state, dispatch, _view) => {
    if (dispatch) {
      dispatch(state.tr.setMeta(key, { type: "HIDE_TOOLTIP" }).setMeta("addToHistory", false));
    }
    return true;
  };
}
function getTriggerText(state, markName, trigger) {
  const markType = state.schema.marks[markName];
  assertNotUndefined(markType, `markType ${markName} not found`);
  const { nodeBefore } = state.selection.$from;
  if (!nodeBefore) {
    return "";
  }
  const suggestMark = markType.isInSet(nodeBefore.marks || []);
  if (!suggestMark) {
    return "";
  }
  const textContent = nodeBefore.textContent || "";
  return textContent.replace(/^([^\x00-\xFF]|[\s\n])+/g, "").replace(trigger, "");
}
function queryTriggerText(key) {
  return (state) => {
    const { trigger, markName } = key.getState(state);
    return getTriggerText(state, markName, trigger);
  };
}
function queryIsSuggestTooltipActive(key) {
  return (state) => {
    return key.getState(state) && key.getState(state).show;
  };
}
function replaceSuggestMarkWith(key, maybeNode) {
  return (state, dispatch, view) => {
    const { markName } = key.getState(state);
    const { schema } = state;
    const markType = schema.marks[markName];
    assertNotUndefined(markType, `markType ${markName} not found`);
    const { selection } = state;
    const queryMark = findFirstMarkPosition(markType, state.doc, selection.from - 1, selection.to);
    if (!queryMark || queryMark.start === -1) {
      return false;
    }
    const getTr = () => {
      const { start, end } = queryMark;
      let tr2 = state.tr.removeStoredMark(markType).replaceWith(start, end, Fragment.empty);
      if (!maybeNode) {
        return tr2;
      }
      const isInputFragment = maybeNode instanceof Fragment;
      let node;
      try {
        node = maybeNode instanceof Node || isInputFragment ? maybeNode : typeof maybeNode === "string" ? state.schema.text(maybeNode) : Node.fromJSON(state.schema, maybeNode);
      } catch (e) {
        console.error(e);
        return tr2;
      }
      if (node.isText) {
        tr2 = tr2.replaceWith(start, start, node);
      } else if (node.isBlock) {
        tr2 = safeInsert(node)(tr2);
      } else if (node.isInline || isInputFragment) {
        const fragment = isInputFragment ? node : Fragment.fromArray([node, state.schema.text(" ")]);
        tr2 = tr2.replaceWith(start, start, fragment);
        if (isChromeWithSelectionBug) {
          const selection2 = document.getSelection();
          if (selection2) {
            selection2.empty();
          }
        }
        tr2 = tr2.setSelection(Selection.near(tr2.doc.resolve(start + fragment.size)));
        return tr2;
      }
      return tr2;
    };
    const tr = getTr();
    if (dispatch) {
      view === null || view === void 0 ? void 0 : view.focus();
      dispatch(tr);
    }
    return true;
  };
}
function removeSuggestMark(key) {
  return (state, dispatch, _view) => {
    const { markName } = key.getState(state);
    const { schema, selection } = state;
    const markType = schema.marks[markName];
    assertNotUndefined(markType, `markType ${markName} not found`);
    const queryMark = findFirstMarkPosition(markType, state.doc, selection.from - 1, selection.to);
    const { start, end } = queryMark;
    if (start === -1 && state.storedMarks && markType.isInSet(state.storedMarks)) {
      if (dispatch) {
        dispatch(state.tr.removeStoredMark(markType));
      }
      return true;
    }
    if (start === -1) {
      return false;
    }
    if (dispatch) {
      dispatch(state.tr.removeMark(start, end, markType).removeStoredMark(markType).setMeta("addToHistory", false));
    }
    return true;
  };
}
function incrementSuggestTooltipCounter(key) {
  return (state, dispatch, _view) => {
    if (dispatch) {
      dispatch(state.tr.setMeta(key, { type: "INCREMENT_COUNTER" }).setMeta("addToHistory", false));
    }
    return true;
  };
}
function decrementSuggestTooltipCounter(key) {
  return (state, dispatch, _view) => {
    if (dispatch) {
      dispatch(state.tr.setMeta(key, { type: "DECREMENT_COUNTER" }).setMeta("addToHistory", false));
    }
    return true;
  };
}
function resetSuggestTooltipCounter(key) {
  return (state, dispatch, _view) => {
    if (dispatch) {
      dispatch(state.tr.setMeta(key, { type: "RESET_COUNTER" }).setMeta("addToHistory", false));
    }
    return true;
  };
}
function updateSuggestTooltipCounter(key, counter) {
  return (state, dispatch, _view) => {
    if (dispatch) {
      dispatch(state.tr.setMeta(key, { type: "UPDATE_COUNTER", value: counter }).setMeta("addToHistory", false));
    }
    return true;
  };
}
var suggestTooltip = Object.freeze({
  __proto__: null,
  spec,
  plugins,
  commands,
  defaultKeys,
  queryTriggerText,
  queryIsSuggestTooltipActive,
  replaceSuggestMarkWith,
  removeSuggestMark,
  incrementSuggestTooltipCounter,
  decrementSuggestTooltipCounter,
  resetSuggestTooltipCounter,
  updateSuggestTooltipCounter
});

export {
  createTooltipDOM,
  tooltipPlacement$1,
  selectionTooltip$1,
  suggestTooltip
};
//# sourceMappingURL=chunk-S2ZCVA2Z.js.map
