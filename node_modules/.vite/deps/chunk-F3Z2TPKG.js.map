{
  "version": 3,
  "sources": ["../../../.yarn/__virtual__/prosemirror-utils-bangle-virtual-4dbba9a319/5/Users/ted/.yarn/berry/cache/prosemirror-utils-bangle-npm-0.0.4-afcf52a725-10c0.zip/node_modules/prosemirror-utils-bangle/src/transforms.js", "../../../.yarn/__virtual__/prosemirror-utils-bangle-virtual-4dbba9a319/5/Users/ted/.yarn/berry/cache/prosemirror-utils-bangle-npm-0.0.4-afcf52a725-10c0.zip/node_modules/prosemirror-utils-bangle/src/helpers.js", "../../../.yarn/__virtual__/prosemirror-utils-bangle-virtual-4dbba9a319/5/Users/ted/.yarn/berry/cache/prosemirror-utils-bangle-npm-0.0.4-afcf52a725-10c0.zip/node_modules/prosemirror-utils-bangle/src/selection.js", "../../../.yarn/__virtual__/prosemirror-utils-bangle-virtual-4dbba9a319/5/Users/ted/.yarn/berry/cache/prosemirror-utils-bangle-npm-0.0.4-afcf52a725-10c0.zip/node_modules/prosemirror-utils-bangle/src/node.js", "../../../.yarn/__virtual__/@bangle.dev-utils-virtual-72745470c3/5/Users/ted/.yarn/berry/cache/@bangle.dev-utils-npm-0.32.0-ea437e90b3-10c0.zip/node_modules/@bangle.dev/utils/dist/index.js"],
  "sourcesContent": ["import { NodeSelection, Selection } from 'prosemirror-state';\nimport { Fragment } from 'prosemirror-model';\nimport { findParentNodeOfType, findPositionOfNodeBefore } from './selection';\nimport {\n  cloneTr,\n  isNodeSelection,\n  replaceNodeAtPos,\n  removeNodeAtPos,\n  canInsert,\n  isEmptyParagraph\n} from './helpers';\n\n// :: (nodeType: union<NodeType, [NodeType]>) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a node of a given `nodeType`. It will return an original transaction if parent node hasn't been found.\n//\n// ```javascript\n// dispatch(\n//   removeParentNodeOfType(schema.nodes.table)(tr)\n// );\n// ```\nexport const removeParentNodeOfType = nodeType => tr => {\n  const parent = findParentNodeOfType(nodeType)(tr.selection);\n  if (parent) {\n    return removeNodeAtPos(parent.pos)(tr);\n  }\n  return tr;\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>, content: union<ProseMirrorNode, Fragment>) → (tr: Transaction) → Transaction\n// Returns a new transaction that replaces parent node of a given `nodeType` with the given `content`. It will return an original transaction if either parent node hasn't been found or replacing is not possible.\n//\n// ```javascript\n// const node = schema.nodes.paragraph.createChecked({}, schema.text('new'));\n//\n// dispatch(\n//  replaceParentNodeOfType(schema.nodes.table, node)(tr)\n// );\n// ```\nexport const replaceParentNodeOfType = (nodeType, content) => tr => {\n  if (!Array.isArray(nodeType)) {\n    nodeType = [nodeType];\n  }\n  for (let i = 0, count = nodeType.length; i < count; i++) {\n    const parent = findParentNodeOfType(nodeType[i])(tr.selection);\n    if (parent) {\n      const newTr = replaceNodeAtPos(parent.pos, content)(tr);\n      if (newTr !== tr) {\n        return newTr;\n      }\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) → Transaction\n// Returns a new transaction that removes selected node. It will return an original transaction if current selection is not a `NodeSelection`.\n//\n// ```javascript\n// dispatch(\n//   removeSelectedNode(tr)\n// );\n// ```\nexport const removeSelectedNode = tr => {\n  if (isNodeSelection(tr.selection)) {\n    const from = tr.selection.$from.pos;\n    const to = tr.selection.$to.pos;\n    return cloneTr(tr.delete(from, to));\n  }\n  return tr;\n};\n\n// :: (content: union<ProseMirrorNode, ProseMirrorFragment>) → (tr: Transaction) → Transaction\n// Returns a new transaction that replaces selected node with a given `node`, keeping NodeSelection on the new `node`.\n// It will return the original transaction if either current selection is not a NodeSelection or replacing is not possible.\n//\n// ```javascript\n// const node = schema.nodes.paragraph.createChecked({}, schema.text('new'));\n// dispatch(\n//   replaceSelectedNode(node)(tr)\n// );\n// ```\nexport const replaceSelectedNode = content => tr => {\n  if (isNodeSelection(tr.selection)) {\n    const { $from, $to } = tr.selection;\n    if (\n      (content instanceof Fragment &&\n        $from.parent.canReplace($from.index(), $from.indexAfter(), content)) ||\n      $from.parent.canReplaceWith(\n        $from.index(),\n        $from.indexAfter(),\n        content.type\n      )\n    ) {\n      return cloneTr(\n        tr\n          .replaceWith($from.pos, $to.pos, content)\n          // restore node selection\n          .setSelection(new NodeSelection(tr.doc.resolve($from.pos)))\n      );\n    }\n  }\n  return tr;\n};\n\n// :: (position: number, dir: ?number) → (tr: Transaction) → Transaction\n// Returns a new transaction that tries to find a valid cursor selection starting at the given `position`\n// and searching back if `dir` is negative, and forward if positive.\n// If a valid cursor position hasn't been found, it will return the original transaction.\n//\n// ```javascript\n// dispatch(\n//   setTextSelection(5)(tr)\n// );\n// ```\nexport const setTextSelection = (position, dir = 1) => tr => {\n  const nextSelection = Selection.findFrom(tr.doc.resolve(position), dir, true);\n  if (nextSelection) {\n    return tr.setSelection(nextSelection);\n  }\n  return tr;\n};\n\nconst isSelectableNode = node => node.type && node.type.spec.selectable;\nconst shouldSelectNode = node => isSelectableNode(node) && node.type.isLeaf;\n\nconst setSelection = (node, pos, tr) => {\n  if (shouldSelectNode(node)) {\n    return tr.setSelection(new NodeSelection(tr.doc.resolve(pos)));\n  }\n  return setTextSelection(pos)(tr);\n};\n\n// :: (content: union<ProseMirrorNode, Fragment>, position: ?number, tryToReplace?: boolean) → (tr: Transaction) → Transaction\n// Returns a new transaction that inserts a given `content` at the current cursor position, or at a given `position`, if it is allowed by schema. If schema restricts such nesting, it will try to find an appropriate place for a given node in the document, looping through parent nodes up until the root document node.\n// If `tryToReplace` is true and current selection is a NodeSelection, it will replace selected node with inserted content if its allowed by schema.\n// If cursor is inside of an empty paragraph, it will try to replace that paragraph with the given content. If insertion is successful and inserted node has content, it will set cursor inside of that content.\n// It will return an original transaction if the place for insertion hasn't been found.\n//\n// ```javascript\n// const node = schema.nodes.extension.createChecked({});\n// dispatch(\n//   safeInsert(node)(tr)\n// );\n// ```\nexport const safeInsert = (content, position, tryToReplace) => tr => {\n  const hasPosition = typeof position === 'number';\n  const { $from } = tr.selection;\n  const $insertPos = hasPosition\n    ? tr.doc.resolve(position)\n    : isNodeSelection(tr.selection)\n    ? tr.doc.resolve($from.pos + 1)\n    : $from;\n  const { parent } = $insertPos;\n\n  // try to replace selected node\n  if (isNodeSelection(tr.selection) && tryToReplace) {\n    const oldTr = tr;\n    tr = replaceSelectedNode(content)(tr);\n    if (oldTr !== tr) {\n      return tr;\n    }\n  }\n\n  // try to replace an empty paragraph\n  if (isEmptyParagraph(parent)) {\n    const oldTr = tr;\n    tr = replaceParentNodeOfType(parent.type, content)(tr);\n    if (oldTr !== tr) {\n      const pos = isSelectableNode(content)\n        ? // for selectable node, selection position would be the position of the replaced parent\n          $insertPos.before($insertPos.depth)\n        : $insertPos.pos;\n      return setSelection(content, pos, tr);\n    }\n  }\n\n  // given node is allowed at the current cursor position\n  if (canInsert($insertPos, content)) {\n    tr.insert($insertPos.pos, content);\n    const pos = hasPosition\n      ? $insertPos.pos\n      : isSelectableNode(content)\n      ? // for atom nodes selection position after insertion is the previous pos\n        tr.selection.$anchor.pos - 1\n      : tr.selection.$anchor.pos;\n    return cloneTr(setSelection(content, pos, tr));\n  }\n\n  // looking for a place in the doc where the node is allowed\n  for (let i = $insertPos.depth; i > 0; i--) {\n    const pos = $insertPos.after(i);\n    const $pos = tr.doc.resolve(pos);\n    if (canInsert($pos, content)) {\n      tr.insert(pos, content);\n      return cloneTr(setSelection(content, pos, tr));\n    }\n  }\n  return tr;\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>, type: ?union<NodeType, null>, attrs: ?union<Object, null>, marks?: [Mark]) → (tr: Transaction) → Transaction\n// Returns a transaction that changes the type, attributes, and/or marks of the parent node of a given `nodeType`.\n//\n// ```javascript\n// const node = schema.nodes.extension.createChecked({});\n// dispatch(\n//   setParentNodeMarkup(schema.nodes.panel, null, { panelType })(tr);\n// );\n// ```\nexport const setParentNodeMarkup = (nodeType, type, attrs, marks) => tr => {\n  const parent = findParentNodeOfType(nodeType)(tr.selection);\n  if (parent) {\n    return cloneTr(\n      tr.setNodeMarkup(\n        parent.pos,\n        type,\n        Object.assign({}, parent.node.attrs, attrs),\n        marks\n      )\n    );\n  }\n  return tr;\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) → (tr: Transaction) → Transaction\n// Returns a new transaction that sets a `NodeSelection` on a parent node of a `given nodeType`.\n//\n// ```javascript\n// dispatch(\n//   selectParentNodeOfType([tableCell, tableHeader])(state.tr)\n// );\n// ```\nexport const selectParentNodeOfType = nodeType => tr => {\n  if (!isNodeSelection(tr.selection)) {\n    const parent = findParentNodeOfType(nodeType)(tr.selection);\n    if (parent) {\n      return cloneTr(tr.setSelection(NodeSelection.create(tr.doc, parent.pos)));\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) → Transaction\n// Returns a new transaction that deletes previous node.\n//\n// ```javascript\n// dispatch(\n//   removeNodeBefore(state.tr)\n// );\n// ```\nexport const removeNodeBefore = tr => {\n  const position = findPositionOfNodeBefore(tr.selection);\n  if (typeof position === 'number') {\n    return removeNodeAtPos(position)(tr);\n  }\n  return tr;\n};\n", "import { NodeSelection } from 'prosemirror-state';\nimport { Fragment, Node as PMNode } from 'prosemirror-model';\nimport { setTextSelection } from './transforms';\nimport { findParentNodeClosestToPos } from './selection';\n\n// :: (selection: Selection) → boolean\n// Checks if current selection is a `NodeSelection`.\n//\n// ```javascript\n// if (isNodeSelection(tr.selection)) {\n//   // ...\n// }\n// ```\nexport const isNodeSelection = selection => {\n  return selection instanceof NodeSelection;\n};\n\n// (nodeType: union<NodeType, [NodeType]>) → boolean\n// Checks if the type a given `node` equals to a given `nodeType`.\nexport const equalNodeType = (nodeType, node) => {\n  return (\n    (Array.isArray(nodeType) && nodeType.indexOf(node.type) > -1) ||\n    node.type === nodeType\n  );\n};\n\n// (tr: Transaction) → Transaction\n// Creates a new transaction object from a given transaction\nexport const cloneTr = tr => {\n  return Object.assign(Object.create(tr), tr).setTime(Date.now());\n};\n\n// (position: number, content: union<ProseMirrorNode, Fragment>) → (tr: Transaction) → Transaction\n// Returns a `replace` transaction that replaces a node at a given position with the given `content`.\n// It will return the original transaction if replacing is not possible.\n// `position` should point at the position immediately before the node.\nexport const replaceNodeAtPos = (position, content) => tr => {\n  const node = tr.doc.nodeAt(position);\n  const $pos = tr.doc.resolve(position);\n  if (canReplace($pos, content)) {\n    tr = tr.replaceWith(position, position + node.nodeSize, content);\n    const start = tr.selection.$from.pos - 1;\n    // put cursor inside of the inserted node\n    tr = setTextSelection(Math.max(start, 0), -1)(tr);\n    // move cursor to the start of the node\n    tr = setTextSelection(tr.selection.$from.start())(tr);\n    return cloneTr(tr);\n  }\n  return tr;\n};\n\n// ($pos: ResolvedPos, doc: ProseMirrorNode, content: union<ProseMirrorNode, Fragment>, ) → boolean\n// Checks if replacing a node at a given `$pos` inside of the `doc` node with the given `content` is possible.\nexport const canReplace = ($pos, content) => {\n  const node = $pos.node($pos.depth);\n  return (\n    node &&\n    node.type.validContent(\n      content instanceof Fragment ? content : Fragment.from(content)\n    )\n  );\n};\n\n// (position: number) → (tr: Transaction) → Transaction\n// Returns a `delete` transaction that removes a node at a given position with the given `node`.\n// `position` should point at the position immediately before the node.\nexport const removeNodeAtPos = position => tr => {\n  const node = tr.doc.nodeAt(position);\n  return cloneTr(tr.delete(position, position + node.nodeSize));\n};\n\n// :: ($pos: ResolvedPos, content: union<ProseMirrorNode, Fragment>) → boolean\n// Checks if a given `content` can be inserted at the given `$pos`\n//\n// ```javascript\n// const { selection: { $from } } = state;\n// const node = state.schema.nodes.atom.createChecked();\n// if (canInsert($from, node)) {\n//   // ...\n// }\n// ```\nexport const canInsert = ($pos, content) => {\n  const index = $pos.index();\n\n  if (content instanceof Fragment) {\n    return $pos.parent.canReplace(index, index, content);\n  } else if (content instanceof PMNode) {\n    return $pos.parent.canReplaceWith(index, index, content.type);\n  }\n  return false;\n};\n\n// (node: ProseMirrorNode) → boolean\n// Checks if a given `node` is an empty paragraph\nexport const isEmptyParagraph = node => {\n  return !node || (node.type.name === 'paragraph' && node.nodeSize === 2);\n};\n\nexport const checkInvalidMovements = (\n  originIndex,\n  targetIndex,\n  targets,\n  type\n) => {\n  const direction = originIndex > targetIndex ? -1 : 1;\n  const errorMessage = `Target position is invalid, you can't move the ${type} ${originIndex} to ${targetIndex}, the target can't be split. You could use tryToFit option.`;\n\n  if (direction === 1) {\n    if (targets.slice(0, targets.length - 1).indexOf(targetIndex) !== -1) {\n      throw new Error(errorMessage);\n    }\n  } else {\n    if (targets.slice(1).indexOf(targetIndex) !== -1) {\n      throw new Error(errorMessage);\n    }\n  }\n\n  return true;\n};\n", "import { Selection } from 'prosemirror-state';\nimport { equalNodeType, isNodeSelection } from './helpers';\n\n// :: (predicate: (node: ProseMirrorNode) → boolean) → (selection: Selection) → ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning the closest node and its start position `predicate` returns truthy for. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const predicate = node => node.type === schema.nodes.blockquote;\n// const parent = findParentNode(predicate)(selection);\n// ```\nexport const findParentNode = predicate => ({ $from }) =>\n  findParentNodeClosestToPos($from, predicate);\n\n// :: ($pos: ResolvedPos, predicate: (node: ProseMirrorNode) → boolean) → ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes starting from the given `$pos`, returning the closest node and its start position `predicate` returns truthy for. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const predicate = node => node.type === schema.nodes.blockquote;\n// const parent = findParentNodeClosestToPos(state.doc.resolve(5), predicate);\n// ```\nexport const findParentNodeClosestToPos = ($pos, predicate) => {\n  for (let i = $pos.depth; i > 0; i--) {\n    const node = $pos.node(i);\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n};\n\n// :: (predicate: (node: ProseMirrorNode) → boolean, domAtPos: (pos: number) → {node: dom.Node, offset: number}) → (selection: Selection) → ?dom.Node\n// Iterates over parent nodes, returning DOM reference of the closest node `predicate` returns truthy for.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const predicate = node => node.type === schema.nodes.table;\n// const parent = findParentDomRef(predicate, domAtPos)(selection); // <table>\n// ```\nexport const findParentDomRef = (predicate, domAtPos) => selection => {\n  const parent = findParentNode(predicate)(selection);\n  if (parent) {\n    return findDomRefAtPos(parent.pos, domAtPos);\n  }\n};\n\n// :: (predicate: (node: ProseMirrorNode) → boolean) → (selection: Selection) → boolean\n// Checks if there's a parent node `predicate` returns truthy for.\n//\n// ```javascript\n// if (hasParentNode(node => node.type === schema.nodes.table)(selection)) {\n//   // ....\n// }\n// ```\nexport const hasParentNode = predicate => selection => {\n  return !!findParentNode(predicate)(selection);\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) → (selection: Selection) → ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning closest node of a given `nodeType`. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const parent = findParentNodeOfType(schema.nodes.paragraph)(selection);\n// ```\nexport const findParentNodeOfType = nodeType => selection => {\n  return findParentNode(node => equalNodeType(nodeType, node))(selection);\n};\n\n// :: ($pos: ResolvedPos, nodeType: union<NodeType, [NodeType]>) → ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes starting from the given `$pos`, returning closest node of a given `nodeType`. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const parent = findParentNodeOfTypeClosestToPos(state.doc.resolve(10), schema.nodes.paragraph);\n// ```\nexport const findParentNodeOfTypeClosestToPos = ($pos, nodeType) => {\n  return findParentNodeClosestToPos($pos, node =>\n    equalNodeType(nodeType, node)\n  );\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) → (selection: Selection) → boolean\n// Checks if there's a parent node of a given `nodeType`.\n//\n// ```javascript\n// if (hasParentNodeOfType(schema.nodes.table)(selection)) {\n//   // ....\n// }\n// ```\nexport const hasParentNodeOfType = nodeType => selection => {\n  return hasParentNode(node => equalNodeType(nodeType, node))(selection);\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>, domAtPos: (pos: number) → {node: dom.Node, offset: number}) → (selection: Selection) → ?dom.Node\n// Iterates over parent nodes, returning DOM reference of the closest node of a given `nodeType`.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const parent = findParentDomRefOfType(schema.nodes.codeBlock, domAtPos)(selection); // <pre>\n// ```\nexport const findParentDomRefOfType = (nodeType, domAtPos) => selection => {\n  return findParentDomRef(node => equalNodeType(nodeType, node), domAtPos)(\n    selection\n  );\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) → (selection: Selection) → ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Returns a node of a given `nodeType` if it is selected. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const { extension, inlineExtension, bodiedExtension } = schema.nodes;\n// const selectedNode = findSelectedNodeOfType([\n//   extension,\n//   inlineExtension,\n//   bodiedExtension,\n// ])(selection);\n// ```\nexport const findSelectedNodeOfType = nodeType => selection => {\n  if (isNodeSelection(selection)) {\n    const { node, $from } = selection;\n    if (equalNodeType(nodeType, node)) {\n      return { node, pos: $from.pos, depth: $from.depth };\n    }\n  }\n};\n\n// :: (selection: Selection) → ?number\n// Returns position of the previous node.\n//\n// ```javascript\n// const pos = findPositionOfNodeBefore(tr.selection);\n// ```\nexport const findPositionOfNodeBefore = selection => {\n  const { nodeBefore } = selection.$from;\n  const maybeSelection = Selection.findFrom(selection.$from, -1);\n  if (maybeSelection && nodeBefore) {\n    // leaf node\n    const parent = findParentNodeOfType(nodeBefore.type)(maybeSelection);\n    if (parent) {\n      return parent.pos;\n    }\n    return maybeSelection.$from.pos;\n  }\n};\n\n// :: (position: number, domAtPos: (pos: number) → {node: dom.Node, offset: number}) → dom.Node\n// Returns DOM reference of a node at a given `position`. If the node type is of type `TEXT_NODE` it will return the reference of the parent node.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const ref = findDomRefAtPos($from.pos, domAtPos);\n// ```\nexport const findDomRefAtPos = (position, domAtPos) => {\n  const dom = domAtPos(position);\n  const node = dom.node.childNodes[dom.offset];\n\n  if (dom.node.nodeType === Node.TEXT_NODE) {\n    return dom.node.parentNode;\n  }\n\n  if (!node || node.nodeType === Node.TEXT_NODE) {\n    return dom.node;\n  }\n\n  return node;\n};\n", "// :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Flattens descendants of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const children = flatten(node);\n// ```\nexport const flatten = (node, descend = true) => {\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  }\n  const result = [];\n  node.descendants((child, pos) => {\n    result.push({ node: child, pos });\n    if (!descend) {\n      return false;\n    }\n  });\n  return result;\n};\n\n// :: (node: ProseMirrorNode, predicate: (node: ProseMirrorNode) → boolean, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes predicate returns truthy for. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const textNodes = findChildren(node, child => child.isText, false);\n// ```\nexport const findChildren = (node, predicate, descend) => {\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  } else if (!predicate) {\n    throw new Error('Invalid \"predicate\" parameter');\n  }\n  return flatten(node, descend).filter(child => predicate(child.node));\n};\n\n// :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Returns text nodes of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const textNodes = findTextNodes(node);\n// ```\nexport const findTextNodes = (node, descend) => {\n  return findChildren(node, child => child.isText, descend);\n};\n\n// :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Returns inline nodes of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const inlineNodes = findInlineNodes(node);\n// ```\nexport const findInlineNodes = (node, descend) => {\n  return findChildren(node, child => child.isInline, descend);\n};\n\n// :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Returns block descendants of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const blockNodes = findBlockNodes(node);\n// ```\nexport const findBlockNodes = (node, descend) => {\n  return findChildren(node, child => child.isBlock, descend);\n};\n\n// :: (node: ProseMirrorNode, predicate: (attrs: ?Object) → boolean, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes predicate returns truthy for. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const mergedCells = findChildrenByAttr(table, attrs => attrs.colspan === 2);\n// ```\nexport const findChildrenByAttr = (node, predicate, descend) => {\n  return findChildren(node, child => !!predicate(child.attrs), descend);\n};\n\n// :: (node: ProseMirrorNode, nodeType: NodeType, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes of a given nodeType. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const cells = findChildrenByType(table, schema.nodes.tableCell);\n// ```\nexport const findChildrenByType = (node, nodeType, descend) => {\n  return findChildren(node, child => child.type === nodeType, descend);\n};\n\n// :: (node: ProseMirrorNode, markType: markType, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes that have a mark of a given markType. It doesn't descend into a `node` when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const nodes = findChildrenByMark(state.doc, schema.marks.strong);\n// ```\nexport const findChildrenByMark = (node, markType, descend) => {\n  return findChildren(node, child => markType.isInSet(child.marks), descend);\n};\n\n// :: (node: ProseMirrorNode, nodeType: NodeType) → boolean\n// Returns `true` if a given node contains nodes of a given `nodeType`\n//\n// ```javascript\n// if (contains(panel, schema.nodes.listItem)) {\n//   // ...\n// }\n// ```\nexport const contains = (node, nodeType) => {\n  return !!findChildrenByType(node, nodeType).length;\n};\n", "import { DOMSerializer, InputRule, Plugin, Slice, Fragment, Selection, EditorState } from '@bangle.dev/pm';\nimport { findSelectedNodeOfType, findParentNode, safeInsert } from 'prosemirror-utils-bangle';\nexport { canInsert, contains, findBlockNodes, findChildren, findChildrenByAttr, findChildrenByMark, findChildrenByType, findDomRefAtPos, findInlineNodes, findParentDomRef, findParentDomRefOfType, findParentNode, findParentNodeClosestToPos, findParentNodeOfType, findParentNodeOfTypeClosestToPos, findPositionOfNodeBefore, findSelectedNodeOfType, findTextNodes, flatten, hasParentNode, hasParentNodeOfType, isNodeSelection, removeNodeBefore, removeParentNodeOfType, removeSelectedNode, replaceParentNodeOfType, replaceSelectedNode, safeInsert, selectParentNodeOfType, setParentNodeMarkup, setTextSelection } from 'prosemirror-utils-bangle';\n\nconst browser = {\n    mac: false,\n    ie: false,\n    ie_version: 0,\n    gecko: false,\n    chrome: false,\n    chrome_version: 0,\n    android: false,\n    ios: false,\n    webkit: false,\n};\nif (typeof navigator !== 'undefined' && typeof document !== 'undefined') {\n    const ieEdge = /Edge\\/(\\d+)/.exec(navigator.userAgent);\n    const ieUpTo10 = /MSIE \\d/.test(navigator.userAgent);\n    const ie11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\n    browser.mac = /Mac/.test(navigator.platform);\n    let ie = (browser.ie = !!(ieUpTo10 || ie11up || ieEdge));\n    browser.ie_version = ieUpTo10\n        ? // @ts-ignore TS doesn't understand browser quirks\n            document.documentMode || 6\n        : ie11up\n            ? +ie11up[1]\n            : ieEdge\n                ? +ieEdge[1]\n                : null;\n    browser.gecko = !ie && /gecko\\/\\d/i.test(navigator.userAgent);\n    browser.chrome = !ie && /Chrome\\//.test(navigator.userAgent);\n    browser.chrome_version = parseInt((navigator.userAgent.match(/Chrome\\/(\\d{2})/) || [])[1] || '0', 10);\n    browser.android = /Android \\d/.test(navigator.userAgent);\n    browser.ios =\n        !ie &&\n            /AppleWebKit/.test(navigator.userAgent) &&\n            /Mobile\\/\\w+/.test(navigator.userAgent);\n    browser.webkit =\n        !ie &&\n            !!document.documentElement &&\n            'WebkitAppearance' in document.documentElement.style;\n}\nconst isChromeWithSelectionBug = browser.chrome && !browser.android && browser.chrome_version >= 58;\n\n// Copied from https://github.com/sindresorhus/mimic-fn/blob/main/index.js\n// due to issues with their ESM bundling\nconst copyProperty = (to, from, property, ignoreNonConfigurable) => {\n    // `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n    // `Function#prototype` is non-writable and non-configurable so can never be modified.\n    if (property === 'length' || property === 'prototype') {\n        return;\n    }\n    // `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n    if (property === 'arguments' || property === 'caller') {\n        return;\n    }\n    const toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n    const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n    if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n        return;\n    }\n    Object.defineProperty(to, property, fromDescriptor);\n};\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n// - one its descriptors is changed\n// - it is non-writable and its value is changed\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n    return (toDescriptor === undefined ||\n        toDescriptor.configurable ||\n        (toDescriptor.writable === fromDescriptor.writable &&\n            toDescriptor.enumerable === fromDescriptor.enumerable &&\n            toDescriptor.configurable === fromDescriptor.configurable &&\n            (toDescriptor.writable || toDescriptor.value === fromDescriptor.value)));\n};\nconst changePrototype = (to, from) => {\n    const fromPrototype = Object.getPrototypeOf(from);\n    if (fromPrototype === Object.getPrototypeOf(to)) {\n        return;\n    }\n    Object.setPrototypeOf(to, fromPrototype);\n};\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nconst changeToString = (to, from, name) => {\n    const withName = name === '' ? '' : `with ${name.trim()}() `;\n    const newToString = wrappedToString.bind(null, withName, from.toString());\n    // Ensure `to.toString.toString` is non-enumerable and has the same `same`\n    Object.defineProperty(newToString, 'name', toStringName);\n    Object.defineProperty(to, 'toString', {\n        ...toStringDescriptor,\n        value: newToString,\n    });\n};\nfunction mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {\n    const { name } = to;\n    for (const property of Reflect.ownKeys(from)) {\n        copyProperty(to, from, property, ignoreNonConfigurable);\n    }\n    changePrototype(to, from);\n    changeToString(to, from, name);\n    return to;\n}\n\n// copied from https://github.com/sindresorhus/debounce-fn\nfunction debounceFn(inputFunction, options = {}) {\n    if (typeof inputFunction !== 'function') {\n        throw new TypeError(`Expected the first argument to be a function, got \\`${typeof inputFunction}\\``);\n    }\n    const { wait = 0, maxWait = Number.POSITIVE_INFINITY, before = false, after = true, } = options;\n    if (!before && !after) {\n        throw new Error(\"Both `before` and `after` are false, function wouldn't be called.\");\n    }\n    let timeout;\n    let maxTimeout;\n    let result;\n    const debouncedFunction = function (...arguments_) {\n        const context = this;\n        const later = () => {\n            timeout = undefined;\n            if (maxTimeout) {\n                clearTimeout(maxTimeout);\n                maxTimeout = undefined;\n            }\n            if (after) {\n                result = inputFunction.apply(context, arguments_);\n            }\n        };\n        const maxLater = () => {\n            maxTimeout = undefined;\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = undefined;\n            }\n            if (after) {\n                result = inputFunction.apply(context, arguments_);\n            }\n        };\n        const shouldCallNow = before && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (maxWait > 0 && maxWait !== Number.POSITIVE_INFINITY && !maxTimeout) {\n            maxTimeout = setTimeout(maxLater, maxWait);\n        }\n        if (shouldCallNow) {\n            result = inputFunction.apply(context, arguments_);\n        }\n        return result;\n    };\n    mimicFunction(debouncedFunction, inputFunction);\n    debouncedFunction.cancel = () => {\n        if (timeout) {\n            clearTimeout(timeout);\n            timeout = undefined;\n        }\n        if (maxTimeout) {\n            clearTimeout(maxTimeout);\n            maxTimeout = undefined;\n        }\n    };\n    return debouncedFunction;\n}\n\nlet nodeEnv = undefined;\n// Done this way to allow for bundlers\n// to do a string replace.\ntry {\n    // @ts-ignore process is undefined unless we pull in @types/node\n    // eslint-disable-next-line no-process-env\n    nodeEnv = process.env.NODE_ENV;\n}\ncatch (err) { }\nconst APP_ENV = nodeEnv;\nconst isProdEnv = nodeEnv === 'production';\nconst isTestEnv = nodeEnv === 'test';\n\nfunction assertNotUndefined(value, message) {\n    if (value === undefined) {\n        throw new Error(`assertion failed: ${message}`);\n    }\n}\n/**\n * @param {Function} fn - A unary function whose paramater is non-primitive,\n *                        so that it can be cached using WeakMap\n */\nfunction weakCache(fn) {\n    const cache = new WeakMap();\n    return (arg) => {\n        let value = cache.get(arg);\n        if (value) {\n            return value;\n        }\n        value = fn(arg);\n        cache.set(arg, value);\n        return value;\n    };\n}\n// simple higher order compose\nfunction compose(func, ...funcs) {\n    const allFuncs = [func, ...funcs];\n    return function composed(raw) {\n        return allFuncs.reduceRight((prev, func) => func(prev), raw);\n    };\n}\nclass MatchType {\n    constructor(start, end, match, _sourceString) {\n        this.start = start;\n        this.end = end;\n        this.match = match;\n        this._sourceString = _sourceString;\n    }\n    get subString() {\n        return this._sourceString.slice(this.start, this.end);\n    }\n}\n/**\n *\n * Returns an array of objects which contains a range of substring and whether it matched or didn't match.\n * Note: each item in this array will map 1:1 in order with the original string in a way\n *  such that following will always hold true:\n * ```\n * const result = matchAllPlus(regex, myStr);\n * result.reduce((a, b) => a + b.subString) === myStr\n * result.reduce((a, b) => a + b.slice(b.start, b.end)) === myStr\n * ```\n */\nfunction matchAllPlus(regexp, str) {\n    const result = [];\n    let prevElementEnd = 0;\n    let match;\n    while ((match = regexp.exec(str))) {\n        const curStart = match.index;\n        const curEnd = curStart + match[0].length;\n        if (prevElementEnd !== curStart) {\n            result.push(new MatchType(prevElementEnd, curStart, false, str));\n        }\n        result.push(new MatchType(curStart, curEnd, true, str));\n        prevElementEnd = curEnd;\n    }\n    if (result.length === 0) {\n        return [new MatchType(0, str.length, false, str)];\n    }\n    const lastItemEnd = result[result.length - 1] && result[result.length - 1].end;\n    if (lastItemEnd && lastItemEnd !== str.length) {\n        result.push(new MatchType(lastItemEnd, str.length, false, str));\n    }\n    return result;\n}\nfunction uuid(len = 10) {\n    return Math.random().toString(36).substring(2, 15).slice(0, len);\n}\nfunction abortableSetTimeout(callback, signal, ms) {\n    const timer = setTimeout(callback, ms);\n    signal.addEventListener('abort', () => {\n        clearTimeout(timer);\n    }, { once: true });\n}\nfunction getIdleCallback(cb) {\n    if (typeof window !== 'undefined' && window.requestIdleCallback) {\n        return window.requestIdleCallback(cb);\n    }\n    var t = Date.now();\n    return setTimeout(function () {\n        cb({\n            didTimeout: !1,\n            timeRemaining: function () {\n                return Math.max(0, 50 - (Date.now() - t));\n            },\n        });\n    }, 1);\n}\nfunction cancelablePromise(promise) {\n    let hasCanceled = false;\n    const wrappedPromise = new Promise((resolve, reject) => promise\n        .then((val) => hasCanceled ? reject({ isCanceled: true }) : resolve(val))\n        .catch((error) => hasCanceled ? reject({ isCanceled: true }) : reject(error)));\n    return {\n        promise: wrappedPromise,\n        cancel() {\n            hasCanceled = true;\n        },\n    };\n}\nfunction sleep(t = 20) {\n    return new Promise((res) => setTimeout(res, t));\n}\nfunction objectMapValues(obj, map) {\n    return Object.fromEntries(Object.entries(obj).map(([key, value]) => {\n        return [key, map(value, key)];\n    }));\n}\nfunction objectFilter(obj, cb) {\n    return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n        return cb(value, key);\n    }));\n}\n/**\n * Creates an object from an array of [key, Value], filtering out any\n * undefined or null key\n */\nfunction createObject(entries) {\n    return Object.fromEntries(entries.filter((e) => e[0] != null));\n}\nfunction serialExecuteQueue() {\n    let prev = Promise.resolve();\n    return {\n        add(cb) {\n            return new Promise((resolve, reject) => {\n                const run = async () => {\n                    try {\n                        const result = await cb();\n                        return {\n                            rejected: false,\n                            value: result,\n                        };\n                    }\n                    catch (e) {\n                        return {\n                            rejected: true,\n                            value: e,\n                        };\n                    }\n                };\n                prev = prev.then(() => {\n                    return run().then(({ value, rejected }) => {\n                        if (rejected) {\n                            reject(value);\n                        }\n                        else {\n                            resolve(value);\n                        }\n                    });\n                });\n            });\n        },\n    };\n}\nfunction simpleLRU(size) {\n    let array = [];\n    let removeItems = () => {\n        while (array.length > size) {\n            array.shift();\n        }\n    };\n    return {\n        entries() {\n            return array.slice(0);\n        },\n        remove(key) {\n            array = array.filter((item) => item.key !== key);\n        },\n        clear() {\n            array = [];\n        },\n        get(key) {\n            let result = array.find((item) => item.key === key);\n            if (result) {\n                this.set(key, result.value); // put the item in the front\n                return result.value;\n            }\n            return undefined;\n        },\n        set(key, value) {\n            this.remove(key);\n            array.push({ key, value });\n            removeItems();\n        },\n    };\n}\nfunction domEventListener(element, type, listener, options) {\n    element.addEventListener(type, listener, options);\n    return () => {\n        element.removeEventListener(type, listener, options);\n    };\n}\n/**\n * Based on idea from https://github.com/alexreardon/raf-schd\n * Throttles the function and calls it with the latest argument\n */\nfunction rafSchedule(fn) {\n    let lastArgs = [];\n    let frameId = null;\n    const wrapperFn = (...args) => {\n        // Always capture the latest value\n        lastArgs = args;\n        // There is already a frame queued\n        if (frameId) {\n            return;\n        }\n        // Schedule a new frame\n        frameId = requestAnimationFrame(() => {\n            frameId = null;\n            fn(...lastArgs);\n        });\n    };\n    // Adding cancel property to result function\n    wrapperFn.cancel = () => {\n        if (!frameId) {\n            return;\n        }\n        cancelAnimationFrame(frameId);\n        frameId = null;\n    };\n    return wrapperFn;\n}\nconst bangleWarn = isTestEnv || isProdEnv\n    ? () => { }\n    : console.warn.bind(console, 'Warning in bangle.js:');\n\n/**\n * Creates a bare bone `toDOM` and `parseDOM` handlers for the PM schema.\n * The use case is for nodes or marks who already have a nodeView\n * and want to get basic `toDOM`, `parseDOM` to enable drag n drop or\n * copy paste.\n *\n * @param {*} spec\n * @param {Object} opts\n * @param {string} opts.tag\n * @param {string|0|(node)=>string} opts.content - `0` signals content that PM will inject.\n * @param {string} opts.ignoreAttrs\n * @param {Number} opts.parsingPriority https://prosemirror.net/docs/ref/#model.ParseRule.priority\n */\nfunction domSerializationHelpers(name, { tag = 'div', content, ignoreAttrs = [], parsingPriority = 51, } = {}) {\n    const serializer = (node) => JSON.stringify(objectFilter(node.attrs || {}, (_value, key) => !ignoreAttrs.includes(key)));\n    return {\n        toDOM: (node) => {\n            const domSpec = [\n                tag,\n                {\n                    'data-bangle-name': name,\n                    'data-bangle-attrs': serializer(node),\n                },\n            ];\n            if (content !== undefined) {\n                if (typeof content === 'function') {\n                    domSpec.push(content(node));\n                }\n                else {\n                    domSpec.push(content);\n                }\n            }\n            return domSpec;\n        },\n        parseDOM: [\n            {\n                priority: parsingPriority,\n                tag: `${tag}[data-bangle-name=\"${name}\"]`,\n                getAttrs: (dom) => {\n                    const attrs = dom.getAttribute('data-bangle-attrs');\n                    if (!attrs) {\n                        return {};\n                    }\n                    return JSON.parse(attrs);\n                },\n            },\n        ],\n    };\n}\nfunction createElement(spec) {\n    const { dom, contentDOM } = DOMSerializer.renderSpec(window.document, spec);\n    if (contentDOM) {\n        throw new Error('createElement does not support creating contentDOM');\n    }\n    return dom;\n}\n\n// export enum MaybeType {\n//   Just = 'just',\n//   Nothing = 'nothing',\n// }\n// Note type of left cannot change to keep things simple.\nclass Either {\n    static flatMap(either, rightFn) {\n        if (Either.isLeft(either)) {\n            return Either.left(either.left);\n        }\n        else if (Either.isRight(either)) {\n            return rightFn(either.right, { left: Either.left });\n        }\n        throw new Error('Either.flatMap: unknown type');\n    }\n    static fold(either, \n    // To keep things simple, we don't allow changing the type of left.\n    leftFn, rightFn) {\n        if (Either.isLeft(either)) {\n            return Either.left(leftFn(either.left));\n        }\n        else if (Either.isRight(either)) {\n            return Either.right(rightFn(either.right));\n        }\n        throw new Error('Either.fold: unknown type');\n    }\n    static isLeft(either) {\n        return either.type === 'left';\n    }\n    static isRight(either) {\n        return either.type === 'right';\n    }\n    static left(value) {\n        return { left: value, right: undefined, type: 'left' };\n    }\n    static map(either, rightFn) {\n        return Either.fold(either, (left) => left, rightFn);\n    }\n    static mapLeft(either, leftFn) {\n        return Either.fold(either, leftFn, (right) => right);\n    }\n    static right(value) {\n        return {\n            left: undefined,\n            right: value,\n            type: 'right',\n        };\n    }\n    static unwrap(either) {\n        if (Either.isLeft(either)) {\n            return [either.left, undefined];\n        }\n        else if (Either.isRight(either)) {\n            return [undefined, either.right];\n        }\n        throw new Error('Either.unwrap: unknown type');\n    }\n    static value(either) {\n        if (Either.isLeft(either)) {\n            return either.left;\n        }\n        else if (Either.isRight(either)) {\n            return either.right;\n        }\n        throw new Error('Either.value: unknown type');\n    }\n}\n// declare interface Either<L, R> {\n//   map<R2>(f: (r: R) => R2): Either<L, R2>\n//   leftMap<L2>(f: (l: L) => L2): Either<L2, R>\n//   mapThen<R2>(f: (r: R) => Promise<R2>): Promise<Either<L, R2>>\n//   leftMapThen<L2>(f: (l: L) => Promise<L2>): Promise<Either<L2, R>>\n//   flatMap<R2>(f: (r: R) => Either<L, R2>): Either<L, R2>\n//   leftFlatMap<L2>(f: (l: L) => Either<L2, R>): Either<L2, R>\n//   flatMapThen<R2>(f: (r: R) => Promise<Either<L, R2>>): Promise<Either<L, R2>>\n//   leftFlatMapThen<L2>(\n//   \tf: (l: L) => Promise<Either<L2, R>>): Promise<Either<L2, R>>\n//   rightOrElse(f: (l: L) => R): R\n//   value: L | R\n//   isOk: boolean\n// }\n\nclass Emitter {\n    constructor() {\n        this._callbacks = {};\n        // Remove event listener for given event.\n    }\n    // If fn is not provided, all event listeners for that event will be removed.\n    destroy() {\n        this._callbacks = {};\n    }\n    emit(event, data) {\n        const callbacks = this._callbacks[event];\n        if (callbacks) {\n            callbacks.forEach((callback) => callback(data));\n        }\n        return this;\n    }\n    // If neither is provided, all event listeners will be removed.\n    off(event, fn) {\n        if (!arguments.length) {\n            this._callbacks = {};\n        }\n        else {\n            // event listeners for the given event\n            const callbacks = this._callbacks ? this._callbacks[event] : null;\n            if (callbacks) {\n                if (fn) {\n                    this._callbacks[event] = callbacks.filter((cb) => cb !== fn);\n                }\n                else {\n                    this._callbacks[event] = []; // remove all handlers\n                }\n            }\n        }\n        return this;\n    }\n    // Add an event listener for given event\n    on(event, fn) {\n        // Create namespace for this event\n        if (!this._callbacks[event]) {\n            this._callbacks[event] = [];\n        }\n        this._callbacks[event].push(fn);\n        return this;\n    }\n}\n\nfunction getMarksBetween(start, end, state) {\n    let marks = [];\n    state.doc.nodesBetween(start, end, (node, pos) => {\n        marks = [\n            ...marks,\n            ...node.marks.map((mark) => ({\n                start: pos,\n                end: pos + node.nodeSize,\n                mark,\n            })),\n        ];\n    });\n    return marks;\n}\nfunction markInputRule(regexp, markType) {\n    return new InputRule(regexp, (state, match, start, end) => {\n        const { tr } = state;\n        const m = match.length - 1;\n        let markEnd = end;\n        let markStart = start;\n        const matchMths = match[m];\n        const firstMatch = match[0];\n        const mathOneBeforeM = match[m - 1];\n        if (matchMths != null && firstMatch != null && mathOneBeforeM != null) {\n            const matchStart = start + firstMatch.indexOf(mathOneBeforeM);\n            const matchEnd = matchStart + mathOneBeforeM.length - 1;\n            const textStart = matchStart + mathOneBeforeM.lastIndexOf(matchMths);\n            const textEnd = textStart + matchMths.length;\n            const excludedMarks = getMarksBetween(start, end, state)\n                .filter((item) => {\n                return item.mark.type.excludes(markType);\n            })\n                .filter((item) => item.end > matchStart);\n            if (excludedMarks.length) {\n                return null;\n            }\n            if (textEnd < matchEnd) {\n                tr.delete(textEnd, matchEnd);\n            }\n            if (textStart > matchStart) {\n                tr.delete(matchStart, textStart);\n            }\n            markStart = matchStart;\n            markEnd = markStart + matchMths.length;\n        }\n        tr.addMark(markStart, markEnd, markType.create());\n        tr.removeStoredMark(markType);\n        return tr;\n    });\n}\n\nfunction markPasteRule(regexp, type, getAttrs) {\n    const handler = (fragment, parent) => {\n        const nodes = [];\n        fragment.forEach((child) => {\n            if (child.isText) {\n                const { text, marks } = child;\n                let pos = 0;\n                let match;\n                const isLink = !!marks.filter((x) => x.type.name === 'link')[0];\n                while (!isLink && (match = regexp.exec(text)) !== null) {\n                    if (parent && parent.type.allowsMarkType(type) && match[1]) {\n                        const start = match.index;\n                        const end = start + match[0].length;\n                        const textStart = start + match[0].indexOf(match[1]);\n                        const textEnd = textStart + match[1].length;\n                        const attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n                        // adding text before markdown to nodes\n                        if (start > 0) {\n                            nodes.push(child.cut(pos, start));\n                        }\n                        // adding the markdown part to nodes\n                        nodes.push(child\n                            .cut(textStart, textEnd)\n                            .mark(type.create(attrs).addToSet(child.marks)));\n                        pos = end;\n                    }\n                }\n                // adding rest of text to nodes\n                if (pos < text.length) {\n                    nodes.push(child.cut(pos));\n                }\n            }\n            else {\n                nodes.push(child.copy(handler(child.content, child)));\n            }\n        });\n        return Fragment.fromArray(nodes);\n    };\n    return new Plugin({\n        props: {\n            transformPasted: (slice) => new Slice(handler(slice.content), slice.openStart, slice.openEnd),\n        },\n    });\n}\n\nlet counter = 0;\n// add a unique string to prevent clashes in case multiple objectUid instances exist\n// this can happen for example due to duplicate npm packages due to version or dependency mismatch\nlet unique = Math.random();\nclass ObjectUID extends WeakMap {\n    get(obj) {\n        let uid = super.get(obj);\n        if (uid) {\n            return uid;\n        }\n        uid = (counter++).toString() + '-' + unique;\n        this.set(obj, uid);\n        return uid;\n    }\n}\nconst objectUid = new ObjectUID();\n\nclass GapCursorSelection extends Selection {\n}\nfunction rafCommandExec(view, command) {\n    requestAnimationFrame(() => {\n        command(view.state, view.dispatch, view);\n    });\n}\nfunction filter(predicates, cmd) {\n    return (state, dispatch, view) => {\n        if (cmd == null) {\n            return false;\n        }\n        if (!Array.isArray(predicates)) {\n            predicates = [predicates];\n        }\n        if (predicates.some((pred) => !pred(state, view))) {\n            return false;\n        }\n        return cmd(state, dispatch, view) || false;\n    };\n}\nfunction isMarkActiveInSelection(type) {\n    return (state) => {\n        const { from, $from, to, empty } = state.selection;\n        if (empty) {\n            return Boolean(type.isInSet(state.tr.storedMarks || $from.marks()));\n        }\n        return Boolean(state.doc.rangeHasMark(from, to, type));\n    };\n}\nconst validPos = (pos, doc) => Number.isInteger(pos) && pos >= 0 && pos < doc.content.size;\nconst validListParent = (type, schemaNodes) => {\n    const { bulletList, orderedList } = schemaNodes;\n    return [bulletList, orderedList].includes(type);\n};\n// TODO document this, probably gets the attributes of the mark of the current selection\nfunction getMarkAttrs(editorState, type) {\n    const { from, to } = editorState.selection;\n    let marks = [];\n    editorState.doc.nodesBetween(from, to, (node) => {\n        marks = [...marks, ...node.marks];\n    });\n    const mark = marks.find((markItem) => markItem.type.name === type.name);\n    return mark ? mark.attrs : {};\n}\nfunction nodeIsActive(state, type, attrs = {}) {\n    const predicate = (node) => node.type === type;\n    const node = findSelectedNodeOfType(type)(state.selection) ||\n        findParentNode(predicate)(state.selection);\n    if (!Object.keys(attrs).length || !node) {\n        return !!node;\n    }\n    return node.node.hasMarkup(type, { ...node.node.attrs, ...attrs });\n}\n// export function findChangedNodesFromTransaction(tr: Transaction) {\n//   const nodes: Node[] = [];\n//   const steps = tr.steps || [];\n//   steps.forEach((step) => {\n//     const { to, from, slice } = step;\n//     const size = slice && slice.content ? slice.content.size : 0;\n//     for (let i = from; i <= to + size; i++) {\n//       if (i <= tr.doc.content.size) {\n//         const topLevelNode = tr.doc.resolve(i).node(1);\n//         if (topLevelNode && !nodes.find((n) => n === topLevelNode)) {\n//           nodes.push(topLevelNode);\n//         }\n//       }\n//     }\n//   });\n//   return nodes;\n// }\n/**\n * from atlaskit\n * Returns false if node contains only empty inline nodes and hardBreaks.\n */\nfunction hasVisibleContent(node) {\n    const isInlineNodeHasVisibleContent = (inlineNode) => {\n        return inlineNode.isText\n            ? !!inlineNode.textContent.trim()\n            : inlineNode.type.name !== 'hardBreak';\n    };\n    if (node.isInline) {\n        return isInlineNodeHasVisibleContent(node);\n    }\n    else if (node.isBlock && (node.isLeaf || node.isAtom)) {\n        return true;\n    }\n    else if (!node.childCount) {\n        return false;\n    }\n    for (let index = 0; index < node.childCount; index++) {\n        const child = node.child(index);\n        if (hasVisibleContent(child)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n *  * from atlaskit\n * Checks if a node has any content. Ignores node that only contain empty block nodes.\n */\nfunction isNodeEmpty(node) {\n    if (node && node.textContent) {\n        return false;\n    }\n    if (!node ||\n        !node.childCount ||\n        (node.childCount === 1 && isEmptyParagraph(node.firstChild))) {\n        return true;\n    }\n    const block = [];\n    const nonBlock = [];\n    node.forEach((child) => {\n        child.isInline ? nonBlock.push(child) : block.push(child);\n    });\n    return (!nonBlock.length &&\n        !block.filter((childNode) => (!!childNode.childCount &&\n            !(childNode.childCount === 1 &&\n                isEmptyParagraph(childNode.firstChild))) ||\n            childNode.isAtom).length);\n}\n/**\n * Checks if a node looks like an empty document\n */\nfunction isEmptyDocument(node) {\n    const nodeChild = node.content.firstChild;\n    if (node.childCount !== 1 || !nodeChild) {\n        return false;\n    }\n    return (nodeChild.type.name === 'paragraph' &&\n        !nodeChild.childCount &&\n        nodeChild.nodeSize === 2 &&\n        (!nodeChild.marks || nodeChild.marks.length === 0));\n}\n/*\n * from atlaskit\n * Checks if node is an empty paragraph.\n */\nfunction isEmptyParagraph(node) {\n    return (!node ||\n        (node.type.name === 'paragraph' && !node.textContent && !node.childCount));\n}\n// from atlaskit\n// https://github.com/ProseMirror/prosemirror-commands/blob/master/bangle-play/commands.js#L90\n// Keep going left up the tree, without going across isolating boundaries, until we\n// can go along the tree at that same level\n//\n// You can think of this as, if you could construct each document like we do in the tests,\n// return the position of the first ) backwards from the current selection.\nfunction findCutBefore($pos) {\n    // parent is non-isolating, so we can look across this boundary\n    if (!$pos.parent.type.spec.isolating) {\n        // search up the tree from the pos's *parent*\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            // starting from the inner most node's parent, find out\n            // if we're not its first child\n            if ($pos.index(i) > 0) {\n                return $pos.doc.resolve($pos.before(i + 1));\n            }\n            if ($pos.node(i).type.spec.isolating) {\n                break;\n            }\n        }\n    }\n    return null;\n}\nfunction isRangeOfType(doc, $from, $to, nodeType) {\n    return (getAncestorNodesBetween(doc, $from, $to).filter((node) => node.type !== nodeType).length === 0);\n}\n/**\n * Returns all top-level ancestor-nodes between $from and $to\n */\nfunction getAncestorNodesBetween(doc, $from, $to) {\n    const nodes = [];\n    const maxDepth = findAncestorPosition(doc, $from).depth;\n    let current = doc.resolve($from.start(maxDepth));\n    while (current.pos <= $to.start($to.depth)) {\n        const depth = Math.min(current.depth, maxDepth);\n        const node = current.node(depth);\n        if (node) {\n            nodes.push(node);\n        }\n        if (depth === 0) {\n            break;\n        }\n        let next = doc.resolve(current.after(depth));\n        if (next.start(depth) >= doc.nodeSize - 2) {\n            break;\n        }\n        if (next.depth !== current.depth) {\n            next = doc.resolve(next.pos + 2);\n        }\n        if (next.depth) {\n            current = doc.resolve(next.start(next.depth));\n        }\n        else {\n            current = doc.resolve(next.end(next.depth));\n        }\n    }\n    return nodes;\n}\n/**\n * Traverse the document until an \"ancestor\" is found. Any nestable block can be an ancestor.\n */\nfunction findAncestorPosition(doc, pos) {\n    const nestableBlocks = ['blockquote', 'bulletList', 'orderedList'];\n    if (pos.depth === 1) {\n        return pos;\n    }\n    let node = pos.node(pos.depth);\n    let newPos = pos;\n    while (pos.depth >= 1) {\n        pos = doc.resolve(pos.before(pos.depth));\n        node = pos.node(pos.depth);\n        if (node && nestableBlocks.indexOf(node.type.name) !== -1) {\n            newPos = pos;\n        }\n    }\n    return newPos;\n}\nconst isEmptySelectionAtStart = (state) => {\n    const { empty, $from } = state.selection;\n    return (empty &&\n        ($from.parentOffset === 0 || state.selection instanceof GapCursorSelection));\n};\n/**\n * Removes marks from nodes in the current selection that are not supported\n */\nconst sanitiseSelectionMarksForWrapping = (state, newParentType) => {\n    let tr = null;\n    let { from, to } = state.tr.selection;\n    state.doc.nodesBetween(from, to, (node, pos, parent) => {\n        // If iterate over a node thats out of our defined range\n        // We skip here but continue to iterate over its children.\n        if (node.isText || pos < from || pos > to || !parent) {\n            return true;\n        }\n        node.marks.forEach((mark) => {\n            if (!parent.type.allowsMarkType(mark.type) ||\n                (newParentType && !newParentType.allowsMarkType(mark.type))) {\n                const filteredMarks = node.marks.filter((m) => m.type !== mark.type);\n                const position = pos > 0 ? pos - 1 : 0;\n                let targetNode = state.doc.nodeAt(position);\n                // you cannot set markup for text node\n                if (!targetNode || targetNode.isText) {\n                    return;\n                }\n                tr = (tr || state.tr).setNodeMarkup(position, undefined, node.attrs, filteredMarks);\n            }\n        });\n        return;\n    }, from);\n    return tr;\n};\n// This will return (depth - 1) for root list parent of a list.\nconst getListLiftTarget = (type, schema, resPos) => {\n    let target = resPos.depth;\n    const { bulletList, orderedList } = schema.nodes;\n    let listItem = type;\n    if (!listItem) {\n        ({ listItem } = schema.nodes);\n    }\n    for (let i = resPos.depth; i > 0; i--) {\n        const node = resPos.node(i);\n        if (node.type === bulletList || node.type === orderedList) {\n            target = i;\n        }\n        if (node.type !== bulletList &&\n            node.type !== orderedList &&\n            node.type !== listItem) {\n            break;\n        }\n    }\n    return target - 1;\n};\nfunction mapChildren(node, callback) {\n    const array = [];\n    for (let i = 0; i < node.childCount; i++) {\n        array.push(callback(node.child(i), i, node instanceof Fragment ? node : node.content));\n    }\n    return array;\n}\nconst isFirstChildOfParent = (state) => {\n    const { $from } = state.selection;\n    return $from.depth > 1\n        ? (state.selection instanceof GapCursorSelection &&\n            $from.parentOffset === 0) ||\n            $from.index($from.depth - 1) === 0\n        : true;\n};\nfunction mapSlice(slice, callback) {\n    const fragment = mapFragment(slice.content, callback);\n    return new Slice(fragment, slice.openStart, slice.openEnd);\n}\nfunction mapFragment(content, callback, parent) {\n    const children = [];\n    for (let i = 0, size = content.childCount; i < size; i++) {\n        const node = content.child(i);\n        const transformed = node.isLeaf\n            ? callback(node, parent, i)\n            : callback(node.copy(mapFragment(node.content, callback, node)), parent, i);\n        if (transformed) {\n            if (transformed instanceof Fragment) {\n                children.push(...getFragmentBackingArray(transformed));\n            }\n            else if (Array.isArray(transformed)) {\n                children.push(...transformed);\n            }\n            else {\n                children.push(transformed);\n            }\n        }\n    }\n    return Fragment.fromArray(children);\n}\nfunction getFragmentBackingArray(fragment) {\n    // @ts-ignore @types/prosemirror-model doesn't have Fragment.content\n    return fragment.content;\n}\n/**\n *\n * @param {*} type The schema type of object to create\n * @param {*} placement The placement of the node - above or below\n * @param {*} nestable putting this true will create the\n *            empty node at -1. Set this to true   for nodes\n *             which are nested, for example in:\n *              `<ul> p1 <li> p2 <p>abc</p> p7 </li> p8 <ul>`\n *            we want to insert empty `<li>` above, for which we\n *            will  insert it at pos p1 and not p2. If nested was false,\n *            the function would hav inserted at p2.\n */\nfunction insertEmpty(type, placement = 'above', nestable = false, attrs) {\n    const isAbove = placement === 'above';\n    const depth = nestable ? -1 : undefined;\n    return (state, dispatch) => {\n        const insertPos = isAbove\n            ? state.selection.$from.before(depth)\n            : state.selection.$from.after(depth);\n        const nodeToInsert = type.createAndFill(attrs);\n        const tr = state.tr;\n        let newTr = safeInsert(nodeToInsert, insertPos)(state.tr);\n        if (tr === newTr) {\n            return false;\n        }\n        if (dispatch) {\n            dispatch(newTr.scrollIntoView());\n        }\n        return true;\n    };\n}\nfunction findFirstMarkPosition(mark, doc, from, to) {\n    let markPos = { start: -1, end: -1 };\n    doc.nodesBetween(from, to, (node, pos) => {\n        // stop recursing if result is found\n        if (markPos.start > -1) {\n            return false;\n        }\n        if (markPos.start === -1 && mark.isInSet(node.marks)) {\n            markPos = {\n                start: pos,\n                end: pos + Math.max(node.textContent.length, 1),\n            };\n        }\n        return;\n    });\n    return markPos;\n}\n/**\n * Creates a plugin which allows for saving of value\n * Helpful for use cases when you just want to store\n * a value in the state and the value will not change\n * over time.\n *\n * Good to know: you get the value by doing `key.getState(state)`\n */\nfunction valuePlugin(key, value) {\n    return new Plugin({\n        key,\n        state: {\n            init() {\n                return value;\n            },\n            apply(_, v) {\n                return v;\n            },\n        },\n    });\n}\nfunction toHTMLString(state) {\n    const div = document.createElement('div');\n    const fragment = DOMSerializer.fromSchema(state.schema).serializeFragment(state.doc.content);\n    div.appendChild(fragment);\n    return div.innerHTML;\n}\nfunction extendDispatch(dispatch, tapTr) {\n    return (dispatch &&\n        ((tr) => {\n            if (tr.isGeneric) {\n                tapTr(tr);\n            }\n            dispatch(tr);\n        }));\n}\n/**\n * Gets the node type from the schema\n * Warning: This will throw if the node type is not found\n * @param arg\n * @param name\n * @returns\n */\nfunction getNodeType(arg, name) {\n    const nodeType = arg instanceof EditorState ? arg.schema.nodes[name] : arg.nodes[name];\n    assertNotUndefined(nodeType, `nodeType ${name} not found`);\n    return nodeType;\n}\n/**\n * Gets the paragraph node type from the schema\n * Warning: This will throw if the node type is not found\n * @param arg\n * @param name\n * @returns\n */\nfunction getParaNodeType(arg) {\n    const nodeType = arg instanceof EditorState\n        ? arg.schema.nodes['paragraph']\n        : arg.nodes['paragraph'];\n    assertNotUndefined(nodeType, `nodeType paragraph not found`);\n    return nodeType;\n}\n\nexport { APP_ENV, Either, Emitter, GapCursorSelection, ObjectUID, abortableSetTimeout, assertNotUndefined, bangleWarn, browser, cancelablePromise, compose, createElement, createObject, debounceFn, domEventListener, domSerializationHelpers, extendDispatch, filter, findAncestorPosition, findCutBefore, findFirstMarkPosition, getAncestorNodesBetween, getFragmentBackingArray, getIdleCallback, getListLiftTarget, getMarkAttrs, getNodeType, getParaNodeType, hasVisibleContent, insertEmpty, isChromeWithSelectionBug, isEmptyDocument, isEmptyParagraph, isEmptySelectionAtStart, isFirstChildOfParent, isMarkActiveInSelection, isNodeEmpty, isProdEnv, isRangeOfType, isTestEnv, mapChildren, mapFragment, mapSlice, markInputRule, markPasteRule, matchAllPlus, nodeIsActive, objectFilter, objectMapValues, objectUid, rafCommandExec, rafSchedule, sanitiseSelectionMarksForWrapping, serialExecuteQueue, simpleLRU, sleep, toHTMLString, uuid, validListParent, validPos, valuePlugin, weakCache };\n"],
  "mappings": "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",
  "names": ["Node", "func", "node", "isEmptyParagraph"]
}
