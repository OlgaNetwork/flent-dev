import {
  useEditorViewContext,
  usePluginState
} from "./chunk-BPUUFR25.js";
import {
  createTooltipDOM,
  suggestTooltip
} from "./chunk-S2ZCVA2Z.js";
import "./chunk-7TIGO2NG.js";
import "./chunk-HNOPRNJR.js";
import {
  bangleWarn,
  getNodeType,
  rafCommandExec,
  uuid,
  valuePlugin
} from "./chunk-F3Z2TPKG.js";
import {
  PluginKey
} from "./chunk-ZRMAPHIN.js";
import "./chunk-NVKSN2QT.js";
import {
  require_react_dom
} from "./chunk-KCNL2KYZ.js";
import {
  require_react
} from "./chunk-UAYAVOPY.js";
import {
  __toESM
} from "./chunk-AUZ3RYOM.js";

// .yarn/__virtual__/@bangle.dev-react-emoji-suggest-virtual-f63d647616/5/Users/ted/.yarn/berry/cache/@bangle.dev-react-emoji-suggest-npm-0.32.0-4a302f7e9e-10c0.zip/node_modules/@bangle.dev/react-emoji-suggest/dist/index.js
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var emptyValue = { item: void 0, coords: void 0 };
function coordsToCounter(coords, namedGroups) {
  const groups = flattenEmojiGroups(namedGroups);
  let counter = 0;
  for (let i = 0; i < coords[0]; i++) {
    counter += groups[i].length;
  }
  counter += coords[1];
  return counter;
}
function counterToCoords(counter, namedGroups) {
  const groups = flattenEmojiGroups(namedGroups);
  let normalizedCounter = normalizeCounter(counter, groups);
  if (normalizedCounter == null) {
    return;
  }
  for (let i = 0; i < groups.length; i++) {
    const size = groups[i].length;
    if (normalizedCounter < size) {
      return [i, normalizedCounter];
    }
    normalizedCounter = normalizedCounter - size;
  }
  return;
}
function resolveCounter(counter, namedGroups) {
  const coords = counterToCoords(counter, namedGroups);
  if (!coords) {
    return emptyValue;
  }
  const groups = flattenEmojiGroups(namedGroups);
  return { item: groups[coords[0]][coords[1]], coords };
}
function resolveRowJump(counter, direction = 1, jump, namedGroups) {
  const { coords } = jumpRow(counter, direction, jump, namedGroups);
  if (coords == null) {
    return null;
  }
  return coordsToCounter(coords, namedGroups);
}
function getNextGroup(groupIndex, groups, direction = 1) {
  let newIndex = groupIndex + direction;
  if (groups.length === 0) {
    return;
  }
  while (newIndex < 0) {
    newIndex += groups.length;
  }
  newIndex = newIndex % groups.length;
  return newIndex;
}
function getSquareDimensions({ rowWidth, squareMargin, squareSide }) {
  const squareFullWidth = squareSide + 2 * squareMargin;
  const rowCount = Math.floor((rowWidth - 2) / squareFullWidth);
  const containerWidth = rowCount * squareFullWidth;
  return {
    containerWidth,
    rowCount
  };
}
function jumpRow(counter, direction = 1, jump, namedGroups) {
  const coords = counterToCoords(counter, namedGroups);
  if (!coords) {
    return emptyValue;
  }
  const groups = flattenEmojiGroups(namedGroups);
  const groupIndex = coords[0];
  const itemIndex = coords[1];
  const groupSize = groups[groupIndex].length;
  const newIndex = direction === 1 ? itemIndex + jump : itemIndex - jump;
  if (newIndex < groupSize && newIndex >= 0) {
    return {
      item: groups[groupIndex][newIndex],
      coords: [groupIndex, newIndex]
    };
  }
  const nextGroupIndex = getNextGroup(groupIndex, groups, newIndex >= groupSize ? 1 : -1);
  if (nextGroupIndex == null) {
    return emptyValue;
  }
  const nextGroup = groups[nextGroupIndex];
  const nextItemIndex = direction === 1 ? 0 : nextGroup.length - 1;
  const item = nextGroup[nextItemIndex];
  if (item == null) {
    return emptyValue;
  }
  return {
    item,
    coords: [nextGroupIndex, nextItemIndex]
  };
}
function flattenEmojiGroups(namedGroups) {
  return namedGroups.map((r) => r.emojis);
}
function normalizeCounter(counter, groups) {
  const totalSize = groups.reduce((prev, cur) => prev + cur.length, 0);
  if (totalSize === 0) {
    return;
  }
  while (counter < 0) {
    counter += totalSize;
  }
  counter = counter % totalSize;
  return counter;
}
var { decrementSuggestTooltipCounter, incrementSuggestTooltipCounter, updateSuggestTooltipCounter, removeSuggestMark, resetSuggestTooltipCounter, defaultKeys } = suggestTooltip;
var spec = specFactory;
var plugins = pluginsFactory;
var commands = {
  queryTriggerText,
  selectEmoji
};
var defaultTrigger = ":";
var defaultMaxItems = 2e3;
function specFactory({ markName, trigger = defaultTrigger }) {
  const spec2 = suggestTooltip.spec({ markName, trigger });
  return {
    ...spec2,
    options: {
      trigger
    }
  };
}
function pluginsFactory({ key = new PluginKey("emojiSuggestMenu"), markName, tooltipRenderOpts = {}, getEmojiGroups, maxItems = defaultMaxItems, squareSide = 32, squareMargin = 2, rowWidth = 400 }) {
  return ({ schema, specRegistry }) => {
    const { trigger } = specRegistry.options[markName];
    const suggestTooltipKey = new PluginKey("suggestTooltipKey");
    const tooltipDOMSpec = createTooltipDOM(tooltipRenderOpts.tooltipDOMSpec);
    const getIsTop = () => tooltipDOMSpec.dom.getAttribute("data-popper-placement") === "top-start";
    if (!schema.marks[markName]) {
      bangleWarn(`Couldn't find the markName:${markName}, please make sure you have initialized to use the same markName you initialized the spec with`);
      throw new Error(`markName ${markName} not found`);
    }
    const selectedEmojiSquareId = uuid(6);
    const updateCounter = (keyType) => {
      return (state, dispatch, view) => {
        requestAnimationFrame(() => {
          const selectedEmoji = document.getElementById(selectedEmojiSquareId);
          if (selectedEmoji) {
            if ("scrollIntoViewIfNeeded" in document.body) {
              selectedEmoji.scrollIntoViewIfNeeded(false);
            } else if (selectedEmoji.scrollIntoView) {
              selectedEmoji.scrollIntoView(false);
            }
          }
          view === null || view === void 0 ? void 0 : view.focus();
        });
        if (keyType === "LEFT") {
          return decrementSuggestTooltipCounter(suggestTooltipKey)(state, dispatch, view);
        }
        if (keyType === "RIGHT") {
          return incrementSuggestTooltipCounter(suggestTooltipKey)(state, dispatch, view);
        }
        const goUp = keyType === "UP" ? !getIsTop() : getIsTop();
        const namedEmojiGroups = getEmojiGroups(queryTriggerText(key)(state));
        const { counter } = suggestTooltipKey.getState(state);
        const { rowCount } = getSquareDimensions({
          rowWidth,
          squareMargin,
          squareSide
        });
        const newCounter = resolveRowJump(counter, goUp ? -1 : 1, rowCount, namedEmojiGroups);
        if (newCounter == null) {
          return false;
        }
        return updateSuggestTooltipCounter(suggestTooltipKey, newCounter)(state, dispatch, view);
      };
    };
    return [
      valuePlugin(key, {
        getEmojiGroups,
        maxItems,
        tooltipContentDOM: tooltipDOMSpec.contentDOM,
        markName,
        squareSide,
        squareMargin,
        selectedEmojiSquareId,
        rowWidth,
        suggestTooltipKey
      }),
      suggestTooltip.plugins({
        key: suggestTooltipKey,
        markName,
        trigger,
        tooltipRenderOpts: {
          ...tooltipRenderOpts,
          tooltipDOMSpec
        },
        keybindings: {
          ...defaultKeys,
          left: "ArrowLeft",
          right: "ArrowRight"
        },
        onEnter: (state, dispatch, view) => {
          const emojiGroups = getEmojiGroups(queryTriggerText(key)(state));
          const matchedEmojis = emojiGroups.flatMap((r) => r.emojis);
          if (matchedEmojis.length === 0) {
            return removeSuggestMark(key)(state, dispatch, view);
          }
          const { counter } = suggestTooltipKey.getState(state);
          const { item: activeItem } = resolveCounter(counter, emojiGroups);
          if (!activeItem) {
            return removeSuggestMark(key)(state, dispatch, view);
          }
          const emojiAlias = activeItem[0];
          view && rafCommandExec(view, resetSuggestTooltipCounter(suggestTooltipKey));
          return selectEmoji(key, emojiAlias)(state, dispatch, view);
        },
        onArrowDown: updateCounter("DOWN"),
        onArrowUp: updateCounter("UP"),
        onArrowLeft: updateCounter("LEFT"),
        onArrowRight: updateCounter("RIGHT")
      })
    ];
  };
}
function getSuggestTooltipKey(key) {
  return (state) => {
    return key.getState(state).suggestTooltipKey;
  };
}
function queryTriggerText(key) {
  return (state) => {
    const suggestKey = getSuggestTooltipKey(key)(state);
    return suggestTooltip.queryTriggerText(suggestKey)(state);
  };
}
function selectEmoji(key, emojiAlias) {
  return (state, dispatch, view) => {
    const emojiNode = getNodeType(state, "emoji").create({
      emojiAlias
    });
    const suggestKey = getSuggestTooltipKey(key)(state);
    return suggestTooltip.replaceSuggestMarkWith(suggestKey, emojiNode)(state, dispatch, view);
  };
}
var emojiSuggest = Object.freeze({
  __proto__: null,
  spec,
  plugins,
  commands,
  getSuggestTooltipKey,
  queryTriggerText,
  selectEmoji
});
function EmojiSuggest({ emojiSuggestKey }) {
  const view = useEditorViewContext();
  const { tooltipContentDOM, getEmojiGroups, maxItems, squareSide, squareMargin, rowWidth, selectedEmojiSquareId, suggestTooltipKey } = usePluginState(emojiSuggestKey);
  const { counter, triggerText, show: isVisible } = usePluginState(suggestTooltipKey);
  return import_react_dom.default.createPortal(import_react.default.createElement(
    "div",
    { className: "bangle-emoji-suggest" },
    import_react.default.createElement("div", { style: {
      width: rowWidth,
      display: "flex",
      justifyContent: "center"
    } }, isVisible && import_react.default.createElement(EmojiSuggestContainer, { view, rowWidth, squareMargin, squareSide, maxItems, emojiSuggestKey, getEmojiGroups, triggerText, counter, selectedEmojiSquareId }))
  ), tooltipContentDOM);
}
function EmojiSuggestContainer({ view, rowWidth, squareMargin, squareSide, emojiSuggestKey, getEmojiGroups, triggerText, counter, selectedEmojiSquareId, maxItems }) {
  const emojiGroups = (0, import_react.useMemo)(() => getEmojiGroups(triggerText), [getEmojiGroups, triggerText]);
  const { containerWidth } = getSquareDimensions({
    rowWidth,
    squareMargin,
    squareSide
  });
  const { item: activeItem } = resolveCounter(counter, emojiGroups);
  const onSelectEmoji = (0, import_react.useCallback)((emojiAlias) => {
    selectEmoji(emojiSuggestKey, emojiAlias)(view.state, view.dispatch, view);
  }, [view, emojiSuggestKey]);
  return import_react.default.createElement("div", { className: "bangle-emoji-suggest-container", style: {
    width: containerWidth
  } }, emojiGroups.map(({ name: groupName, emojis }, i) => {
    return import_react.default.createElement(
      "div",
      { className: "bangle-emoji-suggest-group", key: groupName || i },
      groupName && import_react.default.createElement("span", null, groupName),
      import_react.default.createElement("div", null, emojis.slice(0, maxItems).map(([emojiAlias, emoji]) => import_react.default.createElement(EmojiSquare, { key: emojiAlias, isSelected: (activeItem === null || activeItem === void 0 ? void 0 : activeItem[0]) === emojiAlias, emoji, emojiAlias, onSelectEmoji, selectedEmojiSquareId, style: {
        margin: squareMargin,
        width: squareSide,
        height: squareSide,
        lineHeight: squareSide + "px",
        fontSize: Math.max(squareSide - 7, 4)
      } })))
    );
  }));
}
function EmojiSquare({ isSelected, emoji, emojiAlias, onSelectEmoji, style, selectedEmojiSquareId }) {
  return import_react.default.createElement("button", { className: `bangle-emoji-square ${isSelected ? "bangle-is-selected" : ""}`, id: isSelected ? selectedEmojiSquareId : void 0, onClick: (e) => {
    e.preventDefault();
    onSelectEmoji(emojiAlias);
  }, style }, emoji);
}
export {
  EmojiSuggest,
  EmojiSuggestContainer,
  emojiSuggest,
  getSquareDimensions,
  resolveCounter,
  resolveRowJump,
  selectEmoji
};
//# sourceMappingURL=@bangle__dev_react-emoji-suggest.js.map
