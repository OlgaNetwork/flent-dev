{
  "version": 3,
  "sources": ["../../../.yarn/__virtual__/@bangle.dev-table-virtual-91830855d8/5/Users/ted/.yarn/berry/cache/@bangle.dev-table-npm-0.32.0-08e83a57f8-10c0.zip/node_modules/@bangle.dev/table/dist/index.js"],
  "sourcesContent": ["import { tableNodes, tableEditing, keymap, goToNextCell } from '@bangle.dev/pm';\n\nfunction calculateColumnWidth(tableNode) {\n    const sizeMap = new Map();\n    let maxColIndex = 0;\n    tableNode.forEach((row) => {\n        row.forEach((cell, _, colIndex) => {\n            if (colIndex > maxColIndex) {\n                maxColIndex = colIndex;\n            }\n            if (!cell) {\n                return;\n            }\n            const textLength = cell.textContent.length + 2;\n            if (!sizeMap.has(colIndex)) {\n                sizeMap.set(colIndex, textLength);\n            }\n            if (textLength > sizeMap.get(colIndex)) {\n                sizeMap.set(colIndex, textLength);\n            }\n        });\n    });\n    return Array.from({ length: maxColIndex + 1 }, (_, k) => sizeMap.get(k) || 1);\n}\nconst nodes = tableNodes({\n    tableGroup: 'block',\n    cellContent: 'block+',\n    cellAttributes: {\n        align: {\n            default: null,\n            setDOMAttr(value, attrs) {\n                if (value != null) {\n                    attrs['style'] = (attrs['style'] || '') + `text-align: ${value};`;\n                }\n            },\n        },\n        background: {\n            default: null,\n            getFromDOM(dom) {\n                return dom.style.backgroundColor || null;\n            },\n            setDOMAttr(value, attrs) {\n                if (value) {\n                    attrs['style'] =\n                        (attrs['style'] || '') + `background-color: ${value};`;\n                }\n            },\n        },\n    },\n});\nconst tableHeaderName = 'table_header';\nconst toMarkdownCell = (state, node) => {\n    node.forEach(function (child, _, i) {\n        const originalEsc = state.esc;\n        state.esc = (str, ...args) => {\n            str = originalEsc.call(state, str, ...args);\n            str = str.replace(/\\|/gi, '\\\\$&');\n            return str;\n        };\n        state.renderInline(child);\n        state.esc = originalEsc;\n    });\n};\nconst table = {\n    name: 'table',\n    type: 'node',\n    schema: nodes.table,\n    markdown: {\n        toMarkdown: (state, node) => {\n            // flushClose is not added to the typings\n            state.flushClose(1);\n            state.ensureNewLine();\n            state.write('\\n');\n            state.renderContent(node);\n            return;\n        },\n        parseMarkdown: {\n            table: {\n                block: 'table',\n            },\n        },\n    },\n};\nconst tableCell = {\n    name: 'table_cell',\n    type: 'node',\n    schema: nodes.table_cell,\n    markdown: {\n        toMarkdown: toMarkdownCell,\n        parseMarkdown: {\n            td: {\n                block: 'table_cell',\n                getAttrs: (tok) => ({ align: tok.align }),\n            },\n        },\n    },\n};\nconst tableHeader = {\n    name: tableHeaderName,\n    type: 'node',\n    schema: nodes.table_header,\n    markdown: {\n        // cell and header are same as far as serialization is concerned\n        toMarkdown: toMarkdownCell,\n        parseMarkdown: {\n            th: {\n                block: 'table_header',\n                getAttrs: (tok) => ({ align: tok.align }),\n            },\n        },\n    },\n};\nconst tableRow = {\n    name: 'table_row',\n    type: 'node',\n    schema: nodes.table_row,\n    markdown: {\n        toMarkdown: (state, node, parent) => {\n            var _a;\n            state.ensureNewLine();\n            const width = calculateColumnWidth(parent);\n            // child is either table_header or table_cell\n            node.forEach(function (child, _, i) {\n                i === 0 && state.write('| ');\n                // render has missing types for the 2nd and 3rd param (parent and index)\n                state.render(child, node, i);\n                const extraSpace = width[i] - 2 - child.textContent.length;\n                state.write(' '.repeat(Math.max(0, extraSpace)));\n                state.write(' |');\n                child !== node.lastChild && state.write(' ');\n            });\n            state.ensureNewLine();\n            // check if it is the header row\n            if (((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.type.name) === tableHeaderName) {\n                node.forEach(function (child, _, i) {\n                    i === 0 && state.write('|');\n                    const { align } = child.attrs;\n                    switch (align) {\n                        case 'left': {\n                            state.write(':');\n                            const extraSpace = width[i] - 1;\n                            state.write('-'.repeat(Math.max(0, extraSpace)));\n                            break;\n                        }\n                        case 'center': {\n                            state.write(':');\n                            const extraSpace = width[i] - 2;\n                            state.write('-'.repeat(Math.max(0, extraSpace)));\n                            state.write(':');\n                            break;\n                        }\n                        case 'right': {\n                            const extraSpace = width[i] - 1;\n                            state.write('-'.repeat(Math.max(0, extraSpace)));\n                            state.write(':');\n                            break;\n                        }\n                        default: {\n                            const extraSpace = width[i];\n                            state.write('-'.repeat(Math.max(0, extraSpace)));\n                            break;\n                        }\n                    }\n                    state.write('|');\n                });\n            }\n        },\n        parseMarkdown: {\n            tr: {\n                block: 'table_row',\n            },\n        },\n    },\n};\nconst tablePlugins = () => {\n    return [\n        tableEditing(),\n        keymap({\n            'Tab': goToNextCell(1),\n            'Shift-Tab': goToNextCell(-1),\n        }),\n    ];\n};\n\nexport { table, tableCell, tableHeader, tablePlugins, tableRow };\n"],
  "mappings": "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",
  "names": []
}
