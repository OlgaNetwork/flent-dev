import {
  goToNextCell,
  keymap,
  tableEditing,
  tableNodes
} from "./chunk-ZRMAPHIN.js";
import "./chunk-NVKSN2QT.js";
import "./chunk-AUZ3RYOM.js";

// .yarn/__virtual__/@bangle.dev-table-virtual-91830855d8/5/Users/ted/.yarn/berry/cache/@bangle.dev-table-npm-0.32.0-08e83a57f8-10c0.zip/node_modules/@bangle.dev/table/dist/index.js
function calculateColumnWidth(tableNode) {
  const sizeMap = /* @__PURE__ */ new Map();
  let maxColIndex = 0;
  tableNode.forEach((row) => {
    row.forEach((cell, _, colIndex) => {
      if (colIndex > maxColIndex) {
        maxColIndex = colIndex;
      }
      if (!cell) {
        return;
      }
      const textLength = cell.textContent.length + 2;
      if (!sizeMap.has(colIndex)) {
        sizeMap.set(colIndex, textLength);
      }
      if (textLength > sizeMap.get(colIndex)) {
        sizeMap.set(colIndex, textLength);
      }
    });
  });
  return Array.from({ length: maxColIndex + 1 }, (_, k) => sizeMap.get(k) || 1);
}
var nodes = tableNodes({
  tableGroup: "block",
  cellContent: "block+",
  cellAttributes: {
    align: {
      default: null,
      setDOMAttr(value, attrs) {
        if (value != null) {
          attrs["style"] = (attrs["style"] || "") + `text-align: ${value};`;
        }
      }
    },
    background: {
      default: null,
      getFromDOM(dom) {
        return dom.style.backgroundColor || null;
      },
      setDOMAttr(value, attrs) {
        if (value) {
          attrs["style"] = (attrs["style"] || "") + `background-color: ${value};`;
        }
      }
    }
  }
});
var tableHeaderName = "table_header";
var toMarkdownCell = (state, node) => {
  node.forEach(function(child, _, i) {
    const originalEsc = state.esc;
    state.esc = (str, ...args) => {
      str = originalEsc.call(state, str, ...args);
      str = str.replace(/\|/gi, "\\$&");
      return str;
    };
    state.renderInline(child);
    state.esc = originalEsc;
  });
};
var table = {
  name: "table",
  type: "node",
  schema: nodes.table,
  markdown: {
    toMarkdown: (state, node) => {
      state.flushClose(1);
      state.ensureNewLine();
      state.write("\n");
      state.renderContent(node);
      return;
    },
    parseMarkdown: {
      table: {
        block: "table"
      }
    }
  }
};
var tableCell = {
  name: "table_cell",
  type: "node",
  schema: nodes.table_cell,
  markdown: {
    toMarkdown: toMarkdownCell,
    parseMarkdown: {
      td: {
        block: "table_cell",
        getAttrs: (tok) => ({ align: tok.align })
      }
    }
  }
};
var tableHeader = {
  name: tableHeaderName,
  type: "node",
  schema: nodes.table_header,
  markdown: {
    // cell and header are same as far as serialization is concerned
    toMarkdown: toMarkdownCell,
    parseMarkdown: {
      th: {
        block: "table_header",
        getAttrs: (tok) => ({ align: tok.align })
      }
    }
  }
};
var tableRow = {
  name: "table_row",
  type: "node",
  schema: nodes.table_row,
  markdown: {
    toMarkdown: (state, node, parent) => {
      var _a;
      state.ensureNewLine();
      const width = calculateColumnWidth(parent);
      node.forEach(function(child, _, i) {
        i === 0 && state.write("| ");
        state.render(child, node, i);
        const extraSpace = width[i] - 2 - child.textContent.length;
        state.write(" ".repeat(Math.max(0, extraSpace)));
        state.write(" |");
        child !== node.lastChild && state.write(" ");
      });
      state.ensureNewLine();
      if (((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.type.name) === tableHeaderName) {
        node.forEach(function(child, _, i) {
          i === 0 && state.write("|");
          const { align } = child.attrs;
          switch (align) {
            case "left": {
              state.write(":");
              const extraSpace = width[i] - 1;
              state.write("-".repeat(Math.max(0, extraSpace)));
              break;
            }
            case "center": {
              state.write(":");
              const extraSpace = width[i] - 2;
              state.write("-".repeat(Math.max(0, extraSpace)));
              state.write(":");
              break;
            }
            case "right": {
              const extraSpace = width[i] - 1;
              state.write("-".repeat(Math.max(0, extraSpace)));
              state.write(":");
              break;
            }
            default: {
              const extraSpace = width[i];
              state.write("-".repeat(Math.max(0, extraSpace)));
              break;
            }
          }
          state.write("|");
        });
      }
    },
    parseMarkdown: {
      tr: {
        block: "table_row"
      }
    }
  }
};
var tablePlugins = () => {
  return [
    tableEditing(),
    keymap({
      "Tab": goToNextCell(1),
      "Shift-Tab": goToNextCell(-1)
    })
  ];
};
export {
  table,
  tableCell,
  tableHeader,
  tablePlugins,
  tableRow
};
//# sourceMappingURL=@bangle__dev_table.js.map
