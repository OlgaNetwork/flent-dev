{
  "version": 3,
  "sources": ["../../../.yarn/__virtual__/@bangle.dev-collab-manager-virtual-8ea5fe4a98/5/Users/ted/.yarn/berry/cache/@bangle.dev-collab-manager-npm-0.32.0-54ed9924ce-10c0.zip/node_modules/@bangle.dev/collab-manager/dist/index.js"],
  "sourcesContent": ["import { CollabFail, CollabClientRequestType, DEFAULT_MANAGER_ID, ManagerCommunication, CollabManagerBroadCastType } from '@bangle.dev/collab-comms';\nimport { Step } from '@bangle.dev/pm';\nimport { isTestEnv, Either } from '@bangle.dev/utils';\n\nconst MAX_STEP_HISTORY = 1000;\nconst LOG$1 = true;\nlet log$1 = (isTestEnv ? false : LOG$1)\n    ? console.debug.bind(console, 'collab-manager/state:')\n    : () => { };\nclass CollabServerState {\n    constructor(doc, steps = [], version = 0) {\n        this.doc = doc;\n        this.steps = steps;\n        this.version = version;\n        // Trim steps if needed\n        if (steps.length > MAX_STEP_HISTORY) {\n            this.steps = steps.slice(steps.length - MAX_STEP_HISTORY);\n        }\n    }\n    static addEvents(state, version, steps, clientID) {\n        if (CollabServerState.isInvalidVersion(state, version)) {\n            return Either.left(CollabFail.InvalidVersion);\n        }\n        const biggerSteps = steps.map((s) => Object.assign(s, { clientID }));\n        if (state.version !== version) {\n            return Either.left(CollabFail.OutdatedVersion);\n        }\n        let newDoc = state.doc;\n        const maps = [];\n        for (const step of biggerSteps) {\n            let result;\n            try {\n                result = step.apply(newDoc);\n            }\n            catch (error) {\n                console.error(error);\n                return Either.left(CollabFail.ApplyFailed);\n            }\n            if (result.doc == null) {\n                return Either.left(CollabFail.ApplyFailed);\n            }\n            newDoc = result.doc;\n            maps.push(step.getMap());\n        }\n        const newVersion = state.version + biggerSteps.length;\n        const newSteps = state.steps.concat(biggerSteps);\n        log$1(`${clientID}: addEvents version=${newVersion}`);\n        return Either.right(new CollabServerState(newDoc, newSteps, newVersion));\n    }\n    static getEvents(collabState, version) {\n        if (CollabServerState.isInvalidVersion(collabState, version)) {\n            return Either.left(CollabFail.InvalidVersion);\n        }\n        let startIndex = collabState.steps.length - (collabState.version - version);\n        if (startIndex < 0) {\n            return Either.left(CollabFail.HistoryNotAvailable);\n        }\n        return Either.right({\n            version: collabState.version,\n            steps: collabState.steps.slice(startIndex),\n        });\n    }\n    static isInvalidVersion(collabState, version) {\n        return version < 0 || version > collabState.version;\n    }\n}\n\nconst maxNoOfPendingRecords = 100;\n/**\n * A class for managing the instance deletion respecting the following conditions:\n * - If no new client connects to the instance, the instance is deleted after a delay.\n * - If a new client connects to the instance, the deletion is aborted.\n *    - Even if deletion was aborted, older clients will continue to see `checkAccess` return `false`.\n * - Older clients will start seeing `checkAccess` return `false`, right after the request to delete is called.\n * - Newer clients will see `checkAccess` return `true`.\n * - If instance was never requested to be deleted, all `checkAccess` calls will return `true`.\n *\n * New client: Any client that was created after the request to delete was called.\n * Old client: Any client that was created before the request to delete was called.\n */\nclass InstanceDeleteGuard {\n    constructor(opts) {\n        this.opts = opts;\n        this.pendingDeleteRecord = new Map();\n        if (this.opts.deleteWaitTime >= this.opts.maxDurationToKeepRecord) {\n            throw new Error('deleteWaitTime must be less than maxDurationToKeepRecord');\n        }\n    }\n    addPendingDelete(docName, deleteCallback) {\n        var _a;\n        // if there is already a delete request pending, abort it\n        (_a = this.pendingDeleteRecord.get(docName)) === null || _a === void 0 ? void 0 : _a.abortDelete.abort();\n        const abortController = new AbortController();\n        this.pendingDeleteRecord.set(docName, {\n            deleteTime: Date.now(),\n            abortDelete: abortController,\n        });\n        abortableSetTimeout(deleteCallback, abortController.signal, this.opts.deleteWaitTime);\n        this.containSize();\n    }\n    /**\n     * Guard to ensure client is not accessing an instance that is about to be deleted or is deleted\n     */\n    checkAccess(docName, clientCreatedAt) {\n        const record = this.pendingDeleteRecord.get(docName);\n        if (!record) {\n            return true;\n        }\n        // if client was created after the delete request\n        // we cancel the pending delete instance request. Note that the request may have already\n        // been executed, but we don't care about that.\n        // we also grant access but we still keep the record around, in case an older client\n        // tries to access the instance.\n        if (clientCreatedAt > record.deleteTime) {\n            record.abortDelete.abort();\n            return true;\n        }\n        return false;\n    }\n    containSize() {\n        const timeNow = Date.now();\n        let sorted = Array.from(this.pendingDeleteRecord.entries()).filter((item) => {\n            return (timeNow - item[1].deleteTime <= this.opts.maxDurationToKeepRecord);\n        });\n        if (sorted.length > maxNoOfPendingRecords) {\n            sorted = sorted\n                .sort((a, b) => {\n                return b[1].deleteTime - a[1].deleteTime;\n            })\n                .slice(0, maxNoOfPendingRecords);\n        }\n        this.pendingDeleteRecord = new Map(sorted);\n    }\n    destroy() {\n        this.pendingDeleteRecord.forEach((item) => {\n            item.abortDelete.abort();\n        });\n        this.pendingDeleteRecord.clear();\n    }\n}\nfunction abortableSetTimeout(callback, signal, ms) {\n    const timer = setTimeout(callback, ms);\n    signal.addEventListener('abort', () => {\n        clearTimeout(timer);\n    }, { once: true });\n}\n\nconst LOG = true;\nlet log = (isTestEnv ? false : LOG)\n    ? console.debug.bind(console, 'collab-manager:')\n    : () => { };\nclass CollabManager {\n    constructor(_options) {\n        this._options = _options;\n        this._abortController = new AbortController();\n        this._handleRequest = async (request, id) => {\n            if (!this._instanceDeleteGuard.checkAccess(request.body.docName, request.body.clientCreatedAt)) {\n                return {\n                    ok: false,\n                    body: CollabFail.HistoryNotAvailable,\n                    type: request.type,\n                };\n            }\n            log(`id=${id} userId=${request.body.userId} received request=${request.type}, `);\n            switch (request.type) {\n                case CollabClientRequestType.GetDocument: {\n                    return this._handleGetDocument(request, id);\n                }\n                case CollabClientRequestType.PullEvents: {\n                    return this._handlePullEvents(request, id);\n                }\n                case CollabClientRequestType.PushEvents: {\n                    return this._handlePushEvents(request, id);\n                }\n                default: {\n                    throw new Error('Unknown request type');\n                }\n            }\n        };\n        this._instances = new Map();\n        this.managerId = _options.managerId || DEFAULT_MANAGER_ID;\n        this._serverCom = new ManagerCommunication(this.managerId, _options.collabMessageBus, this._handleRequest, this._abortController.signal);\n        this._instanceDeleteGuard = new InstanceDeleteGuard(this._options.instanceDeleteGuardOpts || {\n            deleteWaitTime: 500,\n            maxDurationToKeepRecord: 1000 * 60,\n        });\n    }\n    destroy() {\n        this._abortController.abort();\n        this._instanceDeleteGuard.destroy();\n    }\n    getAllDocNames() {\n        return new Set(this._instances.keys());\n    }\n    getCollabState(docName) {\n        var _a;\n        return (_a = this._instances.get(docName)) === null || _a === void 0 ? void 0 : _a.collabState;\n    }\n    isDestroyed() {\n        return this._abortController.signal.aborted;\n    }\n    // Requests deletion of instance after a delay if no new clients\n    // attempt to connect to the given `docName`. Tweak opts.instanceDeleteGuardOpts\n    requestDeleteInstance(docName) {\n        if (this.isDestroyed()) {\n            return;\n        }\n        // delete the instance after broadcasting\n        // since some clients will take a while to terminate\n        this._instanceDeleteGuard.addPendingDelete(docName, () => {\n            this._instances.delete(docName);\n        });\n    }\n    // removes collab state entry associated with docName.\n    // And broadcast to any client with the docName (if any exists)\n    // to reset its content and do a fresh fetch of the document.\n    // WARNING: this is a destructive operation and will result\n    // in loss of any un-pushed client data.\n    resetDoc(docName) {\n        this._instances.delete(docName);\n        this._serverCom.broadcast({\n            type: CollabManagerBroadCastType.ResetClient,\n            body: {\n                docName: docName,\n            },\n        });\n    }\n    async _createInstance(docName) {\n        const initialCollabState = await this._options.getInitialState(docName);\n        // this takes care of edge case where another instance is created\n        // while we wait on `getInitialState`.\n        let instance = this._instances.get(docName);\n        if (instance) {\n            return Either.right(instance);\n        }\n        if (!initialCollabState) {\n            return Either.left(CollabFail.DocumentNotFound);\n        }\n        instance = new Instance(docName, this._options.schema, initialCollabState, this._options.applyState);\n        this._instances.set(docName, instance);\n        return Either.right(instance);\n    }\n    /**\n     * Get an instance of a document or creates a new one\n     * if none exists.\n     * @param docName\n     * @returns\n     */\n    async _getInstance(docName) {\n        const instance = this._instances.get(docName);\n        if (instance) {\n            instance.lastActive = Date.now();\n            return Either.right(instance);\n        }\n        return this._createInstance(docName);\n    }\n    async _handleGetDocument(request, uid) {\n        const work = (instance) => {\n            return {\n                doc: instance.collabState.doc.toJSON(),\n                users: instance.userCount,\n                version: instance.collabState.version,\n                managerId: this.managerId,\n            };\n        };\n        return this._toResponse(Either.map(await this._getInstance(request.body.docName), work), request.type);\n    }\n    async _handlePullEvents(request, uid) {\n        const work = (instance) => {\n            if (this.managerId !== request.body.managerId) {\n                return Either.left(CollabFail.IncorrectManager);\n            }\n            return instance.getEvents(request.body);\n        };\n        return this._toResponse(Either.flatMap(await this._getInstance(request.body.docName), work), request.type);\n    }\n    async _handlePushEvents(request, uid) {\n        const work = (instance) => {\n            const { type, body } = request;\n            if (this.managerId !== body.managerId) {\n                return Either.left(CollabFail.IncorrectManager);\n            }\n            const result = instance.addEvents(body);\n            if (Either.isRight(result)) {\n                queueMicrotask(() => {\n                    this._serverCom.broadcast({\n                        type: CollabManagerBroadCastType.NewVersion,\n                        body: {\n                            docName: instance.docName,\n                            version: instance.collabState.version,\n                        },\n                    });\n                });\n            }\n            return result;\n        };\n        return this._toResponse(Either.flatMap(await this._getInstance(request.body.docName), work), request.type);\n    }\n    _toResponse(val, requestType) {\n        if (Either.isLeft(val)) {\n            return {\n                ok: false,\n                body: val.left,\n                type: requestType,\n            };\n        }\n        else {\n            return {\n                ok: true,\n                body: val.right,\n                type: requestType,\n            };\n        }\n    }\n}\nclass Instance {\n    constructor(docName, schema, _collabState, _applyState = (docName, newCollabState, oldCollabState) => {\n        return true;\n    }) {\n        this.docName = docName;\n        this.schema = schema;\n        this._collabState = _collabState;\n        this._applyState = _applyState;\n        this.lastActive = Date.now();\n    }\n    get collabState() {\n        return this._collabState;\n    }\n    // TODO add userCount\n    get userCount() {\n        return 1;\n    }\n    addEvents({ clientID, version: rawVersion, steps, userId, docName, }) {\n        this.lastActive = Date.now();\n        let version = nonNegInteger(rawVersion);\n        if (version === undefined) {\n            return Either.left(CollabFail.InvalidVersion);\n        }\n        const parsedSteps = steps.map((s) => Step.fromJSON(this.schema, s));\n        return Either.flatMap(CollabServerState.addEvents(this._collabState, version, parsedSteps, clientID), (collabState) => {\n            if (this._applyState(docName, collabState, this._collabState)) {\n                this._collabState = collabState;\n            }\n            else {\n                return Either.left(CollabFail.ApplyFailed);\n            }\n            return Either.right({\n                empty: null,\n            });\n        });\n    }\n    getEvents({ docName, version, userId, managerId, }) {\n        return Either.map(CollabServerState.getEvents(this._collabState, version), (events) => {\n            return {\n                version: events.version,\n                steps: events.steps.map((step) => step.toJSON()),\n                clientIDs: events.steps.map((step) => step.clientID),\n                users: this.userCount, // TODO\n            };\n        });\n    }\n}\nfunction nonNegInteger(str) {\n    let num = Number(str);\n    if (!isNaN(num) && Math.floor(num) === num && num >= 0) {\n        return num;\n    }\n    return undefined;\n}\n\nexport { CollabManager, CollabServerState, MAX_STEP_HISTORY };\n"],
  "mappings": "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",
  "names": ["docName"]
}
