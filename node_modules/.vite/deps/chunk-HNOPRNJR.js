import {
  bangleWarn,
  browser,
  createObject,
  filter,
  findParentNodeOfType,
  getNodeType,
  getParaNodeType,
  insertEmpty,
  isTestEnv,
  mapChildren,
  objectFilter,
  toHTMLString
} from "./chunk-F3Z2TPKG.js";
import {
  DOMParser,
  DOMSerializer,
  EditorState,
  EditorView,
  Fragment,
  InputRule,
  Node,
  NodeSelection,
  Plugin,
  PluginKey,
  ReplaceStep,
  Schema,
  Selection,
  Slice,
  TextSelection,
  baseKeymap,
  dropCursor,
  gapCursor,
  history,
  inputRules,
  keymap,
  redo,
  setBlockType,
  undo,
  undoInputRule
} from "./chunk-ZRMAPHIN.js";

// .yarn/__virtual__/@bangle.dev-pm-commands-virtual-1ac47c2a63/5/Users/ted/.yarn/berry/cache/@bangle.dev-pm-commands-npm-0.32.0-c6939dba60-10c0.zip/node_modules/@bangle.dev/pm-commands/dist/index.js
function getParentTextSelection(state, currentDepth) {
  const { $from } = state.selection;
  const parentPos = $from.start(currentDepth);
  let replaceStart = parentPos;
  let replaceEnd = $from.end(currentDepth);
  return TextSelection.create(state.doc, replaceStart, replaceEnd);
}
function copyEmptyCommand(type) {
  return (state, dispatch, view) => {
    if (!state.selection.empty) {
      return false;
    }
    const current = findParentNodeOfType(type)(state.selection);
    if (!current) {
      return false;
    }
    const selection = state.selection;
    let tr = state.tr;
    tr = tr.setSelection(getParentTextSelection(state, current.depth));
    if (dispatch) {
      dispatch(tr);
    }
    document.execCommand("copy");
    const tr2 = view.state.tr;
    if (dispatch) {
      dispatch(tr2.setSelection(Selection.near(tr2.doc.resolve(selection.$from.pos))));
    }
    return true;
  };
}
function cutEmptyCommand(type) {
  return (state, dispatch) => {
    if (!state.selection.empty) {
      return false;
    }
    const parent = findParentNodeOfType(type)(state.selection);
    if (!parent || !parent.node) {
      return false;
    }
    let tr = state.tr;
    tr = tr.setSelection(NodeSelection.create(tr.doc, parent.pos));
    if (dispatch) {
      dispatch(tr);
    }
    document.execCommand("cut");
    return true;
  };
}
function parentHasDirectParentOfType(parentType, parentsParentType) {
  parentsParentType = Array.isArray(parentsParentType) ? parentsParentType : [parentsParentType];
  return (state) => {
    const currentResolved = findParentNodeOfType(parentType)(state.selection);
    if (!currentResolved) {
      return false;
    }
    const depth = currentResolved.depth - 1;
    if (depth < 0) {
      return false;
    }
    const parentsParent = state.selection.$from.node(depth);
    return parentsParentType.includes(parentsParent.type);
  };
}
function moveNode(type, dir = "UP") {
  const isDown = dir === "DOWN";
  return (state, dispatch) => {
    if (!state.selection.empty) {
      return false;
    }
    const { $from } = state.selection;
    const currentResolved = findParentNodeOfType(type)(state.selection);
    if (!currentResolved) {
      return false;
    }
    const { node: currentNode } = currentResolved;
    const parentDepth = currentResolved.depth - 1;
    const parent = $from.node(parentDepth);
    const parentPos = $from.start(parentDepth);
    if (currentNode.type !== type) {
      return false;
    }
    const arr = mapChildren(parent, (node) => node);
    let index = arr.indexOf(currentNode);
    let swapWith = isDown ? index + 1 : index - 1;
    if (swapWith >= arr.length || swapWith < 0) {
      return false;
    }
    const swapWithNodeSize = arr[swapWith].nodeSize;
    [arr[index], arr[swapWith]] = [arr[swapWith], arr[index]];
    let tr = state.tr;
    let replaceStart = parentPos;
    let replaceEnd = $from.end(parentDepth);
    const slice = new Slice(Fragment.fromArray(arr), 0, 0);
    tr = tr.step(new ReplaceStep(replaceStart, replaceEnd, slice, false));
    tr = tr.setSelection(Selection.near(tr.doc.resolve(isDown ? $from.pos + swapWithNodeSize : $from.pos - swapWithNodeSize)));
    if (dispatch) {
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
}
function jumpToStartOfNode(type) {
  return (state, dispatch) => {
    const current = findParentNodeOfType(type)(state.selection);
    if (!current) {
      return false;
    }
    if (dispatch) {
      const { start } = current;
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, start)));
    }
    return true;
  };
}
function jumpToEndOfNode(type) {
  return (state, dispatch) => {
    const current = findParentNodeOfType(type)(state.selection);
    if (!current) {
      return false;
    }
    if (dispatch) {
      const { node, start } = current;
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, start + node.content.size)));
    }
    return true;
  };
}

// .yarn/__virtual__/@bangle.dev-core-virtual-a24b9e11a9/5/Users/ted/.yarn/berry/cache/@bangle.dev-core-npm-0.32.0-e4676daf54-10c0.zip/node_modules/@bangle.dev/core/dist/index.js
var spec$2 = specFactory$2;
var name$4 = "doc";
function specFactory$2({ content = "block+" } = {}) {
  return {
    type: "node",
    topNode: true,
    name: name$4,
    schema: {
      content
    }
  };
}
var doc = Object.freeze({
  __proto__: null,
  spec: spec$2
});
var PluginGroup = class {
  constructor(name2, plugins2) {
    this.name = name2;
    this.plugins = plugins2;
  }
};
var name$3 = "editorStateCounter";
var plugins$2 = pluginsFactory$2;
var docChangedKey = new PluginKey(name$3);
var selectionChangedKey = new PluginKey(name$3);
function pluginsFactory$2() {
  return () => {
    return new PluginGroup(name$3, [
      new Plugin({
        key: docChangedKey,
        state: {
          init(_, _state) {
            return 0;
          },
          apply(tr, pluginState, _oldState, _newState) {
            return tr.docChanged ? pluginState + 1 : pluginState;
          }
        }
      }),
      new Plugin({
        key: selectionChangedKey,
        state: {
          init(_, _state) {
            return 0;
          },
          apply(_tr, pluginState, oldState, newState) {
            return newState.selection.eq(oldState && oldState.selection) ? pluginState : pluginState + 1;
          }
        }
      })
    ]);
  };
}
var editorStateCounter = Object.freeze({
  __proto__: null,
  plugins: plugins$2,
  docChangedKey,
  selectionChangedKey
});
var plugins$1 = pluginsFactory$1;
var commands$1 = {
  undo: undo2,
  redo: redo2
};
var defaultKeys$1 = {
  undo: "Mod-z",
  redo: "Mod-y",
  redoAlt: "Shift-Mod-z"
};
var name$2 = "history";
function pluginsFactory$1({ historyOpts = {}, keybindings = defaultKeys$1 } = {}) {
  return () => {
    return new PluginGroup(name$2, [
      history(historyOpts),
      keybindings && keymap(createObject([
        [keybindings.undo, undo2()],
        [keybindings.redo, redo2()],
        [keybindings.redoAlt, redo2()]
      ]))
    ]);
  };
}
function undo2() {
  return undo;
}
function redo2() {
  return redo;
}
var history2 = Object.freeze({
  __proto__: null,
  plugins: plugins$1,
  commands: commands$1,
  defaultKeys: defaultKeys$1,
  undo: undo2,
  redo: redo2
});
var spec$1 = specFactory$1;
var plugins = pluginsFactory;
var commands = {
  convertToParagraph,
  jumpToStartOfParagraph,
  jumpToEndOfParagraph,
  queryIsParagraph,
  queryIsTopLevelParagraph,
  insertEmptyParagraphAbove,
  insertEmptyParagraphBelow
};
var defaultKeys = {
  jumpToEndOfParagraph: browser.mac ? "Ctrl-e" : "Ctrl-End",
  jumpToStartOfParagraph: browser.mac ? "Ctrl-a" : "Ctrl-Home",
  moveDown: "Alt-ArrowDown",
  moveUp: "Alt-ArrowUp",
  emptyCopy: "Mod-c",
  emptyCut: "Mod-x",
  insertEmptyParaAbove: "Mod-Shift-Enter",
  insertEmptyParaBelow: "Mod-Enter",
  convertToParagraph: "Ctrl-Shift-0"
};
var name$1 = "paragraph";
function specFactory$1() {
  return {
    type: "node",
    name: name$1,
    schema: {
      content: "inline*",
      group: "block",
      draggable: false,
      parseDOM: [
        {
          tag: "p"
        }
      ],
      toDOM: () => ["p", 0]
    },
    markdown: {
      toMarkdown(state, node) {
        state.renderInline(node);
        state.closeBlock(node);
      },
      parseMarkdown: {
        paragraph: {
          block: "paragraph"
        }
      }
    }
  };
}
function pluginsFactory({ keybindings = defaultKeys } = {}) {
  return ({ schema }) => {
    const type = getParaNodeType(schema);
    const isTopLevel = parentHasDirectParentOfType(type, getNodeType(schema, "doc"));
    return [
      keybindings && keymap(createObject([
        [keybindings.convertToParagraph, convertToParagraph()],
        [keybindings.moveUp, filter(isTopLevel, moveNode(type, "UP"))],
        [keybindings.moveDown, filter(isTopLevel, moveNode(type, "DOWN"))],
        [keybindings.jumpToStartOfParagraph, jumpToStartOfNode(type)],
        [keybindings.jumpToEndOfParagraph, jumpToEndOfNode(type)],
        [keybindings.emptyCopy, filter(isTopLevel, copyEmptyCommand(type))],
        [keybindings.emptyCut, filter(isTopLevel, cutEmptyCommand(type))],
        [
          keybindings.insertEmptyParaAbove,
          filter(isTopLevel, insertEmpty(type, "above"))
        ],
        [
          keybindings.insertEmptyParaBelow,
          filter(isTopLevel, insertEmpty(type, "below"))
        ]
      ]))
    ];
  };
}
function convertToParagraph() {
  return (state, dispatch) => setBlockType(getParaNodeType(state))(state, dispatch);
}
function queryIsTopLevelParagraph() {
  return (state) => {
    const type = getParaNodeType(state);
    return parentHasDirectParentOfType(type, getNodeType(state, "doc"))(state);
  };
}
function queryIsParagraph() {
  return (state) => {
    const type = getParaNodeType(state);
    return Boolean(findParentNodeOfType(type)(state.selection));
  };
}
function insertEmptyParagraphAbove() {
  return (state, dispatch, view) => {
    const type = getParaNodeType(state);
    return filter(parentHasDirectParentOfType(type, getNodeType(state, "doc")), insertEmpty(type, "above"))(state, dispatch, view);
  };
}
function insertEmptyParagraphBelow() {
  return (state, dispatch, view) => {
    const type = getParaNodeType(state);
    return filter(parentHasDirectParentOfType(type, getNodeType(state, "doc")), insertEmpty(type, "below"))(state, dispatch, view);
  };
}
function jumpToStartOfParagraph() {
  return (state, dispatch) => {
    const type = getParaNodeType(state);
    return jumpToStartOfNode(type)(state, dispatch);
  };
}
function jumpToEndOfParagraph() {
  return (state, dispatch) => {
    const type = getParaNodeType(state);
    return jumpToEndOfNode(type)(state, dispatch);
  };
}
var paragraph = Object.freeze({
  __proto__: null,
  spec: spec$1,
  plugins,
  commands,
  defaultKeys,
  convertToParagraph,
  queryIsTopLevelParagraph,
  queryIsParagraph,
  insertEmptyParagraphAbove,
  insertEmptyParagraphBelow,
  jumpToStartOfParagraph,
  jumpToEndOfParagraph
});
var spec = specFactory;
var name = "text";
function specFactory() {
  return {
    type: "node",
    name,
    schema: {
      group: "inline"
    },
    markdown: {
      toMarkdown(state, node) {
        state.text(node.text);
      }
    }
  };
}
var text = Object.freeze({
  __proto__: null,
  spec
});
function pluginLoader(specRegistry, plugins2, { metadata, editorProps, defaultPlugins = true, dropCursorOpts, transformPlugins = (p) => p } = {}) {
  const schema = specRegistry.schema;
  const pluginPayload = {
    schema,
    specRegistry,
    metadata
  };
  let [flatPlugins, pluginGroupNames] = flatten$1(plugins2, pluginPayload);
  if (defaultPlugins) {
    let defaultPluginGroups = [];
    if (!pluginGroupNames.has("history")) {
      defaultPluginGroups.push(plugins$1());
    }
    if (!pluginGroupNames.has("editorStateCounter")) {
      defaultPluginGroups.push(plugins$2());
    }
    flatPlugins = flatPlugins.concat(
      // TODO: deprecate the ability pass a callback to the plugins param of pluginGroup
      flatten$1(defaultPluginGroups, pluginPayload)[0]
    );
    flatPlugins = processInputRules(flatPlugins);
    flatPlugins.push(keymap(baseKeymap), dropCursor(dropCursorOpts), gapCursor());
  }
  if (editorProps) {
    flatPlugins.push(new Plugin({
      props: editorProps
    }));
  }
  flatPlugins = flatPlugins.filter(Boolean);
  flatPlugins = transformPlugins(flatPlugins);
  if (flatPlugins.some((p) => !(p instanceof Plugin))) {
    bangleWarn("You are either using multiple versions of the library or not returning a Plugin class in your plugins. Investigate :", flatPlugins.find((p) => !(p instanceof Plugin)));
    throw new Error("Invalid plugin");
  }
  validateNodeViews(flatPlugins, specRegistry);
  return flatPlugins;
}
function processInputRules(plugins2, { inputRules: inputRules$1 = true, undoInputRule: undoInputRule$1 = true } = {}) {
  let newPlugins = [];
  let match = [];
  plugins2.forEach((plugin) => {
    if (plugin instanceof InputRule) {
      match.push(plugin);
      return;
    }
    newPlugins.push(plugin);
  });
  if (inputRules$1) {
    plugins2 = [
      ...newPlugins,
      inputRules({
        rules: match
      })
    ];
  }
  if (undoInputRule$1) {
    plugins2.push(keymap({
      Backspace: undoInputRule
    }));
  }
  return plugins2;
}
function validateNodeViews(plugins2, specRegistry) {
  const nodeViewPlugins = plugins2.filter((p) => p.props && p.props.nodeViews);
  const nodeViewNames = /* @__PURE__ */ new Map();
  for (const plugin of nodeViewPlugins) {
    for (const name2 of Object.keys(plugin.props.nodeViews)) {
      if (!specRegistry.schema.nodes[name2]) {
        bangleWarn(`When loading your plugins, we found nodeView implementation for the node '${name2}' did not have a corresponding spec. Check the plugin:`, plugin, "and your specRegistry", specRegistry);
        throw new Error(`NodeView validation failed. Spec for '${name2}' not found.`);
      }
      if (nodeViewNames.has(name2)) {
        bangleWarn(`When loading your plugins, we found more than one nodeView implementation for the node '${name2}'. Bangle can only have a single nodeView implementation, please check the following two plugins`, plugin, nodeViewNames.get(name2));
        throw new Error(`NodeView validation failed. Duplicate nodeViews for '${name2}' found.`);
      }
      nodeViewNames.set(name2, plugin);
    }
  }
}
function flatten$1(rawPlugins, callbackPayload) {
  const pluginGroupNames = /* @__PURE__ */ new Set();
  const recurse = (plugins2) => {
    if (Array.isArray(plugins2)) {
      return plugins2.flatMap((p) => recurse(p)).filter(Boolean);
    }
    if (plugins2 instanceof PluginGroup) {
      if (pluginGroupNames.has(plugins2.name)) {
        throw new Error(`Duplicate names of pluginGroups ${plugins2.name} not allowed.`);
      }
      pluginGroupNames.add(plugins2.name);
      return recurse(plugins2.plugins);
    }
    if (typeof plugins2 === "function") {
      if (!callbackPayload) {
        throw new Error("Found a function but no payload");
      }
      return recurse(plugins2(callbackPayload));
    }
    return plugins2;
  };
  return [recurse(rawPlugins), pluginGroupNames];
}
var SpecRegistry = class {
  constructor(rawSpecs = [], { defaultSpecs = true } = {}) {
    let flattenedSpecs = flatten(rawSpecs);
    flattenedSpecs.forEach(validateSpec);
    const names = new Set(flattenedSpecs.map((r) => r.name));
    if (flattenedSpecs.length !== names.size) {
      bangleWarn("The specRegistry has one or more specs with the same name", flattenedSpecs);
      throw new Error("Duplicate spec error, please check your specRegistry");
    }
    if (defaultSpecs) {
      const defaultSpecsArray = [];
      if (!names.has("paragraph")) {
        defaultSpecsArray.unshift(spec$1());
      }
      if (!names.has("text")) {
        defaultSpecsArray.unshift(spec());
      }
      if (!names.has("doc")) {
        defaultSpecsArray.unshift(spec$2());
      }
      flattenedSpecs = [...defaultSpecsArray, ...flattenedSpecs];
    }
    this._spec = flattenedSpecs;
    this._schema = createSchema(this._spec);
    this._options = Object.fromEntries(this._spec.filter((spec2) => spec2.options).map((spec2) => [spec2.name, spec2.options]));
  }
  get options() {
    return this._options;
  }
  get schema() {
    return this._schema;
  }
  get spec() {
    return this._spec;
  }
};
function createSchema(specRegistry) {
  let nodes = [];
  let marks = [];
  let topNode;
  for (const spec2 of specRegistry) {
    if (spec2.type === "node") {
      nodes.push([spec2.name, spec2.schema]);
      if (spec2.topNode === true) {
        topNode = spec2.name;
      }
    } else if (spec2.type === "mark") {
      marks.push([spec2.name, spec2.schema]);
    } else {
      let r = spec2;
      throw new Error("Unknown type: " + r.type);
    }
  }
  return new Schema({
    topNode,
    nodes: Object.fromEntries(nodes),
    marks: Object.fromEntries(marks)
  });
}
function validateSpec(spec2) {
  if (!spec2.name) {
    bangleWarn("The spec didn't have a name field", spec2);
    throw new Error("Invalid spec. Spec must have a name");
  }
  if (!["node", "mark"].includes(spec2.type)) {
    bangleWarn("The spec must be of type node, mark or component ", spec2);
    throw new Error("Invalid spec type");
  }
  if (["node", "mark"].includes(spec2.type) && !spec2.schema) {
    bangleWarn("The spec of type 'mark' or 'node' must have a schema field", spec2);
    throw new Error("Invalid spec schema");
  }
}
function flatten(data) {
  const recurse = (d) => {
    if (Array.isArray(d)) {
      return d.flatMap((i) => recurse(i)).filter((r) => Boolean(r));
    }
    if (d == null || d === false) {
      return [];
    }
    return [d];
  };
  return recurse(data);
}
var BangleEditorState = class {
  constructor({ specRegistry, specs, plugins: plugins2 = () => [], initialValue, editorProps, pmStateOpts, pluginMetadata, dropCursorOpts } = {}) {
    if (specs && specRegistry) {
      throw new Error("Cannot have both specs and specRegistry defined");
    }
    if (!specRegistry) {
      specRegistry = new SpecRegistry(specs);
    }
    if (Array.isArray(plugins2)) {
      console.warn("The use plugins as an array is deprecated, please pass a function which returns an array of plugins. Refer: https://bangle.dev/docs/api/core#bangleeditorstate");
    }
    this.specRegistry = specRegistry;
    const schema = this.specRegistry.schema;
    const pmPlugins = pluginLoader(specRegistry, plugins2, {
      editorProps,
      metadata: pluginMetadata,
      dropCursorOpts
    });
    this.pmState = EditorState.create({
      schema,
      doc: createDocument({ schema, content: initialValue }),
      plugins: pmPlugins,
      ...pmStateOpts
    });
  }
};
var createDocument = ({ schema, content, parseOptions }) => {
  const emptyDocument = {
    type: "doc",
    content: [
      {
        type: "paragraph"
      }
    ]
  };
  if (content == null) {
    return schema.nodeFromJSON(emptyDocument);
  }
  if (content instanceof Node) {
    return content;
  }
  if (typeof content === "object") {
    return schema.nodeFromJSON(content);
  }
  if (typeof content === "string") {
    const element = document.createElement("div");
    element.innerHTML = content.trim();
    return DOMParser.fromSchema(schema).parse(element, parseOptions);
  }
  return void 0;
};
var BangleEditor = class {
  constructor(element, { focusOnInit = true, state, pmViewOpts = {} }) {
    this.destroyed = false;
    if (!(state instanceof BangleEditorState)) {
      throw new Error("state is required and must be an instance of BangleEditorState");
    }
    this.view = new EditorView(element, {
      state: state.pmState,
      dispatchTransaction: (transaction) => {
        const newState = this.view.state.apply(transaction);
        this.view.updateState(newState);
      },
      attributes: { class: "bangle-editor" },
      ...pmViewOpts
    });
    if (focusOnInit) {
      this.focusView();
    }
  }
  destroy() {
    if (this.destroyed) {
      return;
    }
    if (this.view.isDestroyed) {
      this.destroyed = true;
      return;
    }
    this.destroyed = true;
    this.view.destroy();
  }
  focusView() {
    if (isTestEnv || this.view.hasFocus()) {
      return;
    }
    this.view.focus();
  }
  toHTMLString() {
    return toHTMLString(this.view.state);
  }
};
function createElement(spec2) {
  const { dom, contentDOM } = DOMSerializer.renderSpec(window.document, spec2);
  if (contentDOM) {
    throw new Error("createElement does not support creating contentDOM");
  }
  return dom;
}
function domSerializationHelpers(name2, { tag = "div", content, ignoreAttrs = [], parsingPriority = 51 } = {}) {
  const serializer = (node) => JSON.stringify(objectFilter(node.attrs || {}, (_value, key) => !ignoreAttrs.includes(key)));
  return {
    toDOM: (node) => {
      const domSpec = [
        tag,
        {
          "data-bangle-name": name2,
          "data-bangle-attrs": serializer(node)
        }
      ];
      if (content !== void 0) {
        if (typeof content === "function") {
          domSpec.push(content(node));
        } else {
          domSpec.push(content);
        }
      }
      return domSpec;
    },
    parseDOM: [
      {
        priority: parsingPriority,
        tag: `${tag}[data-bangle-name="${name2}"]`,
        getAttrs: (dom) => {
          const attrs = dom.getAttribute("data-bangle-attrs");
          if (!attrs) {
            return {};
          }
          return JSON.parse(attrs);
        }
      }
    ]
  };
}
var renderHandlersCache = /* @__PURE__ */ new WeakMap();
var BaseNodeView = class {
  // for pm to get hold of containerDOM
  constructor({
    node,
    view,
    getPos,
    decorations,
    containerDOM,
    contentDOM,
    // Defaults to whatever is set by the rendering framework which ideally
    // would have called the method `saveRenderHandlers` before this gets
    // executed.
    renderHandlers = getRenderHandlers(view)
  }, { selectionSensitive = true } = {}) {
    this._node = node;
    this._view = view;
    this._getPos = getPos;
    this._decorations = decorations;
    this._selected = false;
    if (!renderHandlers) {
      bangleWarn("It appears the view =", view, " was not associated with renderHandlers. You are either using nodeViews accidentally or have incorrectly setup nodeViews");
      throw new Error("You either did not pass the renderHandlers correct or it cannot find render handlers associated with the view.");
    }
    this.renderHandlers = renderHandlers;
    this.containerDOM = containerDOM;
    this.contentDOM = contentDOM;
    if (this.contentDOM) {
      this.contentDOM.classList.add("bangle-nv-content");
    }
    if (this.containerDOM) {
      this.containerDOM.classList.add("bangle-nv-container");
    }
    if (this._node.type.isAtom && this.contentDOM) {
      throw new Error("An atom node cannot have a contentDOM");
    }
    this.opts = {
      selectionSensitive
    };
    this.renderHandlers.create(this, this.getNodeViewProps());
  }
  // this exists as the name `dom` is too ambiguous
  get dom() {
    return this.containerDOM;
  }
  getAttrs() {
    return this._node.attrs;
  }
  getNodeViewProps() {
    return {
      node: this._node,
      view: this._view,
      getPos: this._getPos,
      decorations: this._decorations,
      selected: this._selected,
      attrs: this._node.attrs,
      updateAttrs: (attrs) => {
        this._view.dispatch(updateAttrs(this._getPos(), this._node, attrs, this._view.state.tr));
      }
    };
  }
};
var NodeView = class _NodeView extends BaseNodeView {
  /**
   * The idea here is to figure out whether your component
   * will be hole-y (will let pm put in contents) or be opaque (example emoji).
   * NOTE: if  passing contentDOM, it is your responsibility to insert it into
   * containerDOM.
   * NOTE: when dealing with renderHandlers like .create or .update
   * donot assume anything about the current state of dom elements. For
   * example, the dom you created in .create handler, may or may not exist,
   * when the .update is called.
   *
   */
  static createPlugin({
    name: name2,
    containerDOM: containerDOMSpec,
    contentDOM: contentDOMSpec,
    // only for components which need to have editable content
    renderHandlers
  }) {
    return new Plugin({
      key: new PluginKey(name2 + "NodeView"),
      props: {
        nodeViews: {
          [name2]: (node, view, getPos, decorations) => {
            const containerDOM = createElement(containerDOMSpec);
            let contentDOM;
            if (contentDOMSpec) {
              contentDOM = createElement(contentDOMSpec);
            }
            return new _NodeView({
              node,
              view,
              getPos,
              decorations,
              containerDOM,
              contentDOM,
              renderHandlers
            });
          }
        }
      }
    });
  }
  deselectNode() {
    this.containerDOM.classList.remove("ProseMirror-selectednode");
    this._selected = false;
    this.renderHandlers.update(this, this.getNodeViewProps());
  }
  // }
  destroy() {
    this.renderHandlers.destroy(this, this.getNodeViewProps());
    this.containerDOM = void 0;
    this.contentDOM = void 0;
  }
  // PM essentially works by watching mutation and then syncing the two states: its own and the DOM.
  ignoreMutation(mutation) {
    if (this._node.type.isAtom) {
      return true;
    }
    if (mutation.type === "selection") {
      return false;
    }
    if (this.containerDOM.contains(mutation.target)) {
      return false;
    }
    if (mutation.target === this.contentDOM) {
      return false;
    }
    return true;
  }
  selectNode() {
    this.containerDOM.classList.add("ProseMirror-selectednode");
    this._selected = true;
    this.renderHandlers.update(this, this.getNodeViewProps());
  }
  update(node, decorations) {
    if (this._node.type !== node.type) {
      return false;
    }
    if (this._node === node && this._decorations === decorations) {
      return true;
    }
    this._node = node;
    this._decorations = decorations;
    this.renderHandlers.update(this, this.getNodeViewProps());
    return true;
  }
};
function saveRenderHandlers(editorContainer, handlers) {
  if (renderHandlersCache.has(editorContainer)) {
    throw new Error("It looks like renderHandlers were already set by someone else.");
  }
  renderHandlersCache.set(editorContainer, handlers);
}
function getRenderHandlers(view) {
  let editorContainer = view.dom.parentNode;
  const handlers = renderHandlersCache.get(editorContainer);
  return handlers;
}
function updateAttrs(pos, node, newAttrs, tr) {
  if (pos === void 0) {
    return tr;
  }
  return tr.setNodeMarkup(pos, void 0, {
    ...node.attrs,
    ...newAttrs
  });
}
var criticalComponents = {
  doc,
  paragraph,
  text,
  history: history2,
  editorStateCounter
};

export {
  copyEmptyCommand,
  cutEmptyCommand,
  parentHasDirectParentOfType,
  moveNode,
  jumpToStartOfNode,
  jumpToEndOfNode,
  doc,
  editorStateCounter,
  history2 as history,
  paragraph,
  text,
  SpecRegistry,
  BangleEditorState,
  BangleEditor,
  createElement,
  domSerializationHelpers,
  NodeView,
  saveRenderHandlers,
  getRenderHandlers,
  criticalComponents
};
//# sourceMappingURL=chunk-HNOPRNJR.js.map
