{
  "version": 3,
  "sources": ["../../../../../../../Users/ted/.yarn/berry/cache/@bangle.dev-collab-comms-npm-0.32.0-ee1eba97bf-10c0.zip/node_modules/@bangle.dev/collab-comms/dist/index.js"],
  "sourcesContent": ["var MessageType;\n(function (MessageType) {\n    MessageType[\"PING\"] = \"PING\";\n    MessageType[\"PONG\"] = \"PONG\";\n    MessageType[\"BROADCAST\"] = \"BROADCAST\";\n})(MessageType || (MessageType = {}));\nclass CollabMessageBus {\n    constructor(_opts = {}) {\n        this._opts = _opts;\n        this._destroyed = false;\n        this._listeners = new Map();\n        this._seenMessages = new WeakSet();\n    }\n    destroy(name) {\n        if (name == null) {\n            this._listeners.clear();\n        }\n        else {\n            this._listeners.delete(name);\n        }\n        this._destroyed = true;\n    }\n    // if name is WILD_CARD, then it will receive every message irrespective of the `to` field.\n    receiveMessages(name, callback) {\n        if (this._destroyed) {\n            return () => { };\n        }\n        let listeners = this._listeners.get(name);\n        if (!listeners) {\n            listeners = new Set();\n            this._listeners.set(name, listeners);\n        }\n        listeners.add(callback);\n        return () => {\n            const listeners = this._listeners.get(name);\n            listeners === null || listeners === void 0 ? void 0 : listeners.delete(callback);\n            if ((listeners === null || listeners === void 0 ? void 0 : listeners.size) === 0) {\n                this._listeners.delete(name);\n            }\n        };\n    }\n    // receive messages that specify the give `name` in the `to` field.\n    transmit(message) {\n        var _a, _b;\n        // ignore message if it has already been seen\n        if (this._seenMessages.has(message)) {\n            return;\n        }\n        if (((_b = (_a = this._opts).debugFilterMessage) === null || _b === void 0 ? void 0 : _b.call(_a, message)) === false) {\n            return;\n        }\n        this._seenMessages.add(message);\n        if (message.type === MessageType.BROADCAST && message.to != null) {\n            throw new Error('Broadcast message must not have a `to` field');\n        }\n        if (typeof message.to !== 'string' &&\n            // @ts-expect-error\n            (message.type === MessageType.PING || message.type === MessageType.PONG)) {\n            throw new Error('PING/PONG message must have a `to` field');\n        }\n        const _transmit = () => {\n            var _a;\n            let targetListeners = message.to\n                ? this._listeners.get(message.to) || new Set()\n                : // if there is no `to` field, then it is a broadcast to all.\n                    // Using a set to prevent duplicates firing of broadcast if same listener is attached\n                    // to multiple `to`s.\n                    new Set([...this._listeners.values()].flatMap((r) => [...r]));\n            // Add listeners which listen to any message\n            let wildcardListeners = this._listeners.get(CollabMessageBus.WILD_CARD) || new Set();\n            // Remove duplicate listeners - a listener should only receive a message once\n            (_a = new Set([...wildcardListeners, ...targetListeners])) === null || _a === void 0 ? void 0 : _a.forEach((listener) => {\n                listener(message);\n            });\n        };\n        if (this._opts.debugSlowdown == null) {\n            _transmit();\n        }\n        else {\n            setTimeout(_transmit, this._opts.debugSlowdown);\n        }\n    }\n}\nCollabMessageBus.WILD_CARD = Symbol('WILD_CARD');\n\n// This is the default value if one it not specified by the consumer.\nconst DEFAULT_MANAGER_ID = '@bangle.dev/collab-manager/MANAGER';\nvar NetworkingError;\n(function (NetworkingError) {\n    NetworkingError[\"Timeout\"] = \"NetworkingError.Timeout\";\n})(NetworkingError || (NetworkingError = {}));\nvar CollabManagerBroadCastType;\n(function (CollabManagerBroadCastType) {\n    CollabManagerBroadCastType[\"NewVersion\"] = \"CollabManagerBroadCastType.NewVersion\";\n    CollabManagerBroadCastType[\"ResetClient\"] = \"CollabManagerBroadCastType.ResetClient\";\n})(CollabManagerBroadCastType || (CollabManagerBroadCastType = {}));\nvar CollabFail;\n(function (CollabFail) {\n    CollabFail[\"ApplyFailed\"] = \"CollabFail.ApplyFailed\";\n    CollabFail[\"DocumentNotFound\"] = \"CollabFail.DocumentNotFound\";\n    CollabFail[\"HistoryNotAvailable\"] = \"CollabFail.HistoryNotAvailable\";\n    CollabFail[\"IncorrectManager\"] = \"CollabFail.IncorrectManager\";\n    CollabFail[\"InvalidVersion\"] = \"CollabFail.InvalidVersion\";\n    CollabFail[\"ManagerDestroyed\"] = \"CollabFail.ManagerDestroyed\";\n    CollabFail[\"OutdatedVersion\"] = \"CollabFail.OutdatedVersion\";\n    CollabFail[\"ManagerUnresponsive\"] = \"CollabFail.ManagerUnresponsive\";\n})(CollabFail || (CollabFail = {}));\nvar CollabClientRequestType;\n(function (CollabClientRequestType) {\n    CollabClientRequestType[\"GetDocument\"] = \"CollabClientRequestType.GetDocument\";\n    CollabClientRequestType[\"PullEvents\"] = \"CollabClientRequestType.PullEvents\";\n    CollabClientRequestType[\"PushEvents\"] = \"CollabClientRequestType.PushEvents\";\n})(CollabClientRequestType || (CollabClientRequestType = {}));\n\nconst DEFAULT_TIMEOUT = 1000;\n// wraps the message in a request form - ie sends the message and waits for a response\n// if it doesn't get any response within the `requestTimeout`, rejects with a  NetworkingError.Timeout\nfunction wrapRequest(payload, { emitter, to, from, requestTimeout = DEFAULT_TIMEOUT, }) {\n    return new Promise((res, rej) => {\n        const id = generateUUID();\n        // NOTE: the field `id` of a PONG message will be the same as the PING message\n        const removeListener = emitter.receiveMessages(from, (message) => {\n            if (message.type !== MessageType.PONG || message.id !== id) {\n                return;\n            }\n            clearTimeout(timer);\n            removeListener();\n            return res(message.messageBody);\n        });\n        const timer = setTimeout(() => {\n            removeListener();\n            rej(new Error(NetworkingError.Timeout));\n        }, requestTimeout);\n        emitter.transmit({\n            to,\n            from,\n            id,\n            messageBody: payload,\n            type: MessageType.PING,\n        });\n    });\n}\nfunction generateUUID() {\n    return (Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16) +\n        '-' +\n        Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16) +\n        '-' +\n        Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16));\n}\n\nclass ClientCommunication {\n    constructor(_opts) {\n        var _a;\n        this._opts = _opts;\n        this.getDocument = (body) => {\n            let request = {\n                type: CollabClientRequestType.GetDocument,\n                body,\n            };\n            return this._wrapRequest(CollabClientRequestType.GetDocument, request);\n        };\n        this.pullEvents = (body) => {\n            const request = {\n                type: CollabClientRequestType.PullEvents,\n                body,\n            };\n            return this._wrapRequest(CollabClientRequestType.PullEvents, request);\n        };\n        this.pushEvents = (body) => {\n            const request = {\n                type: CollabClientRequestType.PushEvents,\n                body,\n            };\n            return this._wrapRequest(CollabClientRequestType.PushEvents, request);\n        };\n        this.managerId = this._opts.managerId;\n        const removeListener = (_a = this._opts.messageBus) === null || _a === void 0 ? void 0 : _a.receiveMessages(this._opts.clientId, (message) => {\n            if (message.type !== MessageType.BROADCAST &&\n                message.from !== this.managerId) {\n                return;\n            }\n            const messageBody = message.messageBody;\n            const { type } = messageBody;\n            // ignore any message that is not for the current doc\n            if (messageBody.body.docName !== this._opts.docName) {\n                return;\n            }\n            switch (type) {\n                case CollabManagerBroadCastType.NewVersion: {\n                    this._opts.onNewVersion(messageBody.body);\n                    return;\n                }\n                case CollabManagerBroadCastType.ResetClient: {\n                    this._opts.onResetClient(messageBody.body);\n                    return;\n                }\n                default: {\n                    throw new Error(`Unknown message type: ${type}`);\n                }\n            }\n        });\n        this._opts.signal.addEventListener('abort', () => {\n            removeListener();\n        }, { once: true });\n    }\n    async _wrapRequest(type, request) {\n        try {\n            return (await wrapRequest(request, {\n                from: this._opts.clientId,\n                to: this.managerId,\n                emitter: this._opts.messageBus,\n                requestTimeout: this._opts.requestTimeout,\n            }));\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                const message = error.message;\n                switch (message) {\n                    case NetworkingError.Timeout: {\n                        return {\n                            body: CollabFail.ManagerUnresponsive,\n                            type,\n                            ok: false,\n                        };\n                    }\n                    default: {\n                        throw error;\n                    }\n                }\n            }\n            throw error;\n        }\n    }\n}\n\nclass ManagerCommunication {\n    constructor(managerId, _collabMessageBus, handleRequest, signal) {\n        this.managerId = managerId;\n        this._collabMessageBus = _collabMessageBus;\n        const removeListener = this._collabMessageBus.receiveMessages(managerId, async (message) => {\n            // handle only PING message\n            // since manager needs to respond them: PING -> PONG\n            if (message.type !== MessageType.PING) {\n                return;\n            }\n            const { id, messageBody } = message;\n            let requestBody = messageBody || {};\n            switch (requestBody.type) {\n                case CollabClientRequestType.GetDocument:\n                case CollabClientRequestType.PullEvents:\n                case CollabClientRequestType.PushEvents: {\n                    // TODO handle error\n                    let response = await handleRequest(requestBody, id);\n                    this._collabMessageBus.transmit({\n                        from: managerId,\n                        to: message.from,\n                        type: MessageType.PONG,\n                        id: id,\n                        messageBody: response,\n                    });\n                    break;\n                }\n            }\n        });\n        signal.addEventListener('abort', () => {\n            removeListener();\n        }, { once: true });\n    }\n    broadcast(messageBody) {\n        this._collabMessageBus.transmit({\n            from: this.managerId,\n            to: undefined,\n            type: MessageType.BROADCAST,\n            id: generateUUID(),\n            messageBody: messageBody,\n        });\n    }\n}\n\nexport { ClientCommunication, CollabClientRequestType, CollabFail, CollabManagerBroadCastType, CollabMessageBus, DEFAULT_MANAGER_ID, ManagerCommunication, MessageType, NetworkingError };\n"],
  "mappings": "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",
  "names": ["MessageType", "listeners", "_a", "NetworkingError", "CollabManagerBroadCastType", "CollabFail", "CollabClientRequestType"]
}
