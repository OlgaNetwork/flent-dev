import {
  CollabClientRequestType,
  CollabFail,
  CollabManagerBroadCastType,
  DEFAULT_MANAGER_ID,
  ManagerCommunication
} from "./chunk-SNN6MBEY.js";
import {
  Either,
  isTestEnv
} from "./chunk-F3Z2TPKG.js";
import {
  Step
} from "./chunk-ZRMAPHIN.js";
import "./chunk-NVKSN2QT.js";
import "./chunk-AUZ3RYOM.js";

// .yarn/__virtual__/@bangle.dev-collab-manager-virtual-8ea5fe4a98/5/Users/ted/.yarn/berry/cache/@bangle.dev-collab-manager-npm-0.32.0-54ed9924ce-10c0.zip/node_modules/@bangle.dev/collab-manager/dist/index.js
var MAX_STEP_HISTORY = 1e3;
var LOG$1 = true;
var log$1 = (isTestEnv ? false : LOG$1) ? console.debug.bind(console, "collab-manager/state:") : () => {
};
var CollabServerState = class _CollabServerState {
  constructor(doc, steps = [], version = 0) {
    this.doc = doc;
    this.steps = steps;
    this.version = version;
    if (steps.length > MAX_STEP_HISTORY) {
      this.steps = steps.slice(steps.length - MAX_STEP_HISTORY);
    }
  }
  static addEvents(state, version, steps, clientID) {
    if (_CollabServerState.isInvalidVersion(state, version)) {
      return Either.left(CollabFail.InvalidVersion);
    }
    const biggerSteps = steps.map((s) => Object.assign(s, { clientID }));
    if (state.version !== version) {
      return Either.left(CollabFail.OutdatedVersion);
    }
    let newDoc = state.doc;
    const maps = [];
    for (const step of biggerSteps) {
      let result;
      try {
        result = step.apply(newDoc);
      } catch (error) {
        console.error(error);
        return Either.left(CollabFail.ApplyFailed);
      }
      if (result.doc == null) {
        return Either.left(CollabFail.ApplyFailed);
      }
      newDoc = result.doc;
      maps.push(step.getMap());
    }
    const newVersion = state.version + biggerSteps.length;
    const newSteps = state.steps.concat(biggerSteps);
    log$1(`${clientID}: addEvents version=${newVersion}`);
    return Either.right(new _CollabServerState(newDoc, newSteps, newVersion));
  }
  static getEvents(collabState, version) {
    if (_CollabServerState.isInvalidVersion(collabState, version)) {
      return Either.left(CollabFail.InvalidVersion);
    }
    let startIndex = collabState.steps.length - (collabState.version - version);
    if (startIndex < 0) {
      return Either.left(CollabFail.HistoryNotAvailable);
    }
    return Either.right({
      version: collabState.version,
      steps: collabState.steps.slice(startIndex)
    });
  }
  static isInvalidVersion(collabState, version) {
    return version < 0 || version > collabState.version;
  }
};
var maxNoOfPendingRecords = 100;
var InstanceDeleteGuard = class {
  constructor(opts) {
    this.opts = opts;
    this.pendingDeleteRecord = /* @__PURE__ */ new Map();
    if (this.opts.deleteWaitTime >= this.opts.maxDurationToKeepRecord) {
      throw new Error("deleteWaitTime must be less than maxDurationToKeepRecord");
    }
  }
  addPendingDelete(docName, deleteCallback) {
    var _a;
    (_a = this.pendingDeleteRecord.get(docName)) === null || _a === void 0 ? void 0 : _a.abortDelete.abort();
    const abortController = new AbortController();
    this.pendingDeleteRecord.set(docName, {
      deleteTime: Date.now(),
      abortDelete: abortController
    });
    abortableSetTimeout(deleteCallback, abortController.signal, this.opts.deleteWaitTime);
    this.containSize();
  }
  /**
   * Guard to ensure client is not accessing an instance that is about to be deleted or is deleted
   */
  checkAccess(docName, clientCreatedAt) {
    const record = this.pendingDeleteRecord.get(docName);
    if (!record) {
      return true;
    }
    if (clientCreatedAt > record.deleteTime) {
      record.abortDelete.abort();
      return true;
    }
    return false;
  }
  containSize() {
    const timeNow = Date.now();
    let sorted = Array.from(this.pendingDeleteRecord.entries()).filter((item) => {
      return timeNow - item[1].deleteTime <= this.opts.maxDurationToKeepRecord;
    });
    if (sorted.length > maxNoOfPendingRecords) {
      sorted = sorted.sort((a, b) => {
        return b[1].deleteTime - a[1].deleteTime;
      }).slice(0, maxNoOfPendingRecords);
    }
    this.pendingDeleteRecord = new Map(sorted);
  }
  destroy() {
    this.pendingDeleteRecord.forEach((item) => {
      item.abortDelete.abort();
    });
    this.pendingDeleteRecord.clear();
  }
};
function abortableSetTimeout(callback, signal, ms) {
  const timer = setTimeout(callback, ms);
  signal.addEventListener("abort", () => {
    clearTimeout(timer);
  }, { once: true });
}
var LOG = true;
var log = (isTestEnv ? false : LOG) ? console.debug.bind(console, "collab-manager:") : () => {
};
var CollabManager = class {
  constructor(_options) {
    this._options = _options;
    this._abortController = new AbortController();
    this._handleRequest = async (request, id) => {
      if (!this._instanceDeleteGuard.checkAccess(request.body.docName, request.body.clientCreatedAt)) {
        return {
          ok: false,
          body: CollabFail.HistoryNotAvailable,
          type: request.type
        };
      }
      log(`id=${id} userId=${request.body.userId} received request=${request.type}, `);
      switch (request.type) {
        case CollabClientRequestType.GetDocument: {
          return this._handleGetDocument(request, id);
        }
        case CollabClientRequestType.PullEvents: {
          return this._handlePullEvents(request, id);
        }
        case CollabClientRequestType.PushEvents: {
          return this._handlePushEvents(request, id);
        }
        default: {
          throw new Error("Unknown request type");
        }
      }
    };
    this._instances = /* @__PURE__ */ new Map();
    this.managerId = _options.managerId || DEFAULT_MANAGER_ID;
    this._serverCom = new ManagerCommunication(this.managerId, _options.collabMessageBus, this._handleRequest, this._abortController.signal);
    this._instanceDeleteGuard = new InstanceDeleteGuard(this._options.instanceDeleteGuardOpts || {
      deleteWaitTime: 500,
      maxDurationToKeepRecord: 1e3 * 60
    });
  }
  destroy() {
    this._abortController.abort();
    this._instanceDeleteGuard.destroy();
  }
  getAllDocNames() {
    return new Set(this._instances.keys());
  }
  getCollabState(docName) {
    var _a;
    return (_a = this._instances.get(docName)) === null || _a === void 0 ? void 0 : _a.collabState;
  }
  isDestroyed() {
    return this._abortController.signal.aborted;
  }
  // Requests deletion of instance after a delay if no new clients
  // attempt to connect to the given `docName`. Tweak opts.instanceDeleteGuardOpts
  requestDeleteInstance(docName) {
    if (this.isDestroyed()) {
      return;
    }
    this._instanceDeleteGuard.addPendingDelete(docName, () => {
      this._instances.delete(docName);
    });
  }
  // removes collab state entry associated with docName.
  // And broadcast to any client with the docName (if any exists)
  // to reset its content and do a fresh fetch of the document.
  // WARNING: this is a destructive operation and will result
  // in loss of any un-pushed client data.
  resetDoc(docName) {
    this._instances.delete(docName);
    this._serverCom.broadcast({
      type: CollabManagerBroadCastType.ResetClient,
      body: {
        docName
      }
    });
  }
  async _createInstance(docName) {
    const initialCollabState = await this._options.getInitialState(docName);
    let instance = this._instances.get(docName);
    if (instance) {
      return Either.right(instance);
    }
    if (!initialCollabState) {
      return Either.left(CollabFail.DocumentNotFound);
    }
    instance = new Instance(docName, this._options.schema, initialCollabState, this._options.applyState);
    this._instances.set(docName, instance);
    return Either.right(instance);
  }
  /**
   * Get an instance of a document or creates a new one
   * if none exists.
   * @param docName
   * @returns
   */
  async _getInstance(docName) {
    const instance = this._instances.get(docName);
    if (instance) {
      instance.lastActive = Date.now();
      return Either.right(instance);
    }
    return this._createInstance(docName);
  }
  async _handleGetDocument(request, uid) {
    const work = (instance) => {
      return {
        doc: instance.collabState.doc.toJSON(),
        users: instance.userCount,
        version: instance.collabState.version,
        managerId: this.managerId
      };
    };
    return this._toResponse(Either.map(await this._getInstance(request.body.docName), work), request.type);
  }
  async _handlePullEvents(request, uid) {
    const work = (instance) => {
      if (this.managerId !== request.body.managerId) {
        return Either.left(CollabFail.IncorrectManager);
      }
      return instance.getEvents(request.body);
    };
    return this._toResponse(Either.flatMap(await this._getInstance(request.body.docName), work), request.type);
  }
  async _handlePushEvents(request, uid) {
    const work = (instance) => {
      const { type, body } = request;
      if (this.managerId !== body.managerId) {
        return Either.left(CollabFail.IncorrectManager);
      }
      const result = instance.addEvents(body);
      if (Either.isRight(result)) {
        queueMicrotask(() => {
          this._serverCom.broadcast({
            type: CollabManagerBroadCastType.NewVersion,
            body: {
              docName: instance.docName,
              version: instance.collabState.version
            }
          });
        });
      }
      return result;
    };
    return this._toResponse(Either.flatMap(await this._getInstance(request.body.docName), work), request.type);
  }
  _toResponse(val, requestType) {
    if (Either.isLeft(val)) {
      return {
        ok: false,
        body: val.left,
        type: requestType
      };
    } else {
      return {
        ok: true,
        body: val.right,
        type: requestType
      };
    }
  }
};
var Instance = class {
  constructor(docName, schema, _collabState, _applyState = (docName2, newCollabState, oldCollabState) => {
    return true;
  }) {
    this.docName = docName;
    this.schema = schema;
    this._collabState = _collabState;
    this._applyState = _applyState;
    this.lastActive = Date.now();
  }
  get collabState() {
    return this._collabState;
  }
  // TODO add userCount
  get userCount() {
    return 1;
  }
  addEvents({ clientID, version: rawVersion, steps, userId, docName }) {
    this.lastActive = Date.now();
    let version = nonNegInteger(rawVersion);
    if (version === void 0) {
      return Either.left(CollabFail.InvalidVersion);
    }
    const parsedSteps = steps.map((s) => Step.fromJSON(this.schema, s));
    return Either.flatMap(CollabServerState.addEvents(this._collabState, version, parsedSteps, clientID), (collabState) => {
      if (this._applyState(docName, collabState, this._collabState)) {
        this._collabState = collabState;
      } else {
        return Either.left(CollabFail.ApplyFailed);
      }
      return Either.right({
        empty: null
      });
    });
  }
  getEvents({ docName, version, userId, managerId }) {
    return Either.map(CollabServerState.getEvents(this._collabState, version), (events) => {
      return {
        version: events.version,
        steps: events.steps.map((step) => step.toJSON()),
        clientIDs: events.steps.map((step) => step.clientID),
        users: this.userCount
        // TODO
      };
    });
  }
};
function nonNegInteger(str) {
  let num = Number(str);
  if (!isNaN(num) && Math.floor(num) === num && num >= 0) {
    return num;
  }
  return void 0;
}
export {
  CollabManager,
  CollabServerState,
  MAX_STEP_HISTORY
};
//# sourceMappingURL=@bangle__dev_collab-manager.js.map
