{
  "version": 3,
  "sources": ["../../../.yarn/__virtual__/@bangle.dev-base-components-virtual-b31c872be8/5/Users/ted/.yarn/berry/cache/@bangle.dev-base-components-npm-0.32.0-80687f67c3-10c0.zip/node_modules/@bangle.dev/base-components/dist/index.js"],
  "sourcesContent": ["import { wrappingInputRule, keymap, wrapIn, toggleMark, InputRule, findWrapping, canJoin, TextSelection, ReplaceAroundStep, Slice, Fragment, NodeRange, liftTarget, NodeSelection, autoJoin, wrapInList as wrapInList$1, sinkListItem, liftListItem as liftListItem$1, chainCommands, Selection, textblockTypeInputRule, setBlockType, exitCode, Plugin, PluginKey } from '@bangle.dev/pm';\nimport { moveNode, copyEmptyCommand, cutEmptyCommand, parentHasDirectParentOfType, jumpToStartOfNode, jumpToEndOfNode } from '@bangle.dev/pm-commands';\nimport { getNodeType, createObject, findParentNodeOfType, filter, getParaNodeType, insertEmpty, markPasteRule as markPasteRule$1, markInputRule, assertNotUndefined, isMarkActiveInSelection, getListLiftTarget, isRangeOfType, sanitiseSelectionMarksForWrapping, extendDispatch, flatten, compose, isEmptySelectionAtStart, isFirstChildOfParent, hasVisibleContent, isNodeEmpty, hasParentNodeOfType, GapCursorSelection, findCutBefore, findPositionOfNodeBefore, findParentNode, validListParent, validPos, safeInsert, browser, findChildren, getMarkAttrs, matchAllPlus, mapSlice, createElement, domSerializationHelpers } from '@bangle.dev/utils';\nimport { NodeView } from '@bangle.dev/core';\nexport { doc, editorStateCounter, history, paragraph, text } from '@bangle.dev/core';\n\nconst spec$e = specFactory$e;\nconst plugins$e = pluginsFactory$e;\nconst commands$c = {\n    queryIsBlockquoteActive,\n    wrapInBlockquote,\n};\nconst defaultKeys$b = {\n    wrapIn: 'Ctrl-ArrowRight',\n    moveDown: 'Alt-ArrowDown',\n    moveUp: 'Alt-ArrowUp',\n    emptyCopy: 'Mod-c',\n    emptyCut: 'Mod-x',\n    insertEmptyParaAbove: 'Mod-Shift-Enter',\n    insertEmptyParaBelow: 'Mod-Enter',\n};\nconst name$e = 'blockquote';\nfunction specFactory$e() {\n    return {\n        type: 'node',\n        name: name$e,\n        schema: {\n            content: 'block*',\n            group: 'block',\n            defining: true,\n            draggable: false,\n            parseDOM: [{ tag: 'blockquote' }],\n            toDOM: () => {\n                return ['blockquote', 0];\n            },\n        },\n        markdown: {\n            toMarkdown: (state, node) => {\n                state.wrapBlock('> ', null, node, () => state.renderContent(node));\n            },\n            parseMarkdown: {\n                blockquote: {\n                    block: name$e,\n                },\n            },\n        },\n    };\n}\nfunction pluginsFactory$e({ markdownShortcut = true, keybindings = defaultKeys$b, } = {}) {\n    return ({ schema }) => {\n        const type = getNodeType(schema, name$e);\n        return [\n            markdownShortcut && wrappingInputRule(/^\\s*>\\s$/, type),\n            keybindings &&\n                keymap(createObject([\n                    [keybindings.wrapIn, wrapInBlockquote()],\n                    [keybindings.moveUp, moveNode(type, 'UP')],\n                    [keybindings.moveDown, moveNode(type, 'DOWN')],\n                    [keybindings.emptyCopy, copyEmptyCommand(type)],\n                    [keybindings.emptyCut, cutEmptyCommand(type)],\n                    [keybindings.insertEmptyParaAbove, insertEmptyParaAbove$1()],\n                    [keybindings.insertEmptyParaBelow, insertEmptyParaBelow$1()],\n                ])),\n        ];\n    };\n}\nfunction queryIsBlockquoteActive() {\n    return (state) => {\n        const type = getNodeType(state, name$e);\n        return Boolean(findParentNodeOfType(type)(state.selection));\n    };\n}\nfunction wrapInBlockquote() {\n    return filter((state) => !queryIsBlockquoteActive()(state), (state, dispatch, _view) => {\n        const type = getNodeType(state, name$e);\n        return wrapIn(type)(state, dispatch);\n    });\n}\nfunction insertEmptyParaAbove$1() {\n    const isInBlockquote = queryIsBlockquoteActive();\n    return (state, dispatch, view) => {\n        const para = getParaNodeType(state);\n        return filter(isInBlockquote, insertEmpty(para, 'above', true))(state, dispatch, view);\n    };\n}\nfunction insertEmptyParaBelow$1() {\n    const isInBlockquote = queryIsBlockquoteActive();\n    return (state, dispatch, view) => {\n        const para = getParaNodeType(state);\n        return filter(isInBlockquote, insertEmpty(para, 'below', true))(state, dispatch, view);\n    };\n}\n\nvar blockquote = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec$e,\n    plugins: plugins$e,\n    commands: commands$c,\n    defaultKeys: defaultKeys$b,\n    queryIsBlockquoteActive: queryIsBlockquoteActive,\n    wrapInBlockquote: wrapInBlockquote,\n    insertEmptyParaAbove: insertEmptyParaAbove$1,\n    insertEmptyParaBelow: insertEmptyParaBelow$1\n});\n\nconst spec$d = specFactory$d;\nconst plugins$d = pluginsFactory$d;\nconst commands$b = {\n    toggleBold,\n    queryIsBoldActive,\n};\nconst defaultKeys$a = {\n    toggleBold: 'Mod-b',\n};\nconst name$d = 'bold';\nconst getTypeFromSchema$5 = (schema) => {\n    const markType = schema.marks[name$d];\n    assertNotUndefined(markType, `markType ${name$d} not found`);\n    return markType;\n};\nfunction specFactory$d() {\n    return {\n        type: 'mark',\n        name: name$d,\n        schema: {\n            parseDOM: [\n                {\n                    tag: 'strong',\n                },\n                {\n                    tag: 'b',\n                    // making node any type as there is some problem with pm-model types\n                    getAttrs: (node) => node.style.fontWeight !== 'normal' && null,\n                },\n                {\n                    style: 'font-weight',\n                    getAttrs: (value) => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null,\n                },\n            ],\n            toDOM: () => ['strong', 0],\n        },\n        markdown: {\n            toMarkdown: {\n                open: '**',\n                close: '**',\n                mixable: true,\n                expelEnclosingWhitespace: true,\n            },\n            parseMarkdown: {\n                strong: { mark: name$d },\n            },\n        },\n    };\n}\nfunction pluginsFactory$d({ markdownShortcut = true, keybindings = defaultKeys$a, } = {}) {\n    return ({ schema }) => {\n        const type = getTypeFromSchema$5(schema);\n        return [\n            markdownShortcut &&\n                markPasteRule$1(/(?:^|\\s)((?:\\*\\*)((?:[^*]+))(?:\\*\\*))/g, type),\n            markdownShortcut &&\n                markPasteRule$1(/(?:^|\\s)((?:__)((?:[^__]+))(?:__))/g, type),\n            markdownShortcut &&\n                markInputRule(/(?:^|\\s)((?:__)((?:[^__]+))(?:__))$/, type),\n            markdownShortcut &&\n                markInputRule(/(?:^|\\s)((?:\\*\\*)((?:[^*]+))(?:\\*\\*))$/, type),\n            keybindings &&\n                keymap(createObject([[keybindings.toggleBold, toggleBold()]])),\n        ];\n    };\n}\nfunction toggleBold() {\n    return (state, dispatch, _view) => {\n        const markType = state.schema.marks[name$d];\n        assertNotUndefined(markType, `markType ${name$d} not found`);\n        return toggleMark(markType)(state, dispatch);\n    };\n}\nfunction queryIsBoldActive() {\n    return (state) => {\n        const markType = state.schema.marks[name$d];\n        assertNotUndefined(markType, `markType ${name$d} not found`);\n        return isMarkActiveInSelection(markType)(state);\n    };\n}\n\nvar bold = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec$d,\n    plugins: plugins$d,\n    commands: commands$b,\n    defaultKeys: defaultKeys$a,\n    toggleBold: toggleBold,\n    queryIsBoldActive: queryIsBoldActive\n});\n\nconst isNodeTodo = (node, schema) => {\n    return (node.type === getNodeType(schema, 'listItem') &&\n        typeof node.attrs['todoChecked'] === 'boolean');\n};\n/**\n * remove todoChecked attribute from a listItem\n * no-op if not listitem\n * @param {*} tr\n * @param {*} schema\n * @param {*} node\n * @param {*} pos\n */\nconst removeTodoCheckedAttr = (tr, schema, node, pos) => {\n    if (isNodeTodo(node, schema)) {\n        tr = tr.setNodeMarkup(pos, undefined, Object.assign({}, node.attrs, { todoChecked: null }));\n    }\n    return tr;\n};\n/**\n * set todoChecked attribute to a listItem\n * no-op if not listitem or if already todo\n * @param {*} tr\n * @param {*} schema\n * @param {*} node\n * @param {*} pos\n */\nconst setTodoCheckedAttr = (tr, schema, node, pos) => {\n    if (node.type === getNodeType(schema, 'listItem') &&\n        !isNodeTodo(node, schema)) {\n        tr = tr.setNodeMarkup(pos, undefined, Object.assign({}, node.attrs, { todoChecked: false }));\n    }\n    return tr;\n};\n/**\n * A command to remove the todoChecked attribute (if any) to nodes in and around of the\n * selection. Uses the rules of siblingsAndNodesBetween to shortlist the nodes.\n * If no nodes with todoChecked attr are found returns false otherwise true\n */\nconst removeTodo = filter([isSelectionParentBulletList, (state) => todoCount(state).todos !== 0], (state, dispatch) => {\n    const { schema } = state;\n    let tr = state.tr;\n    siblingsAndNodesBetween(state, (node, pos) => {\n        tr = removeTodoCheckedAttr(tr, schema, node, pos);\n    });\n    if (dispatch) {\n        dispatch(tr);\n    }\n    return true;\n});\n/**\n * A command to set the todoChecked attribute to nodes in and around of the\n * selection. Uses the rules of siblingsAndNodesBetween to shortlist the nodes.\n * If all nodes are already having todoChecked attr returns false otherwise true\n */\nconst setTodo = filter([\n    isSelectionParentBulletList,\n    (state) => {\n        const { todos, lists } = todoCount(state);\n        // If all the list items are todo or none of them are todo\n        // return false so we can run the vanilla toggleList\n        return todos !== lists;\n    },\n], (state, dispatch) => {\n    let { tr, schema } = state;\n    siblingsAndNodesBetween(state, (node, pos) => {\n        tr = setTodoCheckedAttr(tr, schema, node, pos);\n    });\n    if (dispatch) {\n        dispatch(tr);\n    }\n    return true;\n});\n// Alteration of PM's wrappingInputRule\nfunction wrappingInputRuleForTodo(regexp, getAttrs) {\n    return new InputRule(regexp, function (state, match, start, end) {\n        const nodeType = getNodeType(state, 'listItem');\n        var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        var tr = state.tr.delete(start, end);\n        var $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs);\n        if (!wrapping) {\n            return null;\n        }\n        tr.wrap(range, wrapping);\n        var before = tr.doc.resolve(start - 1).nodeBefore;\n        if (before &&\n            before.type === getNodeType(state, 'bulletList') &&\n            canJoin(tr.doc, start - 1) &&\n            before.lastChild &&\n            // only join if before is todo\n            isNodeTodo(before.lastChild, state.schema)) {\n            tr.join(start - 1);\n        }\n        return tr;\n    });\n}\n/**\n * given a bullet/ordered list it will call callback for each node\n *  which\n *    - strictly lies inside the range provided\n *    - nodes that are sibblings of the top level nodes\n *      which lie in the range.\n *\n * Example\n *         <ul>\n *              <li>[A\n *                 <list-A's kids/>\n *              </li>\n *              <li><B]></li>\n *              <li><C></li>\n *              <li>D <list-D's kids </li>\n *           </ul>\n *\n * In the above the callback will be called for everyone\n *  A, list-A's kids, B, C, D _but_ not list-D's kids.\n */\nfunction siblingsAndNodesBetween(state, callback) {\n    const { schema, selection: { $from, $to }, } = state;\n    const range = $from.blockRange($to, (node) => node.childCount > 0 &&\n        node.firstChild.type === getNodeType(schema, 'listItem'));\n    if (!range) {\n        return;\n    }\n    const { parent, startIndex, endIndex } = range;\n    // NOTE: this gets us to start pos inside of the parent bullet list\n    //        <ul>{} <nth-item> ..[.]. </nth-item></ul>\n    //        {} - is the pos of offset\n    let startPos = range.$from.start(range.depth);\n    for (let i = 0; i < parent.childCount; i++) {\n        const child = parent.child(i);\n        callback(child, startPos);\n        // also call callback for children of nodes\n        // that lie inside the selection\n        if (i >= startIndex && i < endIndex - 1) {\n            child.nodesBetween(0, child.content.size, callback, startPos + 1);\n        }\n        startPos += child.nodeSize;\n    }\n    return;\n}\nfunction isSelectionParentBulletList(state) {\n    const { selection } = state;\n    const fromNode = selection.$from.node(-2);\n    const endNode = selection.$to.node(-2);\n    return (fromNode &&\n        fromNode.type === getNodeType(state, 'bulletList') &&\n        endNode &&\n        endNode.type === getNodeType(state, 'bulletList'));\n}\nfunction todoCount(state) {\n    let lists = 0;\n    let todos = 0;\n    const { schema } = state;\n    siblingsAndNodesBetween(state, (node, _pos) => {\n        // TODO it might create problem by counting ol 's listItem?\n        if (node.type === getNodeType(schema, 'listItem')) {\n            lists++;\n        }\n        if (isNodeTodo(node, schema)) {\n            todos++;\n        }\n    });\n    return {\n        lists: lists,\n        todos: todos,\n    };\n}\n\nfunction liftListItem(type, state, selection, tr) {\n    let { $from, $to } = selection;\n    let listItem = type;\n    if (!listItem) {\n        listItem = getNodeType(state, 'listItem');\n    }\n    let range = $from.blockRange($to, (node) => !!node.childCount &&\n        !!node.firstChild &&\n        node.firstChild.type === listItem);\n    if (!range ||\n        range.depth < 2 ||\n        $from.node(range.depth - 1).type !== listItem) {\n        return tr;\n    }\n    let end = range.end;\n    let endOfList = $to.end(range.depth);\n    if (end < endOfList) {\n        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(listItem.create(undefined, range.parent.copy())), 1, 0), 1, true));\n        range = new NodeRange(tr.doc.resolve($from.pos), tr.doc.resolve(endOfList), range.depth);\n    }\n    return tr.lift(range, liftTarget(range)).scrollIntoView();\n}\n// Function will lift list item following selection to level-1.\nfunction liftFollowingList(type, state, from, to, rootListDepth, tr) {\n    let listItem = type;\n    if (!listItem) {\n        listItem = getNodeType(state, 'listItem');\n    }\n    let lifted = false;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (!lifted && node.type === listItem && pos > from) {\n            lifted = true;\n            let listDepth = rootListDepth + 3;\n            while (listDepth > rootListDepth + 2) {\n                const start = tr.doc.resolve(tr.mapping.map(pos));\n                listDepth = start.depth;\n                const end = tr.doc.resolve(tr.mapping.map(pos + node.content.size));\n                const sel = new TextSelection(start, end);\n                tr = liftListItem(listItem, state, sel, tr);\n            }\n        }\n    });\n    return tr;\n}\n// The function will list paragraphs in selection out to level 1 below root list.\nfunction liftSelectionList(type, state, tr) {\n    const { from, to } = state.selection;\n    const { paragraph } = state.schema.nodes;\n    const listCol = [];\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (node.type === paragraph) {\n            listCol.push({ node, pos });\n        }\n    });\n    for (let i = listCol.length - 1; i >= 0; i--) {\n        const paragraph = listCol[i];\n        const start = tr.doc.resolve(tr.mapping.map(paragraph.pos));\n        if (start.depth > 0) {\n            let end;\n            if (paragraph.node.textContent && paragraph.node.textContent.length > 0) {\n                end = tr.doc.resolve(tr.mapping.map(paragraph.pos + paragraph.node.textContent.length));\n            }\n            else {\n                end = tr.doc.resolve(tr.mapping.map(paragraph.pos + 1));\n            }\n            const range = start.blockRange(end);\n            if (range) {\n                tr.lift(range, getListLiftTarget(type, state.schema, start));\n            }\n        }\n    }\n    return tr;\n}\n\nconst maxIndentation = 4;\n// Returns the number of nested lists that are ancestors of the given selection\nconst numberNestedLists = (resolvedPos, nodes) => {\n    const { bulletList, orderedList } = nodes;\n    let count = 0;\n    for (let i = resolvedPos.depth - 1; i > 0; i--) {\n        const node = resolvedPos.node(i);\n        if (node.type === bulletList || node.type === orderedList) {\n            count += 1;\n        }\n    }\n    return count;\n};\nconst isInsideList = (state, listType) => {\n    const { $from } = state.selection;\n    const parent = $from.node(-2);\n    const grandGrandParent = $from.node(-3);\n    return ((parent && parent.type === listType) ||\n        (grandGrandParent && grandGrandParent.type === listType));\n};\nconst canOutdent = (type) => (state) => {\n    const { parent } = state.selection.$from;\n    let listItem = type;\n    if (!listItem) {\n        ({ listItem } = state.schema.nodes);\n    }\n    const { paragraph } = state.schema.nodes;\n    if (state.selection instanceof GapCursorSelection) {\n        return parent.type === listItem;\n    }\n    return (parent.type === paragraph && hasParentNodeOfType(listItem)(state.selection));\n};\n/**\n * Check if we can sink the list.\n * @returns {boolean} - true if we can sink the list\n *                    - false if we reach the max indentation level\n */\nfunction canSink(initialIndentationLevel, state) {\n    /*\n        - Keep going forward in document until indentation of the node is < than the initial\n        - If indentation is EVER > max indentation, return true and don't sink the list\n        */\n    let currentIndentationLevel;\n    let currentPos = state.tr.selection.$to.pos;\n    do {\n        const resolvedPos = state.doc.resolve(currentPos);\n        currentIndentationLevel = numberNestedLists(resolvedPos, state.schema.nodes);\n        if (currentIndentationLevel > maxIndentation) {\n            // Cancel sink list.\n            // If current indentation less than the initial, it won't be\n            // larger than the max, and the loop will terminate at end of this iteration\n            return false;\n        }\n        currentPos++;\n    } while (currentIndentationLevel >= initialIndentationLevel);\n    return true;\n}\nconst isInsideListItem = (type) => (state) => {\n    const { $from } = state.selection;\n    let listItem = type;\n    if (!listItem) {\n        listItem = getNodeType(state, 'listItem');\n    }\n    const { paragraph } = state.schema.nodes;\n    if (state.selection instanceof GapCursorSelection) {\n        return $from.parent.type === listItem;\n    }\n    return (hasParentNodeOfType(listItem)(state.selection) &&\n        $from.parent.type === paragraph);\n};\n// Get the depth of the nearest ancestor list\nconst rootListDepth = (type, pos, nodes) => {\n    let listItem = type;\n    const { bulletList, orderedList } = nodes;\n    let depth;\n    for (let i = pos.depth - 1; i > 0; i--) {\n        const node = pos.node(i);\n        if (node.type === bulletList || node.type === orderedList) {\n            depth = i;\n        }\n        if (node.type !== bulletList &&\n            node.type !== orderedList &&\n            node.type !== listItem) {\n            break;\n        }\n    }\n    return depth;\n};\nfunction canToJoinToPreviousListItem(state) {\n    const { $from } = state.selection;\n    const { bulletList, orderedList } = state.schema.nodes;\n    const $before = state.doc.resolve($from.pos - 1);\n    let nodeBefore = $before ? $before.nodeBefore : null;\n    if (state.selection instanceof GapCursorSelection) {\n        nodeBefore = $from.nodeBefore;\n    }\n    return (!!nodeBefore && [bulletList, orderedList].indexOf(nodeBefore.type) > -1);\n}\n/**\n * ------------------\n * Command Factories\n * ------------------\n */\n/**\n *\n * @param {Object} listType  bulletList, orderedList,\n * @param {Object} itemType   'listItem'\n * @param {boolean} todo if true and the final result of toggle is a bulletList\n *                      set `todoChecked` attr for each listItem.\n */\nfunction toggleList(listType, itemType, todo) {\n    return (state, dispatch, view) => {\n        const { selection } = state;\n        const fromNode = selection.$from.node(selection.$from.depth - 2);\n        const endNode = selection.$to.node(selection.$to.depth - 2);\n        if (!fromNode ||\n            fromNode.type.name !== listType.name ||\n            !endNode ||\n            endNode.type.name !== listType.name) {\n            return toggleListCommand(listType, todo)(state, dispatch, view);\n        }\n        else {\n            // If current ListType is the same as `listType` in arg,\n            // toggle the list to `p`.\n            const listItem = itemType ? itemType : getNodeType(state, 'listItem');\n            const depth = rootListDepth(listItem, selection.$to, state.schema.nodes);\n            let liftFrom = selection.$to.pos;\n            // I am not fully sure the best solution,\n            // but if we donot handle the the nodeSelection of itemType\n            // an incorrect content error in thrown by liftFollowingList.\n            if (selection instanceof NodeSelection &&\n                selection.node.type === listItem) {\n                liftFrom =\n                    selection.$from.pos + selection.node.firstChild.content.size;\n            }\n            let baseTr = state.tr;\n            let tr = liftFollowingList(listItem, state, liftFrom, selection.$to.end(depth), depth || 0, baseTr);\n            tr = liftSelectionList(listItem, state, tr);\n            if (dispatch) {\n                dispatch(tr);\n            }\n            return true;\n        }\n    };\n}\nfunction toggleListCommand(listType, todo = false) {\n    /**\n     * A function which will set todoChecked attribute\n     * in any of the nodes that have modified on the tr\n     */\n    const setTodoListTr = (schema) => (tr) => {\n        if (!tr.isGeneric) {\n            return tr;\n        }\n        // The following code gets a list of ranges that were changed\n        // From wrapDispatchForJoin: https://github.com/prosemirror/prosemirror-commands/blob/e5f8c303be55147086bfe4521cf7419e6effeb8f/src%2Fcommands.js#L495\n        // and https://discuss.prosemirror.net/t/finding-out-what-changed-in-a-transaction/2372\n        let ranges = [];\n        for (let i = 0; i < tr.mapping.maps.length; i++) {\n            let map = tr.mapping.maps[i];\n            for (let j = 0; j < ranges.length; j++) {\n                ranges[j] = map.map(ranges[j]);\n            }\n            map.forEach((_s, _e, from, to) => {\n                ranges.push(from, to);\n            });\n        }\n        const canBeTodo = (node, parentNode) => node.type === getNodeType(schema, 'listItem') &&\n            (parentNode === null || parentNode === void 0 ? void 0 : parentNode.type) === getNodeType(schema, 'bulletList');\n        for (let i = 0; i < ranges.length; i += 2) {\n            let from = ranges[i];\n            let to = ranges[i + 1];\n            tr.doc.nodesBetween(from, to, (node, pos, parentNode) => {\n                if (pos >= from && pos < to && canBeTodo(node, parentNode)) {\n                    setTodoCheckedAttr(tr, schema, node, pos);\n                }\n            });\n        }\n        return tr;\n    };\n    return function (state, dispatch, view) {\n        if (dispatch) {\n            dispatch(state.tr.setSelection(adjustSelectionInList(state.doc, state.selection)));\n        }\n        if (!view) {\n            return false;\n        }\n        state = view.state;\n        const { $from, $to } = state.selection;\n        const isRangeOfSingleType = isRangeOfType(state.doc, $from, $to, listType);\n        if (isInsideList(state, listType) && isRangeOfSingleType) {\n            return liftListItems()(state, dispatch);\n        }\n        else {\n            // Converts list type e.g. bulletList -> orderedList if needed\n            if (!isRangeOfSingleType) {\n                liftListItems()(state, dispatch);\n                state = view.state;\n            }\n            // Remove any invalid marks that are not supported\n            const tr = sanitiseSelectionMarksForWrapping(state, listType);\n            if (tr && dispatch) {\n                dispatch(tr);\n                state = view.state;\n            }\n            // Wraps selection in list\n            return wrapInList(listType)(state, todo ? extendDispatch(dispatch, setTodoListTr(state.schema)) : dispatch);\n        }\n    };\n}\nfunction wrapInList(nodeType, attrs) {\n    return autoJoin(wrapInList$1(nodeType, attrs), (before, after) => before.type === after.type && before.type === nodeType);\n}\nfunction liftListItems() {\n    return function (state, dispatch) {\n        const { tr } = state;\n        const { $from, $to } = state.selection;\n        tr.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n            // Following condition will ensure that block types paragraph, heading, codeBlock, blockquote, panel are lifted.\n            // isTextblock is true for paragraph, heading, codeBlock.\n            if (node.isTextblock) {\n                const sel = new NodeSelection(tr.doc.resolve(tr.mapping.map(pos)));\n                const range = sel.$from.blockRange(sel.$to);\n                if (!range ||\n                    ![getNodeType(state, 'listItem')].includes(sel.$from.parent.type)) {\n                    return false;\n                }\n                const target = range && liftTarget(range);\n                if (target === undefined || target === null) {\n                    return false;\n                }\n                tr.lift(range, target);\n            }\n            return;\n        });\n        if (dispatch) {\n            dispatch(tr);\n        }\n        return true;\n    };\n}\n/**\n * Sometimes a selection in the editor can be slightly offset, for example:\n * it's possible for a selection to start or end at an empty node at the very end of\n * a line. This isn't obvious by looking at the editor and it's likely not what the\n * user intended - so we need to adjust the selection a bit in scenarios like that.\n */\nfunction adjustSelectionInList(doc, selection) {\n    let { $from, $to } = selection;\n    const isSameLine = $from.pos === $to.pos;\n    let startPos = $from.pos;\n    let endPos = $to.pos;\n    if (isSameLine && startPos === doc.nodeSize - 3) {\n        // Line is empty, don't do anything\n        return selection;\n    }\n    // Selection started at the very beginning of a line and therefor points to the previous line.\n    if ($from.nodeBefore && !isSameLine) {\n        startPos++;\n        let node = doc.nodeAt(startPos);\n        while (!node || (node && !node.isText)) {\n            startPos++;\n            node = doc.nodeAt(startPos);\n        }\n    }\n    if (endPos === startPos) {\n        return new TextSelection(doc.resolve(startPos));\n    }\n    return new TextSelection(doc.resolve(startPos), doc.resolve(endPos));\n}\nfunction indentList(type) {\n    const handleTodo = (schema) => (tr) => {\n        if (!tr.isGeneric) {\n            return tr;\n        }\n        const range = tr.selection.$from.blockRange(tr.selection.$to, (node) => node.childCount > 0 &&\n            node.firstChild.type === getNodeType(schema, 'listItem'));\n        if (!range ||\n            // we donot have an existing node to check if todo is needed or not\n            range.startIndex === 0) {\n            return tr;\n        }\n        const isNodeBeforeATodo = isNodeTodo(range.parent.child(range.startIndex - 1), schema);\n        const { parent, startIndex, endIndex } = range;\n        let offset = 0;\n        for (let i = startIndex; i < endIndex; i++) {\n            const child = parent.child(i);\n            const pos = range.start + offset;\n            tr = isNodeBeforeATodo\n                ? setTodoCheckedAttr(tr, schema, child, pos)\n                : removeTodoCheckedAttr(tr, schema, child, pos);\n            offset += child.nodeSize;\n        }\n        return tr;\n    };\n    return function indentListCommand(state, dispatch) {\n        let listItem = type;\n        if (!listItem) {\n            listItem = getNodeType(state, 'listItem');\n        }\n        if (isInsideListItem(listItem)(state)) {\n            // Record initial list indentation\n            const initialIndentationLevel = numberNestedLists(state.selection.$from, state.schema.nodes);\n            if (canSink(initialIndentationLevel, state)) {\n                sinkListItem(listItem)(state, extendDispatch(dispatch, handleTodo(state.schema)));\n            }\n            return true;\n        }\n        return false;\n    };\n}\nfunction outdentList(type) {\n    return function (state, dispatch, view) {\n        let listItem = type;\n        if (!listItem) {\n            listItem = getNodeType(state, 'listItem');\n        }\n        const { $from, $to } = state.selection;\n        if (!isInsideListItem(listItem)(state)) {\n            return false;\n        }\n        // if we're backspacing at the start of a list item, unindent it\n        // take the the range of nodes we might be lifting\n        // the predicate is for when you're backspacing a top level list item:\n        // we don't want to go up past the doc node, otherwise the range\n        // to clear will include everything\n        let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type === listItem);\n        if (!range) {\n            return false;\n        }\n        const isGreatGrandTodo = isNodeTodo(state.selection.$from.node(-3), state.schema);\n        // TODO this is not quite as lean as the indent approach of todo\n        // check if we need to set todoCheck attribute\n        if (dispatch && view) {\n            const grandParent = state.selection.$from.node(-2);\n            const grandParentPos = state.selection.$from.start(-2);\n            let tr = state.tr;\n            for (const { node, pos } of flatten(grandParent, false)) {\n                const absPos = pos + grandParentPos;\n                // -1 so that we cover the entire list item\n                if (absPos >= state.selection.$from.before(-1) &&\n                    absPos < state.selection.$to.after(-1)) {\n                    if (isGreatGrandTodo) {\n                        setTodoCheckedAttr(tr, state.schema, node, absPos);\n                    }\n                    else {\n                        removeTodoCheckedAttr(tr, state.schema, node, absPos);\n                    }\n                }\n            }\n            dispatch(tr);\n            state = view.state;\n        }\n        const composedCommand = compose(mergeLists(listItem, range), // 2. Check if I need to merge nearest list\n        liftListItem$1)(listItem);\n        return composedCommand(state, dispatch, view);\n    };\n}\n/**\n * Merge closest bullet list blocks into one\n *\n * @param {NodeType} listItem\n * @param {NodeRange} range\n * @returns\n */\nfunction mergeLists(listItem, range) {\n    return (command) => {\n        return (state, dispatch, view) => {\n            const newDispatch = (tr) => {\n                /* we now need to handle the case that we lifted a sublist out,\n                 * and any listItems at the current level get shifted out to\n                 * their own new list; e.g.:\n                 *\n                 * unorderedList\n                 *  listItem(A)\n                 *  listItem\n                 *    unorderedList\n                 *      listItem(B)\n                 *  listItem(C)\n                 *\n                 * becomes, after unindenting the first, top level listItem, A:\n                 *\n                 * content of A\n                 * unorderedList\n                 *  listItem(B)\n                 * unorderedList\n                 *  listItem(C)\n                 *\n                 * so, we try to merge these two lists if they're of the same type, to give:\n                 *\n                 * content of A\n                 * unorderedList\n                 *  listItem(B)\n                 *  listItem(C)\n                 */\n                const $start = state.doc.resolve(range.start);\n                const $end = state.doc.resolve(range.end);\n                const $join = tr.doc.resolve(tr.mapping.map(range.end - 1));\n                if ($join.nodeBefore &&\n                    $join.nodeAfter &&\n                    $join.nodeBefore.type === $join.nodeAfter.type) {\n                    if ($end.nodeAfter &&\n                        $end.nodeAfter.type === listItem &&\n                        $end.parent.type === $start.parent.type) {\n                        tr.join($join.pos);\n                    }\n                }\n                if (dispatch) {\n                    dispatch(tr.scrollIntoView());\n                }\n            };\n            return command(state, newDispatch, view);\n        };\n    };\n}\n// Chaining runs each command until one of them returns true\nconst backspaceKeyCommand = (type) => (state, dispatch, view) => {\n    return chainCommands(\n    // if we're at the start of a list item, we need to either backspace\n    // directly to an empty list item above, or outdent this node\n    filter([\n        isInsideListItem(type),\n        isEmptySelectionAtStart,\n        // list items might have multiple paragraphs; only do this at the first one\n        isFirstChildOfParent,\n        canOutdent(type),\n    ], chainCommands(deletePreviousEmptyListItem(type), outdentList(type))), \n    // if we're just inside a paragraph node (or gapcursor is shown) and backspace, then try to join\n    // the text to the previous list item, if one exists\n    filter([isEmptySelectionAtStart, canToJoinToPreviousListItem], joinToPreviousListItem(type)))(state, dispatch, view);\n};\nfunction enterKeyCommand(type) {\n    return (state, dispatch, view) => {\n        const { selection } = state;\n        if (selection.empty) {\n            const { $from } = selection;\n            let listItem = type;\n            if (!listItem) {\n                listItem = getNodeType(state, 'listItem');\n            }\n            const { codeBlock } = state.schema.nodes;\n            const node = $from.node($from.depth);\n            const wrapper = $from.node($from.depth - 1);\n            if (wrapper && wrapper.type === listItem) {\n                /** Check if the wrapper has any visible content */\n                const wrapperHasContent = hasVisibleContent(wrapper);\n                if (isNodeEmpty(node) && !wrapperHasContent) {\n                    const grandParent = $from.node($from.depth - 3);\n                    // To allow for cases where a non-todo item is nested inside a todo item\n                    // pressing enter should convert that type into a todo listItem and outdent.\n                    if (isNodeTodo(grandParent, state.schema) &&\n                        !isNodeTodo(wrapper, state.schema)) {\n                        return outdentList(getNodeType(state, 'listItem'))(state, dispatch, view);\n                    }\n                    else {\n                        return outdentList(listItem)(state, dispatch, view);\n                    }\n                }\n                else if (!codeBlock || !hasParentNodeOfType(codeBlock)(selection)) {\n                    return splitListItem(listItem, (node) => {\n                        if (!isNodeTodo(node, state.schema)) {\n                            return node.attrs;\n                        }\n                        return {\n                            ...node.attrs,\n                            todoChecked: false,\n                        };\n                    })(state, dispatch);\n                }\n            }\n        }\n        return false;\n    };\n}\n/***\n * Implementation taken from PM and mk-2\n * Splits the list items, specific implementation take from PM\n *\n * splitAttrs(node): attrs - if defined the new split item will get attrs returned by this.\n *                        where node is the currently active node.\n */\nfunction splitListItem(itemType, splitAttrs) {\n    return function (state, dispatch) {\n        const ref = state.selection;\n        const $from = ref.$from;\n        const $to = ref.$to;\n        const node = ref.node;\n        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\n            return false;\n        }\n        const grandParent = $from.node(-1);\n        if (grandParent.type !== itemType) {\n            return false;\n        }\n        /** --> The following line changed from the original PM implementation to allow list additions with multiple paragraphs */\n        if (\n        // @ts-ignore Fragment.content is missing in @types/prosemirror-model\n        grandParent.content.content.length <= 1 &&\n            $from.parent.content.size === 0 &&\n            !(grandParent.content.size === 0)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth === 2 ||\n                $from.node(-3).type !== itemType ||\n                $from.index(-2) !== $from.node(-2).childCount - 1) {\n                return false;\n            }\n            if (dispatch) {\n                let wrap = Fragment.empty;\n                const keepItem = $from.index(-1) > 0;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for (let d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d--) {\n                    wrap = Fragment.from($from.node(d).copy(wrap));\n                }\n                // Add a second list item with an empty default start node\n                wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n                const tr$1 = state.tr.replace($from.before(keepItem ? undefined : -1), $from.after(-3), new Slice(wrap, keepItem ? 3 : 2, 2));\n                tr$1.setSelection(Selection.near(tr$1.doc.resolve($from.pos + (keepItem ? 3 : 2))));\n                dispatch(tr$1.scrollIntoView());\n            }\n            return true;\n        }\n        const nextType = $to.pos === $from.end()\n            ? grandParent.contentMatchAt(0).defaultType\n            : undefined;\n        const tr = state.tr.delete($from.pos, $to.pos);\n        const types = [\n            splitAttrs\n                ? { type: itemType, attrs: splitAttrs(grandParent) }\n                : undefined,\n            nextType && { type: nextType },\n        ];\n        if (dispatch) {\n            dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n        }\n        return true;\n    };\n}\nfunction joinToPreviousListItem(type) {\n    return (state, dispatch) => {\n        let listItem = type;\n        if (!listItem) {\n            ({ listItem } = state.schema.nodes);\n        }\n        const { $from } = state.selection;\n        const { paragraph, codeBlock, heading, bulletList, orderedList } = state.schema.nodes;\n        const isGapCursorShown = state.selection instanceof GapCursorSelection;\n        const $cutPos = isGapCursorShown ? state.doc.resolve($from.pos + 1) : $from;\n        let $cut = findCutBefore($cutPos);\n        if (!$cut) {\n            return false;\n        }\n        // see if the containing node is a list\n        if ($cut.nodeBefore &&\n            [bulletList, orderedList].indexOf($cut.nodeBefore.type) > -1) {\n            // and the node after this is a paragraph / codeBlock / heading\n            if ($cut.nodeAfter &&\n                [paragraph, codeBlock, heading].indexOf($cut.nodeAfter.type) > -1) {\n                // find the nearest paragraph that precedes this node\n                let $lastNode = $cut.doc.resolve($cut.pos - 1);\n                while ($lastNode.parent.type !== paragraph) {\n                    $lastNode = state.doc.resolve($lastNode.pos - 1);\n                }\n                let { tr } = state;\n                if (isGapCursorShown) {\n                    const nodeBeforePos = findPositionOfNodeBefore(tr.selection);\n                    if (typeof nodeBeforePos !== 'number') {\n                        return false;\n                    }\n                    // append the paragraph / codeblock / heading to the list node\n                    const list = $cut.nodeBefore.copy($cut.nodeBefore.content.append(Fragment.from(listItem.createChecked({}, $cut.nodeAfter))));\n                    tr.replaceWith(nodeBeforePos, $from.pos + $cut.nodeAfter.nodeSize, list);\n                }\n                else {\n                    // take the text content of the paragraph and insert after the paragraph up until before the the cut\n                    tr = tr.step(new ReplaceAroundStep($lastNode.pos, $cut.pos + $cut.nodeAfter.nodeSize, $cut.pos + 1, $cut.pos + $cut.nodeAfter.nodeSize - 1, state.tr.doc.slice($lastNode.pos, $cut.pos), 0, true));\n                }\n                // find out if there's now another list following and join them\n                // as in, [list, p, list] => [list with p, list], and we want [joined list]\n                let $postCut = tr.doc.resolve(tr.mapping.map($cut.pos + $cut.nodeAfter.nodeSize));\n                if ($postCut.nodeBefore &&\n                    $postCut.nodeAfter &&\n                    $postCut.nodeBefore.type === $postCut.nodeAfter.type &&\n                    [bulletList, orderedList].indexOf($postCut.nodeBefore.type) > -1) {\n                    tr = tr.join($postCut.pos);\n                }\n                if (dispatch) {\n                    dispatch(tr.scrollIntoView());\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n}\nfunction deletePreviousEmptyListItem(type) {\n    return (state, dispatch) => {\n        const { $from } = state.selection;\n        let listItem = type;\n        if (!listItem) {\n            listItem = getNodeType(state, 'listItem');\n        }\n        const $cut = findCutBefore($from);\n        if (!$cut || !$cut.nodeBefore || !($cut.nodeBefore.type === listItem)) {\n            return false;\n        }\n        const previousListItemEmpty = $cut.nodeBefore.childCount === 1 &&\n            $cut.nodeBefore.firstChild.nodeSize <= 2;\n        if (previousListItemEmpty) {\n            const { tr } = state;\n            if (dispatch) {\n                dispatch(tr\n                    .delete($cut.pos - $cut.nodeBefore.nodeSize, $from.pos)\n                    .scrollIntoView());\n            }\n            return true;\n        }\n        return false;\n    };\n}\nfunction moveEdgeListItem(type, dir = 'UP') {\n    const isDown = dir === 'DOWN';\n    const isItemAtEdge = (state) => {\n        const currentResolved = findParentNodeOfType(type)(state.selection);\n        if (!currentResolved) {\n            return false;\n        }\n        const currentNode = currentResolved.node;\n        const { $from } = state.selection;\n        const parent = $from.node(currentResolved.depth - 1);\n        const matchedChild = parent && parent[isDown ? 'lastChild' : 'firstChild'];\n        if (currentNode && matchedChild === currentNode) {\n            return true;\n        }\n        return false;\n    };\n    const command = (state, dispatch, view) => {\n        let listItem = type;\n        if (!listItem) {\n            listItem = getNodeType(state, 'listItem');\n        }\n        if (!state.selection.empty) {\n            return false;\n        }\n        const grandParent = findParentNode((node) => validListParent(node.type, state.schema.nodes))(state.selection);\n        const parent = findParentNodeOfType(listItem)(state.selection);\n        if (!(grandParent && grandParent.node) || !(parent && parent.node)) {\n            return false;\n        }\n        // outdent if the not nested list item i.e. top level\n        if (state.selection.$from.depth === 3) {\n            return outdentList(listItem)(state, dispatch, view);\n        }\n        // If there is only one element, we need to delete the entire\n        // bulletList/orderedList so as not to leave any empty list behind.\n        let nodeToRemove = grandParent.node.childCount === 1 ? grandParent : parent;\n        let tr = state.tr.delete(nodeToRemove.pos, nodeToRemove.pos + nodeToRemove.node.nodeSize);\n        // - first // doing a (-1) will move us to end of 'first' hence allowing us to add an item\n        // - second  // start(-3) will give 11 which is the start of this listItem,\n        //   - third{<>}\n        let insertPos = state.selection.$from.before(-3);\n        // when going down move the position by the size of remaining content (after deletion)\n        if (isDown) {\n            let uncleNodePos = state.selection.$from.after(-3);\n            insertPos = uncleNodePos - nodeToRemove.node.nodeSize;\n            let uncle = validPos(uncleNodePos, state.doc) && state.doc.nodeAt(uncleNodePos);\n            if (uncle && uncle.type === listItem) {\n                // Example\n                // - first\n                // - second\n                //   - third{<>}\n                // - uncle\n                // {x} <== you want to go down here\n                insertPos += uncle.nodeSize;\n            }\n        }\n        let nodeToInsert = parent.node;\n        const newTr = safeInsert(nodeToInsert, insertPos)(tr);\n        // no change hence dont mutate anything\n        if (newTr === tr) {\n            return false;\n        }\n        if (dispatch) {\n            dispatch(newTr);\n        }\n        return true;\n    };\n    return filter([isItemAtEdge], command);\n}\nfunction updateNodeAttrs(type, cb) {\n    return (state, dispatch) => {\n        const { $from } = state.selection;\n        const current = $from.node(-1);\n        if (current && current.type === type) {\n            const { tr } = state;\n            const nodePos = $from.before(-1);\n            const newAttrs = cb(current.attrs);\n            if (newAttrs !== current.attrs) {\n                tr.setNodeMarkup(nodePos, undefined, cb(current.attrs));\n                dispatch && dispatch(tr);\n                return true;\n            }\n        }\n        return false;\n    };\n}\n\n// markdown parsing helper\nfunction listIsTight(tokens, i) {\n    while (++i < tokens.length) {\n        let token = tokens[i];\n        if (token && token.type !== 'list_item_open') {\n            return token.hidden;\n        }\n    }\n    return false;\n}\n\nconst spec$c = specFactory$c;\nconst plugins$c = pluginsFactory$c;\nconst commands$a = {\n    toggleBulletList,\n    queryIsBulletListActive,\n};\nconst defaultKeys$9 = {\n    toggle: 'Shift-Ctrl-8',\n    toggleTodo: 'Shift-Ctrl-7',\n};\nconst name$c = 'bulletList';\nfunction specFactory$c() {\n    return {\n        type: 'node',\n        name: name$c,\n        schema: {\n            content: 'listItem+',\n            group: 'block',\n            parseDOM: [{ tag: 'ul' }],\n            toDOM: () => ['ul', 0],\n            attrs: {\n                // a style preference attribute which be used for\n                // rendering output.\n                // For example markdown serializer can render a new line in\n                // between or not.\n                tight: {\n                    default: false,\n                },\n            },\n        },\n        markdown: {\n            toMarkdown(state, node) {\n                state.renderList(node, '  ', () => '- ');\n            },\n            parseMarkdown: {\n                bullet_list: {\n                    block: name$c,\n                    getAttrs: (_, tokens, i) => {\n                        return { tight: listIsTight(tokens, i) };\n                    },\n                },\n            },\n        },\n    };\n}\nfunction pluginsFactory$c({ markdownShortcut = true, todoMarkdownShortcut = true, keybindings = defaultKeys$9, } = {}) {\n    return ({ schema }) => {\n        const type = getNodeType(schema, name$c);\n        return [\n            keybindings &&\n                keymap(createObject([\n                    [keybindings.toggle, toggleBulletList()],\n                    [keybindings.toggleTodo, toggleTodoList()],\n                ])),\n            markdownShortcut &&\n                wrappingInputRule(/^\\s*([-+*])\\s$/, type, undefined, (_str, node) => {\n                    if (node.lastChild && isNodeTodo(node.lastChild, schema)) {\n                        return false;\n                    }\n                    return true;\n                }),\n            todoMarkdownShortcut &&\n                wrappingInputRuleForTodo(/^\\s*(\\[ \\])\\s$/, {\n                    todoChecked: false,\n                }),\n        ];\n    };\n}\nfunction toggleBulletList() {\n    const handleBulletLists = (state, dispatch, view) => toggleList(getNodeType(state, 'bulletList'), getNodeType(state, 'listItem'))(state, dispatch, view);\n    return chainCommands(removeTodo, handleBulletLists);\n}\nfunction toggleTodoList() {\n    const fallback = (state, dispatch, view) => toggleList(getNodeType(state, 'bulletList'), getNodeType(state, 'listItem'), true)(state, dispatch, view);\n    return chainCommands(setTodo, fallback);\n}\nfunction queryIsBulletListActive() {\n    return (state) => {\n        return parentHasDirectParentOfType(getNodeType(state, 'listItem'), [\n            getNodeType(state, 'bulletList'),\n        ])(state);\n    };\n}\nfunction queryIsTodoListActive() {\n    return (state) => {\n        const { schema } = state;\n        return (parentHasDirectParentOfType(getNodeType(state, 'listItem'), [\n            getNodeType(state, 'bulletList'),\n        ])(state) && isNodeTodo(state.selection.$from.node(-1), schema));\n    };\n}\n\nvar bulletList = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec$c,\n    plugins: plugins$c,\n    commands: commands$a,\n    defaultKeys: defaultKeys$9,\n    toggleBulletList: toggleBulletList,\n    toggleTodoList: toggleTodoList,\n    queryIsBulletListActive: queryIsBulletListActive,\n    queryIsTodoListActive: queryIsTodoListActive\n});\n\nconst spec$b = specFactory$b;\nconst plugins$b = pluginsFactory$b;\nconst commands$9 = {\n    toggleCode,\n    queryIsCodeActive,\n};\nconst defaultKeys$8 = {\n    toggleCode: 'Mod-`',\n};\nconst name$b = 'code';\nconst getTypeFromSchema$4 = (schema) => {\n    const markType = schema.marks[name$b];\n    assertNotUndefined(markType, `markType ${name$b} not found`);\n    return markType;\n};\nconst getTypeFromState = (state) => {\n    const markType = state.schema.marks[name$b];\n    assertNotUndefined(markType, `markType ${name$b} not found`);\n    return markType;\n};\nfunction specFactory$b() {\n    return {\n        type: 'mark',\n        name: name$b,\n        schema: {\n            excludes: '_',\n            parseDOM: [{ tag: name$b }],\n            toDOM: () => [name$b, 0],\n        },\n        markdown: {\n            toMarkdown: {\n                open(_state, _mark, parent, index) {\n                    return backticksFor(parent.child(index), -1);\n                },\n                close(_state, _mark, parent, index) {\n                    return backticksFor(parent.child(index - 1), 1);\n                },\n                escape: false,\n            },\n            parseMarkdown: {\n                code_inline: { mark: name$b, noCloseToken: true },\n            },\n        },\n    };\n}\nfunction pluginsFactory$b({ markdownShortcut = true, escapeAtEdge = true, keybindings = defaultKeys$8, } = {}) {\n    return ({ schema }) => {\n        const type = getTypeFromSchema$4(schema);\n        const escapeFilters = [\n            // The $cursor is a safe way to check if it is a textSelection,\n            // It is also used in a bunch of placed in pm-commands when dealing with marks\n            // Ref: https://discuss.prosemirror.net/t/what-is-an-example-of-an-empty-selection-that-has-a-cursor/3071\n            (state) => state.selection.empty && state.selection.$cursor,\n        ];\n        return [\n            markdownShortcut && markPasteRule$1(/(?:`)([^`]+)(?:`)/g, type),\n            markdownShortcut && markInputRule(/(?:`)([^`]+)(?:`)$/, type),\n            keybindings &&\n                keymap(createObject([[keybindings.toggleCode, toggleMark(type)]])),\n            escapeAtEdge &&\n                keymap({\n                    ArrowRight: filter(escapeFilters, moveRight),\n                    ArrowLeft: filter(escapeFilters, moveLeft),\n                }),\n        ];\n    };\n}\nconst posHasCode = (state, pos) => {\n    // This logic exists because\n    // in  rtl (right to left) $<code>text#</code>  (where $ and # represent possible cursor positions)\n    // at the edges of code only $ and # are valid positions by default.\n    // Put other ways, typing at $ cursor pos will not produce regular text,\n    // and typing in # will produce code mark text.\n    // To know if a pos will be inside code or not we check for a range.\n    //    0      1   2   3   4   5   6        7\n    // <para/>     a   b   c   d   e    </para>\n    // if the mark is [bcd], and we are moving left from 6\n    // we will need to check for rangeHasMark(4,5) to get that 5\n    // is having a code mark, hence we do a `pos-1`\n    // but if we are moving right and from 2, we donot need to add or subtract\n    // because just doing rangeHasMark(2, 3) will give us correct answer.\n    if (pos < 0 || pos > state.doc.content.size) {\n        return false;\n    }\n    const code = getTypeFromState(state);\n    const node = state.doc.nodeAt(pos);\n    return node ? node.marks.some((mark) => mark.type === code) : false;\n};\nvar moveRight = (state, dispatch) => {\n    const code = getTypeFromState(state);\n    const $cursor = state.selection.$cursor;\n    let storedMarks = state.tr.storedMarks;\n    const insideCode = markActive(state, code);\n    const currentPosHasCode = state.doc.rangeHasMark($cursor.pos, $cursor.pos, code);\n    const nextPosHasCode = state.doc.rangeHasMark($cursor.pos, $cursor.pos + 1, code);\n    const enteringCode = !currentPosHasCode &&\n        nextPosHasCode &&\n        !(storedMarks && storedMarks.length > 0);\n    // entering code mark (from the left edge): don't move the cursor, just add the mark\n    if (!insideCode && enteringCode) {\n        if (dispatch) {\n            dispatch(state.tr.addStoredMark(code.create()));\n        }\n        return true;\n    }\n    const exitingCode = !currentPosHasCode &&\n        !nextPosHasCode &&\n        !(storedMarks && storedMarks.length === 0);\n    // exiting code mark: don't move the cursor, just remove the mark\n    if (insideCode && exitingCode) {\n        if (dispatch) {\n            dispatch(state.tr.removeStoredMark(code));\n        }\n        return true;\n    }\n    return false;\n};\nvar moveLeft = (state, dispatch) => {\n    const code = getTypeFromState(state);\n    const insideCode = markActive(state, code);\n    const $cursor = state.selection.$cursor;\n    const { storedMarks } = state.tr;\n    const currentPosHasCode = posHasCode(state, $cursor.pos);\n    const nextPosHasCode = posHasCode(state, $cursor.pos - 1);\n    const nextNextPosHasCode = posHasCode(state, $cursor.pos - 2);\n    const exitingCode = currentPosHasCode && !nextPosHasCode && Array.isArray(storedMarks);\n    const atLeftEdge = nextPosHasCode &&\n        !nextNextPosHasCode &&\n        (storedMarks === null ||\n            (Array.isArray(storedMarks) && !!storedMarks.length));\n    const atRightEdge = ((exitingCode && Array.isArray(storedMarks) && !storedMarks.length) ||\n        (!exitingCode && storedMarks === null)) &&\n        !nextPosHasCode &&\n        nextNextPosHasCode;\n    const enteringCode = !currentPosHasCode &&\n        nextPosHasCode &&\n        Array.isArray(storedMarks) &&\n        !storedMarks.length;\n    // at the right edge: remove code mark and move the cursor to the left\n    if (!insideCode && atRightEdge) {\n        const tr = state.tr.setSelection(Selection.near(state.doc.resolve($cursor.pos - 1)));\n        if (dispatch) {\n            dispatch(tr.removeStoredMark(code));\n        }\n        return true;\n    }\n    // entering code mark (from right edge): don't move the cursor, just add the mark\n    if (!insideCode && enteringCode) {\n        if (dispatch) {\n            dispatch(state.tr.addStoredMark(code.create()));\n        }\n        return true;\n    }\n    // at the left edge: add code mark and move the cursor to the left\n    if (insideCode && atLeftEdge) {\n        const tr = state.tr.setSelection(Selection.near(state.doc.resolve($cursor.pos - 1)));\n        if (dispatch) {\n            dispatch(tr.addStoredMark(code.create()));\n        }\n        return true;\n    }\n    // exiting code mark (or at the beginning of the line): don't move the cursor, just remove the mark\n    const isFirstChild = $cursor.index($cursor.depth - 1) === 0;\n    if (insideCode && (exitingCode || (!$cursor.nodeBefore && isFirstChild))) {\n        if (dispatch) {\n            dispatch(state.tr.removeStoredMark(code));\n        }\n        return true;\n    }\n    return false;\n};\nfunction backticksFor(node, side) {\n    let ticks = /`+/g;\n    let m;\n    let len = 0;\n    if (node.isText) {\n        while ((m = ticks.exec(node.text))) {\n            let res = m[0];\n            if (typeof res === 'string') {\n                len = Math.max(len, res.length);\n            }\n        }\n    }\n    let result = len > 0 && side > 0 ? ' `' : '`';\n    for (let i = 0; i < len; i++) {\n        result += '`';\n    }\n    if (len > 0 && side < 0) {\n        result += ' ';\n    }\n    return result;\n}\nfunction markActive(state, mark) {\n    const { from, to, empty } = state.selection;\n    // When the selection is empty, only the active marks apply.\n    if (empty) {\n        return !!mark.isInSet(state.tr.storedMarks || state.selection.$from.marks());\n    }\n    // For a non-collapsed selection, the marks on the nodes matter.\n    let found = false;\n    state.doc.nodesBetween(from, to, (node) => {\n        found = found || !!mark.isInSet(node.marks);\n    });\n    return found;\n}\nfunction toggleCode() {\n    return (state, dispatch) => {\n        const markType = state.schema.marks[name$b];\n        assertNotUndefined(markType, `markType ${name$b} not found`);\n        return toggleMark(markType)(state, dispatch);\n    };\n}\nfunction queryIsCodeActive() {\n    return (state) => {\n        const markType = state.schema.marks[name$b];\n        assertNotUndefined(markType, `markType ${name$b} not found`);\n        return isMarkActiveInSelection(markType)(state);\n    };\n}\n\nvar code = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec$b,\n    plugins: plugins$b,\n    commands: commands$9,\n    defaultKeys: defaultKeys$8,\n    toggleCode: toggleCode,\n    queryIsCodeActive: queryIsCodeActive\n});\n\nconst spec$a = specFactory$a;\nconst plugins$a = pluginsFactory$a;\nconst commands$8 = {\n    queryIsCodeActiveBlock,\n};\nconst defaultKeys$7 = {\n    toCodeBlock: 'Shift-Ctrl-\\\\',\n    moveDown: 'Alt-ArrowDown',\n    moveUp: 'Alt-ArrowUp',\n    insertEmptyParaAbove: 'Mod-Shift-Enter',\n    insertEmptyParaBelow: 'Mod-Enter',\n};\nconst name$a = 'codeBlock';\nfunction specFactory$a() {\n    return {\n        type: 'node',\n        name: name$a,\n        schema: {\n            attrs: {\n                language: { default: '' },\n            },\n            content: 'text*',\n            marks: '',\n            group: 'block',\n            code: true,\n            defining: true,\n            draggable: false,\n            parseDOM: [{ tag: 'pre', preserveWhitespace: 'full' }],\n            toDOM: () => ['pre', ['code', 0]],\n        },\n        markdown: {\n            toMarkdown(state, node) {\n                state.write('```' + (node.attrs['language'] || '') + '\\n');\n                state.text(node.textContent, false);\n                state.ensureNewLine();\n                state.write('```');\n                state.closeBlock(node);\n            },\n            parseMarkdown: {\n                code_block: { block: name$a, noCloseToken: true },\n                fence: {\n                    block: name$a,\n                    getAttrs: (tok) => ({ language: tok.info || '' }),\n                    noCloseToken: true,\n                },\n            },\n        },\n    };\n}\nfunction pluginsFactory$a({ markdownShortcut = true, keybindings = defaultKeys$7, } = {}) {\n    return ({ schema }) => {\n        const type = getNodeType(schema, name$a);\n        return [\n            markdownShortcut && textblockTypeInputRule(/^```$/, type),\n            keybindings &&\n                keymap(createObject([\n                    [keybindings.toCodeBlock, setBlockType(type)],\n                    [keybindings.moveUp, moveNode(type, 'UP')],\n                    [keybindings.moveDown, moveNode(type, 'DOWN')],\n                    [\n                        keybindings.insertEmptyParaAbove,\n                        filter(queryIsCodeActiveBlock(), insertEmpty(getParaNodeType(schema), 'above', false)),\n                    ],\n                    [\n                        keybindings.insertEmptyParaBelow,\n                        filter(queryIsCodeActiveBlock(), insertEmpty(getParaNodeType(schema), 'below', false)),\n                    ],\n                ])),\n        ];\n    };\n}\nfunction queryIsCodeActiveBlock() {\n    return (state) => {\n        const type = getNodeType(state, name$a);\n        return Boolean(findParentNodeOfType(type)(state.selection));\n    };\n}\n\nvar codeBlock = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec$a,\n    plugins: plugins$a,\n    commands: commands$8,\n    defaultKeys: defaultKeys$7,\n    queryIsCodeActiveBlock: queryIsCodeActiveBlock\n});\n\nconst spec$9 = specFactory$9;\nconst plugins$9 = pluginsFactory$9;\nconst defaultKeys$6 = {\n    insert: 'Shift-Enter',\n};\nconst name$9 = 'hardBreak';\nfunction specFactory$9() {\n    return {\n        type: 'node',\n        name: name$9,\n        schema: {\n            inline: true,\n            group: 'inline',\n            selectable: false,\n            parseDOM: [{ tag: 'br' }],\n            toDOM: () => ['br'],\n        },\n        markdown: {\n            toMarkdown(state, node, parent, index) {\n                for (let i = index + 1; i < parent.childCount; i++) {\n                    if (parent.child(i).type !== node.type) {\n                        state.write('\\\\\\n');\n                        return;\n                    }\n                }\n            },\n            parseMarkdown: {\n                hardbreak: { node: 'hardBreak' },\n            },\n        },\n    };\n}\nfunction pluginsFactory$9({ keybindings = defaultKeys$6 } = {}) {\n    return ({ schema }) => {\n        const type = getNodeType(schema, name$9);\n        const command = chainCommands(exitCode, (state, dispatch) => {\n            if (dispatch) {\n                dispatch(state.tr.replaceSelectionWith(type.create()).scrollIntoView());\n            }\n            return true;\n        });\n        return [\n            keybindings && keymap(createObject([[keybindings.insert, command]])),\n        ];\n    };\n}\n\nvar hardBreak = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec$9,\n    plugins: plugins$9,\n    defaultKeys: defaultKeys$6\n});\n\nconst spec$8 = specFactory$8;\nconst plugins$8 = pluginsFactory$8;\nconst commands$7 = {\n    toggleHeading,\n    queryIsHeadingActive,\n};\nconst defaultKeys$5 = {\n    toH1: 'Shift-Ctrl-1',\n    toH2: 'Shift-Ctrl-2',\n    toH3: 'Shift-Ctrl-3',\n    toH4: 'Shift-Ctrl-4',\n    toH5: 'Shift-Ctrl-5',\n    toH6: 'Shift-Ctrl-6',\n    moveDown: 'Alt-ArrowDown',\n    moveUp: 'Alt-ArrowUp',\n    emptyCopy: 'Mod-c',\n    emptyCut: 'Mod-x',\n    insertEmptyParaAbove: 'Mod-Shift-Enter',\n    jumpToStartOfHeading: browser.mac ? 'Ctrl-a' : 'Ctrl-Home',\n    jumpToEndOfHeading: browser.mac ? 'Ctrl-e' : 'Ctrl-End',\n    insertEmptyParaBelow: 'Mod-Enter',\n    toggleCollapse: undefined,\n};\nconst name$8 = 'heading';\nconst defaultLevels = [1, 2, 3, 4, 5, 6];\nconst checkIsInHeading = (state) => {\n    const type = getNodeType(state, name$8);\n    return findParentNodeOfType(type)(state.selection);\n};\nconst parseLevel = (levelStr) => {\n    const level = parseInt(levelStr, 10);\n    return Number.isNaN(level) ? undefined : level;\n};\nfunction specFactory$8({ levels = defaultLevels } = {}) {\n    if (levels.some((r) => typeof r !== 'number')) {\n        throw new Error('levels must be number');\n    }\n    const options = {\n        levels,\n    };\n    return {\n        type: 'node',\n        name: name$8,\n        schema: {\n            attrs: {\n                level: {\n                    default: 1,\n                },\n                collapseContent: {\n                    default: null,\n                },\n            },\n            content: 'inline*',\n            group: 'block',\n            defining: true,\n            draggable: false,\n            parseDOM: levels.map((level) => {\n                return {\n                    tag: `h${level}`,\n                    getAttrs: (dom) => {\n                        const result = { level: parseLevel(level) };\n                        const attrs = dom.getAttribute('data-bangle-attrs');\n                        if (!attrs) {\n                            return result;\n                        }\n                        const obj = JSON.parse(attrs);\n                        return Object.assign({}, result, obj);\n                    },\n                };\n            }),\n            toDOM: (node) => {\n                const result = [`h${node.attrs['level']}`, {}, 0];\n                if (node.attrs['collapseContent']) {\n                    result[1]['data-bangle-attrs'] = JSON.stringify({\n                        collapseContent: node.attrs['collapseContent'],\n                    });\n                    result[1]['class'] = 'bangle-heading-collapsed';\n                }\n                return result;\n            },\n        },\n        markdown: {\n            toMarkdown(state, node) {\n                state.write(state.repeat('#', node.attrs['level']) + ' ');\n                state.renderInline(node);\n                state.closeBlock(node);\n            },\n            parseMarkdown: {\n                heading: {\n                    block: name$8,\n                    getAttrs: (tok) => {\n                        return { level: parseLevel(tok.tag.slice(1)) };\n                    },\n                },\n            },\n        },\n        options,\n    };\n}\nfunction pluginsFactory$8({ markdownShortcut = true, keybindings = defaultKeys$5, } = {}) {\n    return ({ schema, specRegistry }) => {\n        const { levels } = specRegistry.options[name$8];\n        const type = getNodeType(schema, name$8);\n        const levelBindings = Object.fromEntries(levels.map((level) => [\n            keybindings[`toH${level}`],\n            setBlockType(type, { level }),\n        ]));\n        return [\n            keybindings &&\n                keymap({\n                    ...levelBindings,\n                    ...createObject([\n                        [keybindings['moveUp'], moveNode(type, 'UP')],\n                        [keybindings['moveDown'], moveNode(type, 'DOWN')],\n                        [keybindings['jumpToStartOfHeading'], jumpToStartOfNode(type)],\n                        [keybindings['jumpToEndOfHeading'], jumpToEndOfNode(type)],\n                        [keybindings['emptyCopy'], copyEmptyCommand(type)],\n                        [keybindings['emptyCut'], cutEmptyCommand(type)],\n                        [keybindings['insertEmptyParaAbove'], insertEmptyParaAbove()],\n                        [keybindings['insertEmptyParaBelow'], insertEmptyParaBelow()],\n                        [keybindings['toggleCollapse'], toggleHeadingCollapse()],\n                    ]),\n                }),\n            ...(markdownShortcut ? levels : []).map((level) => textblockTypeInputRule(new RegExp(`^(#{1,${level}})\\\\s$`), type, () => ({\n                level,\n            }))),\n        ];\n    };\n}\nfunction toggleHeading(level = 3) {\n    return (state, dispatch) => {\n        if (queryIsHeadingActive(level)(state)) {\n            const para = getParaNodeType(state);\n            return setBlockType(para)(state, dispatch);\n        }\n        return setBlockType(getNodeType(state, name$8), { level })(state, dispatch);\n    };\n}\nfunction queryIsHeadingActive(level) {\n    return (state) => {\n        const match = findParentNodeOfType(getNodeType(state, name$8))(state.selection);\n        if (!match) {\n            return false;\n        }\n        const { node } = match;\n        if (level == null) {\n            return true;\n        }\n        return node.attrs['level'] === level;\n    };\n}\nfunction queryIsCollapseActive() {\n    return (state) => {\n        const match = findParentNodeOfType(getNodeType(state, name$8))(state.selection);\n        if (!match || !isCollapsible(match)) {\n            return false;\n        }\n        return Boolean(match.node.attrs['collapseContent']);\n    };\n}\nfunction collapseHeading() {\n    return (state, dispatch) => {\n        const match = findParentNodeOfType(getNodeType(state, name$8))(state.selection);\n        if (!match || !isCollapsible(match)) {\n            return false;\n        }\n        const isCollapsed = queryIsCollapseActive()(state);\n        if (isCollapsed) {\n            return false;\n        }\n        const result = findCollapseFragment(match.node, state.doc);\n        if (!result) {\n            return false;\n        }\n        const { fragment, start, end } = result;\n        let tr = state.tr.replaceWith(start, end, getNodeType(state, name$8).createChecked({\n            ...match.node.attrs,\n            collapseContent: fragment.toJSON(),\n        }, match.node.content));\n        if (state.selection instanceof TextSelection) {\n            tr = tr.setSelection(TextSelection.create(tr.doc, state.selection.from));\n        }\n        if (dispatch) {\n            dispatch(tr);\n        }\n        return true;\n    };\n}\nfunction uncollapseHeading() {\n    return (state, dispatch) => {\n        const match = findParentNodeOfType(getNodeType(state, name$8))(state.selection);\n        if (!match || !isCollapsible(match)) {\n            return false;\n        }\n        const isCollapsed = queryIsCollapseActive()(state);\n        if (!isCollapsed) {\n            return false;\n        }\n        const frag = Fragment.fromJSON(state.schema, match.node.attrs['collapseContent']);\n        let tr = state.tr.replaceWith(match.pos, match.pos + match.node.nodeSize, Fragment.fromArray([\n            getNodeType(state, name$8).createChecked({\n                ...match.node.attrs,\n                collapseContent: null,\n            }, match.node.content),\n        ]).append(frag));\n        if (state.selection instanceof TextSelection) {\n            tr = tr.setSelection(TextSelection.create(tr.doc, state.selection.from));\n        }\n        if (dispatch) {\n            dispatch(tr);\n        }\n        return true;\n    };\n}\nfunction insertEmptyParaAbove() {\n    return filter(checkIsInHeading, (state, dispatch, view) => {\n        const para = getParaNodeType(state);\n        return insertEmpty(para, 'above', false)(state, dispatch, view);\n    });\n}\nfunction insertEmptyParaBelow() {\n    return filter(checkIsInHeading, (state, dispatch, view) => {\n        const para = getParaNodeType(state);\n        return insertEmpty(para, 'below', false)(state, dispatch, view);\n    });\n}\nfunction toggleHeadingCollapse() {\n    return (state, dispatch) => {\n        const match = findParentNodeOfType(getNodeType(state, name$8))(state.selection);\n        if (!match || match.depth !== 1) {\n            return false;\n        }\n        const isCollapsed = queryIsCollapseActive()(state);\n        return isCollapsed\n            ? uncollapseHeading()(state, dispatch)\n            : collapseHeading()(state, dispatch);\n    };\n}\nfunction uncollapseAllHeadings() {\n    return (state, dispatch) => {\n        const collapsibleNodes = listCollapsedHeading(state);\n        let tr = state.tr;\n        let offset = 0;\n        for (const { node, pos } of collapsibleNodes) {\n            let baseFrag = Fragment.fromJSON(state.schema, flattenFragmentJSON(node.attrs['collapseContent']));\n            tr = tr.replaceWith(offset + pos, offset + pos + node.nodeSize, Fragment.fromArray([\n                getNodeType(state, name$8).createChecked({\n                    ...node.attrs,\n                    collapseContent: null,\n                }, node.content),\n            ]).append(baseFrag));\n            offset += baseFrag.size;\n        }\n        if (state.selection instanceof TextSelection) {\n            tr = tr.setSelection(TextSelection.create(tr.doc, state.selection.from));\n        }\n        if (dispatch) {\n            dispatch(tr);\n        }\n        return true;\n    };\n}\nfunction listCollapsedHeading(state) {\n    return findChildren(state.doc, (node) => node.type === getNodeType(state, name$8) &&\n        Boolean(node.attrs['collapseContent']), false);\n}\nfunction listCollapsibleHeading(state) {\n    return findChildren(state.doc, (node) => node.type === getNodeType(state, name$8), false);\n}\nconst flattenFragmentJSON = (fragJSON) => {\n    let result = [];\n    fragJSON.forEach((nodeJSON) => {\n        if (nodeJSON['type'] === 'heading' && nodeJSON['attrs'].collapseContent) {\n            const collapseContent = nodeJSON['attrs'].collapseContent;\n            result.push({\n                ...nodeJSON,\n                attrs: {\n                    ...nodeJSON['attrs'],\n                    collapseContent: null,\n                },\n            });\n            result.push(...flattenFragmentJSON(collapseContent));\n        }\n        else {\n            result.push(nodeJSON);\n        }\n    });\n    return result;\n};\n// TODO\n/**\n *\n * collapse all headings of given level\n */\n// export function collapseHeadings(level) {}\n/**\n * Collapsible headings are only allowed at depth of 1\n */\nfunction isCollapsible(match) {\n    if (match.depth !== 1) {\n        return false;\n    }\n    return true;\n}\nfunction findCollapseFragment(matchNode, doc) {\n    // Find the last child that will be inside of the collapse\n    let start = undefined;\n    let end = undefined;\n    let isDone = false;\n    const breakCriteria = (node) => {\n        if (node.type !== matchNode.type) {\n            return false;\n        }\n        if (node.attrs['level'] <= matchNode.attrs['level']) {\n            return true;\n        }\n        return false;\n    };\n    doc.forEach((node, offset, index) => {\n        if (isDone) {\n            return;\n        }\n        if (node === matchNode) {\n            start = { index, offset, node };\n            return;\n        }\n        if (start) {\n            if (breakCriteria(node)) {\n                isDone = true;\n                return;\n            }\n            // Avoid including trailing empty nodes\n            // (like empty paragraphs inserted by trailing-node-plugins)\n            // This is done to prevent trailing-node from inserting a new empty node\n            // every time we toggle on off the collapse.\n            if (node.content.size !== 0) {\n                end = { index, offset, node };\n            }\n        }\n    });\n    if (!end) {\n        return null;\n    }\n    // We are not adding parents position (doc will be parent always) to\n    // the offsets since it will be 0\n    const slice = doc.slice(start.offset + start.node.nodeSize, \n    // @ts-ignore end was incorrectly inferred as \"never\" here\n    end.offset + end.node.nodeSize);\n    return {\n        fragment: slice.content,\n        start: start.offset,\n        // @ts-ignore end was incorrectly inferred as \"never\" here\n        end: end.offset + end.node.nodeSize,\n    };\n}\n\nvar heading = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec$8,\n    plugins: plugins$8,\n    commands: commands$7,\n    defaultKeys: defaultKeys$5,\n    toggleHeading: toggleHeading,\n    queryIsHeadingActive: queryIsHeadingActive,\n    queryIsCollapseActive: queryIsCollapseActive,\n    collapseHeading: collapseHeading,\n    uncollapseHeading: uncollapseHeading,\n    insertEmptyParaAbove: insertEmptyParaAbove,\n    insertEmptyParaBelow: insertEmptyParaBelow,\n    toggleHeadingCollapse: toggleHeadingCollapse,\n    uncollapseAllHeadings: uncollapseAllHeadings,\n    listCollapsedHeading: listCollapsedHeading,\n    listCollapsibleHeading: listCollapsibleHeading,\n    flattenFragmentJSON: flattenFragmentJSON\n});\n\nconst spec$7 = specFactory$7;\nconst plugins$7 = pluginsFactory$7;\nconst name$7 = 'horizontalRule';\nfunction specFactory$7() {\n    return {\n        type: 'node',\n        name: name$7,\n        schema: {\n            group: 'block',\n            parseDOM: [{ tag: 'hr' }],\n            toDOM: () => ['hr'],\n        },\n        markdown: {\n            toMarkdown(state, node) {\n                state.write(node.attrs['markup'] || '---');\n                state.closeBlock(node);\n            },\n            parseMarkdown: { hr: { node: name$7 } },\n        },\n    };\n}\nfunction pluginsFactory$7({ markdownShortcut = true } = {}) {\n    return ({ schema }) => {\n        const type = getNodeType(schema, name$7);\n        return [\n            markdownShortcut &&\n                new InputRule(/^(?:---|___\\s|\\*\\*\\*\\s)$/, (state, match, start, end) => {\n                    if (!match[0]) {\n                        return null;\n                    }\n                    let tr = state.tr.replaceWith(start - 1, end, type.createChecked());\n                    // Find the paragraph that contains the \"---\" shortcut text, we need\n                    // it below for deciding whether to insert a new paragraph after the\n                    // hr.\n                    const $para = state.doc.resolve(start);\n                    let insertParaAfter = false;\n                    if ($para.end() != end) {\n                        // if the paragraph has more characters, e.g. \"---abc\", then no\n                        // need to insert a new paragraph\n                        insertParaAfter = false;\n                    }\n                    else if ($para.after() == $para.end(-1)) {\n                        // if the paragraph is the last child of its parent, then insert a\n                        // new paragraph\n                        insertParaAfter = true;\n                    }\n                    else {\n                        const nextNode = state.doc.resolve($para.after()).nodeAfter;\n                        // if the next node is a hr, then insert a new paragraph\n                        insertParaAfter = nextNode.type === type;\n                    }\n                    return insertParaAfter\n                        ? safeInsert(getParaNodeType(state).createChecked(), tr.mapping.map($para.after()))(tr)\n                        : tr;\n                }),\n        ];\n    };\n}\n\nvar horizontalRule = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec$7,\n    plugins: plugins$7\n});\n\n// From Prosemirror https://github.com/prosemirror/prosemirror-markdown/blob/6107527995873d6199bc533a753b614378747056/src/to_markdown.ts#L380\n// Tries to wrap the string with `\"` , if not `''` else `()`\nfunction quote(str) {\n    var wrap = str.indexOf('\"') === -1 ? '\"\"' : str.indexOf(\"'\") === -1 ? \"''\" : '()';\n    return wrap[0] + str + wrap[1];\n}\n\nconst spec$6 = specFactory$6;\nconst plugins$6 = pluginsFactory$6;\nconst commands$6 = {};\nconst name$6 = 'image';\nfunction specFactory$6() {\n    return {\n        type: 'node',\n        name: name$6,\n        schema: {\n            inline: true,\n            attrs: {\n                src: {},\n                alt: {\n                    default: null,\n                },\n                title: {\n                    default: null,\n                },\n            },\n            group: 'inline',\n            draggable: true,\n            parseDOM: [\n                {\n                    tag: 'img[src]',\n                    getAttrs: (dom) => ({\n                        src: dom.getAttribute('src'),\n                        title: dom.getAttribute('title'),\n                        alt: dom.getAttribute('alt'),\n                    }),\n                },\n            ],\n            toDOM: (node) => {\n                return ['img', node.attrs];\n            },\n        },\n        markdown: {\n            toMarkdown(state, node) {\n                const text = state.esc(node.attrs['alt'] || '');\n                const url = state.esc(node.attrs['src']) +\n                    (node.attrs['title'] ? ' ' + quote(node.attrs['title']) : '');\n                state.write(`![${text}](${url})`);\n            },\n            parseMarkdown: {\n                image: {\n                    node: name$6,\n                    getAttrs: (tok) => ({\n                        src: tok.attrGet('src'),\n                        title: tok.attrGet('title') || null,\n                        alt: (tok.children[0] && tok.children[0].content) || null,\n                    }),\n                },\n            },\n        },\n    };\n}\nfunction pluginsFactory$6({ handleDragAndDrop = true, acceptFileType = 'image/*', createImageNodes = defaultCreateImageNodes, } = {}) {\n    return ({ schema }) => {\n        const type = getNodeType(schema, name$6);\n        return [\n            new InputRule(/!\\[(.+|:?)]\\((\\S+)(?:(?:\\s+)[\"'](\\S+)[\"'])?\\)/, (state, match, start, end) => {\n                let [, alt, src, title] = match;\n                if (!src) {\n                    return null;\n                }\n                if (!title) {\n                    title = alt;\n                }\n                return state.tr.replaceWith(start, end, type.create({\n                    src,\n                    alt,\n                    title,\n                }));\n            }),\n            handleDragAndDrop &&\n                new Plugin({\n                    key: new PluginKey(name$6 + '-drop-paste'),\n                    props: {\n                        handleDOMEvents: {\n                            drop(view, _event) {\n                                const event = _event;\n                                if (event.dataTransfer == null) {\n                                    return false;\n                                }\n                                const files = getFileData(event.dataTransfer, acceptFileType, true);\n                                // TODO should we handle all drops but just show error?\n                                // returning false here would just default to native behaviour\n                                // But then any drop handler would fail to work.\n                                if (!files || files.length === 0) {\n                                    return false;\n                                }\n                                event.preventDefault();\n                                const coordinates = view.posAtCoords({\n                                    left: event.clientX,\n                                    top: event.clientY,\n                                });\n                                createImageNodes(files, getNodeType(view.state, name$6), view).then((imageNodes) => {\n                                    addImagesToView(view, coordinates == null ? undefined : coordinates.pos, imageNodes);\n                                });\n                                return true;\n                            },\n                        },\n                        handlePaste: (view, rawEvent) => {\n                            const event = rawEvent;\n                            if (!event.clipboardData) {\n                                return false;\n                            }\n                            const files = getFileData(event.clipboardData, acceptFileType, true);\n                            if (!files || files.length === 0) {\n                                return false;\n                            }\n                            createImageNodes(files, getNodeType(view.state, name$6), view).then((imageNodes) => {\n                                addImagesToView(view, view.state.selection.from, imageNodes);\n                            });\n                            return true;\n                        },\n                    },\n                }),\n        ];\n    };\n}\nasync function defaultCreateImageNodes(files, imageType, _view) {\n    let resolveBinaryStrings = await Promise.all(files.map((file) => readFileAsBinaryString(file)));\n    return resolveBinaryStrings.map((binaryStr) => {\n        return imageType.create({\n            src: binaryStr,\n        });\n    });\n}\nfunction addImagesToView(view, pos, imageNodes) {\n    for (const node of imageNodes) {\n        const { tr } = view.state;\n        let newTr = safeInsert(node, pos)(tr);\n        if (newTr === tr) {\n            continue;\n        }\n        view.dispatch(newTr);\n    }\n}\nfunction readFileAsBinaryString(file) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        const onLoadBinaryString = (readerEvt) => {\n            const binarySrc = btoa(readerEvt.target.result);\n            resolve(`data:${file.type};base64,${binarySrc}`);\n        };\n        const onLoadDataUrl = (readerEvt) => {\n            resolve(readerEvt.target.result);\n        };\n        reader.onerror = () => {\n            reject(new Error('Error reading file' + file.name));\n        };\n        // Some browsers do not support this\n        if ('readAsDataURL' in reader) {\n            reader.onload = onLoadDataUrl;\n            reader.readAsDataURL(file);\n        }\n        else {\n            // @ts-ignore reader was incorrectly inferred as 'never'\n            reader.onload = onLoadBinaryString;\n            // @ts-ignore\n            reader.readAsBinaryString(file);\n        }\n    });\n}\nfunction getFileData(data, accept, multiple) {\n    const dragDataItems = getMatchingItems(data.items, accept, multiple);\n    const files = [];\n    dragDataItems.forEach((item) => {\n        const file = item && item.getAsFile();\n        if (file == null) {\n            return;\n        }\n        files.push(file);\n    });\n    return files;\n}\nfunction getMatchingItems(list, accept, multiple) {\n    const dataItems = Array.from(list);\n    let results;\n    // Return the first item (or undefined) if our filter is for all files\n    if (accept === '') {\n        results = dataItems.filter((item) => item.kind === 'file');\n        return multiple ? results : [results[0]];\n    }\n    const accepts = accept\n        .toLowerCase()\n        .split(',')\n        .map((accept) => {\n        return accept.split('/').map((part) => part.trim());\n    })\n        .filter((acceptParts) => acceptParts.length === 2); // Filter invalid values\n    const predicate = (item) => {\n        if (item.kind !== 'file') {\n            return false;\n        }\n        const [typeMain, typeSub] = item.type\n            .toLowerCase()\n            .split('/')\n            .map((s) => s.trim());\n        for (const [acceptMain, acceptSub] of accepts) {\n            // Look for an exact match, or a partial match if * is accepted, eg image/*.\n            if (typeMain === acceptMain &&\n                (acceptSub === '*' || typeSub === acceptSub)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    results = results = dataItems.filter(predicate);\n    if (multiple === false) {\n        results = [results[0]];\n    }\n    return results;\n}\nconst updateImageNodeAttribute = (attr = {}) => (state, dispatch) => {\n    if (!(state.selection instanceof NodeSelection) || !state.selection.node) {\n        return false;\n    }\n    const { node } = state.selection;\n    if (node.type !== getNodeType(state, name$6)) {\n        return false;\n    }\n    if (dispatch) {\n        dispatch(state.tr.setNodeMarkup(state.selection.$from.pos, undefined, {\n            ...node.attrs,\n            ...attr,\n        }));\n    }\n    return true;\n};\n\nvar image = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec$6,\n    plugins: plugins$6,\n    commands: commands$6,\n    updateImageNodeAttribute: updateImageNodeAttribute\n});\n\nconst spec$5 = specFactory$5;\nconst plugins$5 = pluginsFactory$5;\nconst commands$5 = {\n    toggleItalic,\n    queryIsItalicActive,\n};\nconst defaultKeys$4 = {\n    toggleItalic: 'Mod-i',\n};\nconst name$5 = 'italic';\nconst getTypeFromSchema$3 = (schema) => {\n    const markType = schema.marks[name$5];\n    assertNotUndefined(markType, `markType ${name$5} not found`);\n    return markType;\n};\nfunction specFactory$5() {\n    return {\n        type: 'mark',\n        name: name$5,\n        schema: {\n            parseDOM: [{ tag: 'i' }, { tag: 'em' }, { style: 'font-style=italic' }],\n            toDOM: () => ['em', 0],\n        },\n        markdown: {\n            toMarkdown: {\n                open: '_',\n                close: '_',\n                mixable: true,\n                expelEnclosingWhitespace: true,\n            },\n            parseMarkdown: {\n                em: { mark: name$5 },\n            },\n        },\n    };\n}\nfunction pluginsFactory$5({ keybindings = defaultKeys$4 } = {}) {\n    return ({ schema }) => {\n        const type = getTypeFromSchema$3(schema);\n        return [\n            markPasteRule$1(/_([^_]+)_/g, type),\n            markPasteRule$1(/\\*([^*]+)\\*/g, type),\n            markInputRule(/(?:^|\\s)((?:_)((?:[^_]+))(?:_))$/, type),\n            markInputRule(/(?:^|\\s)((?:\\*)((?:[^*]+))(?:\\*))$/, type),\n            keybindings &&\n                keymap(createObject([[keybindings.toggleItalic, toggleMark(type)]])),\n        ];\n    };\n}\nfunction toggleItalic() {\n    return (state, dispatch, _view) => {\n        const markType = state.schema.marks[name$5];\n        assertNotUndefined(markType, `markType ${name$5} not found`);\n        return toggleMark(markType)(state, dispatch);\n    };\n}\nfunction queryIsItalicActive() {\n    return (state) => {\n        const markType = state.schema.marks[name$5];\n        assertNotUndefined(markType, `markType ${name$5} not found`);\n        return isMarkActiveInSelection(markType)(state);\n    };\n}\n\nvar italic = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec$5,\n    plugins: plugins$5,\n    commands: commands$5,\n    defaultKeys: defaultKeys$4,\n    toggleItalic: toggleItalic,\n    queryIsItalicActive: queryIsItalicActive\n});\n\nconst spec$4 = specFactory$4;\nconst plugins$4 = pluginsFactory$4;\nconst commands$4 = {\n    createLink,\n    updateLink,\n    queryLinkAttrs,\n    queryIsLinkAllowedInRange,\n    queryIsLinkActive,\n    queryIsSelectionAroundLink,\n};\nconst name$4 = 'link';\nconst getTypeFromSchema$2 = (schema) => {\n    const markType = schema.marks[name$4];\n    assertNotUndefined(markType, `markType ${name$4} not found`);\n    return markType;\n};\nfunction specFactory$4({ openOnClick = false } = {}) {\n    return {\n        type: 'mark',\n        name: name$4,\n        schema: {\n            attrs: {\n                href: {\n                    default: null,\n                },\n            },\n            inclusive: false,\n            parseDOM: [\n                {\n                    tag: 'a[href]',\n                    getAttrs: (dom) => ({\n                        href: dom.getAttribute('href'),\n                    }),\n                },\n            ],\n            toDOM: (node) => [\n                'a',\n                {\n                    ...node.attrs,\n                    rel: 'noopener noreferrer nofollow',\n                },\n                0,\n            ],\n        },\n        markdown: {\n            toMarkdown: {\n                open(_state, mark, parent, index) {\n                    return isPlainURL(mark, parent, index, 1) ? '<' : '[';\n                },\n                close(state, mark, parent, index) {\n                    return isPlainURL(mark, parent, index, -1)\n                        ? '>'\n                        : '](' +\n                            state.esc(mark.attrs['href']) +\n                            (mark.attrs['title'] ? ' ' + quote(mark.attrs['title']) : '') +\n                            ')';\n                },\n            },\n            parseMarkdown: {\n                link: {\n                    mark: 'link',\n                    getAttrs: (tok) => ({\n                        href: tok.attrGet('href'),\n                        title: tok.attrGet('title') || null,\n                    }),\n                },\n            },\n        },\n        options: {\n            openOnClick,\n        },\n    };\n}\nfunction pluginsFactory$4() {\n    return ({ schema, specRegistry }) => {\n        // TODO why is this an option in schema\n        const { openOnClick } = specRegistry.options[name$4];\n        const type = getTypeFromSchema$2(schema);\n        return [\n            autoLinkInputRule(type),\n            pasteLink(/https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\\.[a-zA-Z]{2,}\\b([-a-zA-Z0-9@:%_+.~#?&//=]*)/g),\n            markPasteRule(/https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\\.[a-zA-Z]{2,}\\b([-a-zA-Z0-9@:%_+.~#?&//=]*)/g, type, (match) => ({ href: match })),\n            openOnClick &&\n                new Plugin({\n                    props: {\n                        handleClick: (view, _pos, event) => {\n                            const { schema } = view.state;\n                            const attrs = getMarkAttrs(view.state, getTypeFromSchema$2(schema));\n                            if (attrs['href'] && event.target instanceof HTMLAnchorElement) {\n                                event.stopPropagation();\n                                window.open(attrs['href']);\n                            }\n                            return false;\n                        },\n                    },\n                }),\n        ];\n    };\n}\n// scheme :: name :: tld\n// TLDs are from http://data.iana.org/TLD/tlds-alpha-by-domain.txt\nconst URL_REGEX = /(^|\\s)(((http|https|ftp):\\/\\/)?(?:[^\\s.:\\/]+\\.)+(?:aaa|aarp|abarth|abb|abbott|abbvie|abc|able|abogado|abudhabi|ac|academy|accenture|accountant|accountants|aco|actor|ad|adac|ads|adult|ae|aeg|aero|aetna|af|afamilycompany|afl|africa|ag|agakhan|agency|ai|aig|airbus|airforce|airtel|akdn|al|alfaromeo|alibaba|alipay|allfinanz|allstate|ally|alsace|alstom|am|amazon|americanexpress|americanfamily|amex|amfam|amica|amsterdam|analytics|android|anquan|anz|ao|aol|apartments|app|apple|aq|aquarelle|ar|arab|aramco|archi|army|arpa|art|arte|as|asda|asia|associates|at|athleta|attorney|au|auction|audi|audible|audio|auspost|author|auto|autos|avianca|aw|aws|ax|axa|az|azure|ba|baby|baidu|banamex|bananarepublic|band|bank|bar|barcelona|barclaycard|barclays|barefoot|bargains|baseball|basketball|bauhaus|bayern|bb|bbc|bbt|bbva|bcg|bcn|bd|be|beats|beauty|beer|bentley|berlin|best|bestbuy|bet|bf|bg|bh|bharti|bi|bible|bid|bike|bing|bingo|bio|biz|bj|black|blackfriday|blockbuster|blog|bloomberg|blue|bm|bms|bmw|bn|bnpparibas|bo|boats|boehringer|bofa|bom|bond|boo|book|booking|bosch|bostik|boston|bot|boutique|box|br|bradesco|bridgestone|broadway|broker|brother|brussels|bs|bt|budapest|bugatti|build|builders|business|buy|buzz|bv|bw|by|bz|bzh|ca|cab|cafe|cal|call|calvinklein|cam|camera|camp|cancerresearch|canon|capetown|capital|capitalone|car|caravan|cards|care|career|careers|cars|casa|case|cash|casino|cat|catering|catholic|cba|cbn|cbre|cbs|cc|cd|center|ceo|cern|cf|cfa|cfd|cg|ch|chanel|channel|charity|chase|chat|cheap|chintai|christmas|chrome|church|ci|cipriani|circle|cisco|citadel|citi|citic|city|cityeats|ck|cl|claims|cleaning|click|clinic|clinique|clothing|cloud|club|clubmed|cm|cn|co|coach|codes|coffee|college|cologne|com|comcast|commbank|community|company|compare|computer|comsec|condos|construction|consulting|contact|contractors|cooking|cookingchannel|cool|coop|corsica|country|coupon|coupons|courses|cpa|cr|credit|creditcard|creditunion|cricket|crown|crs|cruise|cruises|csc|cu|cuisinella|cv|cw|cx|cy|cymru|cyou|cz|dabur|dad|dance|data|date|dating|datsun|day|dclk|dds|de|deal|dealer|deals|degree|delivery|dell|deloitte|delta|democrat|dental|dentist|desi|design|dev|dhl|diamonds|diet|digital|direct|directory|discount|discover|dish|diy|dj|dk|dm|dnp|do|docs|doctor|dog|domains|dot|download|drive|dtv|dubai|duck|dunlop|dupont|durban|dvag|dvr|dz|earth|eat|ec|eco|edeka|edu|education|ee|eg|email|emerck|energy|engineer|engineering|enterprises|epson|equipment|er|ericsson|erni|es|esq|estate|et|etisalat|eu|eurovision|eus|events|exchange|expert|exposed|express|extraspace|fage|fail|fairwinds|faith|family|fan|fans|farm|farmers|fashion|fast|fedex|feedback|ferrari|ferrero|fi|fiat|fidelity|fido|film|final|finance|financial|fire|firestone|firmdale|fish|fishing|fit|fitness|fj|fk|flickr|flights|flir|florist|flowers|fly|fm|fo|foo|food|foodnetwork|football|ford|forex|forsale|forum|foundation|fox|fr|free|fresenius|frl|frogans|frontdoor|frontier|ftr|fujitsu|fun|fund|furniture|futbol|fyi|ga|gal|gallery|gallo|gallup|game|games|gap|garden|gay|gb|gbiz|gd|gdn|ge|gea|gent|genting|george|gf|gg|ggee|gh|gi|gift|gifts|gives|giving|gl|glade|glass|gle|global|globo|gm|gmail|gmbh|gmo|gmx|gn|godaddy|gold|goldpoint|golf|goo|goodyear|goog|google|gop|got|gov|gp|gq|gr|grainger|graphics|gratis|green|gripe|grocery|group|gs|gt|gu|guardian|gucci|guge|guide|guitars|guru|gw|gy|hair|hamburg|hangout|haus|hbo|hdfc|hdfcbank|health|healthcare|help|helsinki|here|hermes|hgtv|hiphop|hisamitsu|hitachi|hiv|hk|hkt|hm|hn|hockey|holdings|holiday|homedepot|homegoods|homes|homesense|honda|horse|hospital|host|hosting|hot|hoteles|hotels|hotmail|house|how|hr|hsbc|ht|hu|hughes|hyatt|hyundai|ibm|icbc|ice|icu|id|ie|ieee|ifm|ikano|il|im|imamat|imdb|immo|immobilien|in|inc|industries|infiniti|info|ing|ink|institute|insurance|insure|int|international|intuit|investments|io|ipiranga|iq|ir|irish|is|ismaili|ist|istanbul|it|itau|itv|jaguar|java|jcb|je|jeep|jetzt|jewelry|jio|jll|jm|jmp|jnj|jo|jobs|joburg|jot|joy|jp|jpmorgan|jprs|juegos|juniper|kaufen|kddi|ke|kerryhotels|kerrylogistics|kerryproperties|kfh|kg|kh|ki|kia|kim|kinder|kindle|kitchen|kiwi|km|kn|koeln|komatsu|kosher|kp|kpmg|kpn|kr|krd|kred|kuokgroup|kw|ky|kyoto|kz|la|lacaixa|lamborghini|lamer|lancaster|lancia|land|landrover|lanxess|lasalle|lat|latino|latrobe|law|lawyer|lb|lc|lds|lease|leclerc|lefrak|legal|lego|lexus|lgbt|li|lidl|life|lifeinsurance|lifestyle|lighting|like|lilly|limited|limo|lincoln|linde|link|lipsy|live|living|lixil|lk|llc|llp|loan|loans|locker|locus|loft|lol|london|lotte|lotto|love|lpl|lplfinancial|lr|ls|lt|ltd|ltda|lu|lundbeck|luxe|luxury|lv|ly|ma|macys|madrid|maif|maison|makeup|man|management|mango|map|market|marketing|markets|marriott|marshalls|maserati|mattel|mba|mc|mckinsey|md|me|med|media|meet|melbourne|meme|memorial|men|menu|merckmsd|mg|mh|miami|microsoft|mil|mini|mint|mit|mitsubishi|mk|ml|mlb|mls|mm|mma|mn|mo|mobi|mobile|moda|moe|moi|mom|monash|money|monster|mormon|mortgage|moscow|moto|motorcycles|mov|movie|mp|mq|mr|ms|msd|mt|mtn|mtr|mu|museum|mutual|mv|mw|mx|my|mz|na|nab|nagoya|name|natura|navy|nba|nc|ne|nec|net|netbank|netflix|network|neustar|new|news|next|nextdirect|nexus|nf|nfl|ng|ngo|nhk|ni|nico|nike|nikon|ninja|nissan|nissay|nl|no|nokia|northwesternmutual|norton|now|nowruz|nowtv|np|nr|nra|nrw|ntt|nu|nyc|nz|obi|observer|off|office|okinawa|olayan|olayangroup|oldnavy|ollo|om|omega|one|ong|onl|online|ooo|open|oracle|orange|org|organic|origins|osaka|otsuka|ott|ovh|pa|page|panasonic|paris|pars|partners|parts|party|passagens|pay|pccw|pe|pet|pf|pfizer|pg|ph|pharmacy|phd|philips|phone|photo|photography|photos|physio|pics|pictet|pictures|pid|pin|ping|pink|pioneer|pizza|pk|pl|place|play|playstation|plumbing|plus|pm|pn|pnc|pohl|poker|politie|porn|post|pr|pramerica|praxi|press|prime|pro|prod|productions|prof|progressive|promo|properties|property|protection|pru|prudential|ps|pt|pub|pw|pwc|py|qa|qpon|quebec|quest|qvc|racing|radio|raid|re|read|realestate|realtor|realty|recipes|red|redstone|redumbrella|rehab|reise|reisen|reit|reliance|ren|rent|rentals|repair|report|republican|rest|restaurant|review|reviews|rexroth|rich|richardli|ricoh|ril|rio|rip|rmit|ro|rocher|rocks|rodeo|rogers|room|rs|rsvp|ru|rugby|ruhr|run|rw|rwe|ryukyu|sa|saarland|safe|safety|sakura|sale|salon|samsclub|samsung|sandvik|sandvikcoromant|sanofi|sap|sarl|sas|save|saxo|sb|sbi|sbs|sc|sca|scb|schaeffler|schmidt|scholarships|school|schule|schwarz|science|scjohnson|scot|sd|se|search|seat|secure|security|seek|select|sener|services|ses|seven|sew|sex|sexy|sfr|sg|sh|shangrila|sharp|shaw|shell|shia|shiksha|shoes|shop|shopping|shouji|show|showtime|si|silk|sina|singles|site|sj|sk|ski|skin|sky|skype|sl|sling|sm|smart|smile|sn|sncf|so|soccer|social|softbank|software|sohu|solar|solutions|song|sony|soy|spa|space|sport|spot|sr|srl|ss|st|stada|staples|star|statebank|statefarm|stc|stcgroup|stockholm|storage|store|stream|studio|study|style|su|sucks|supplies|supply|support|surf|surgery|suzuki|sv|swatch|swiftcover|swiss|sx|sy|sydney|systems|sz|tab|taipei|talk|taobao|target|tatamotors|tatar|tattoo|tax|taxi|tc|tci|td|tdk|team|tech|technology|tel|temasek|tennis|teva|tf|tg|th|thd|theater|theatre|tiaa|tickets|tienda|tiffany|tips|tires|tirol|tj|tjmaxx|tjx|tk|tkmaxx|tl|tm|tmall|tn|to|today|tokyo|tools|top|toray|toshiba|total|tours|town|toyota|toys|tr|trade|trading|training|travel|travelchannel|travelers|travelersinsurance|trust|trv|tt|tube|tui|tunes|tushu|tv|tvs|tw|tz|ua|ubank|ubs|ug|uk|unicom|university|uno|uol|ups|us|uy|uz|va|vacations|vana|vanguard|vc|ve|vegas|ventures|verisign|versicherung|vet|vg|vi|viajes|video|vig|viking|villas|vin|vip|virgin|visa|vision|viva|vivo|vlaanderen|vn|vodka|volkswagen|volvo|vote|voting|voto|voyage|vu|vuelos|wales|walmart|walter|wang|wanggou|watch|watches|weather|weatherchannel|webcam|weber|website|wed|wedding|weibo|weir|wf|whoswho|wien|wiki|williamhill|win|windows|wine|winners|wme|wolterskluwer|woodside|work|works|world|wow|ws|wtc|wtf|xbox|xerox|xfinity|xihuan|xin|xn--11b4c3d|xn--1ck2e1b|xn--1qqw23a|xn--2scrj9c|xn--30rr7y|xn--3bst00m|xn--3ds443g|xn--3e0b707e|xn--3hcrj9c|xn--3oq18vl8pn36a|xn--3pxu8k|xn--42c2d9a|xn--45br5cyl|xn--45brj9c|xn--45q11c|xn--4dbrk0ce|xn--4gbrim|xn--54b7fta0cc|xn--55qw42g|xn--55qx5d|xn--5su34j936bgsg|xn--5tzm5g|xn--6frz82g|xn--6qq986b3xl|xn--80adxhks|xn--80ao21a|xn--80aqecdr1a|xn--80asehdb|xn--80aswg|xn--8y0a063a|xn--90a3ac|xn--90ae|xn--90ais|xn--9dbq2a|xn--9et52u|xn--9krt00a|xn--b4w605ferd|xn--bck1b9a5dre4c|xn--c1avg|xn--c2br7g|xn--cck2b3b|xn--cckwcxetd|xn--cg4bki|xn--clchc0ea0b2g2a9gcd|xn--czr694b|xn--czrs0t|xn--czru2d|xn--d1acj3b|xn--d1alf|xn--e1a4c|xn--eckvdtc9d|xn--efvy88h|xn--fct429k|xn--fhbei|xn--fiq228c5hs|xn--fiq64b|xn--fiqs8s|xn--fiqz9s|xn--fjq720a|xn--flw351e|xn--fpcrj9c3d|xn--fzc2c9e2c|xn--fzys8d69uvgm|xn--g2xx48c|xn--gckr3f0f|xn--gecrj9c|xn--gk3at1e|xn--h2breg3eve|xn--h2brj9c|xn--h2brj9c8c|xn--hxt814e|xn--i1b6b1a6a2e|xn--imr513n|xn--io0a7i|xn--j1aef|xn--j1amh|xn--j6w193g|xn--jlq480n2rg|xn--jlq61u9w7b|xn--jvr189m|xn--kcrx77d1x4a|xn--kprw13d|xn--kpry57d|xn--kput3i|xn--l1acc|xn--lgbbat1ad8j|xn--mgb9awbf|xn--mgba3a3ejt|xn--mgba3a4f16a|xn--mgba7c0bbn0a|xn--mgbaakc7dvf|xn--mgbaam7a8h|xn--mgbab2bd|xn--mgbah1a3hjkrd|xn--mgbai9azgqp6j|xn--mgbayh7gpa|xn--mgbbh1a|xn--mgbbh1a71e|xn--mgbc0a9azcg|xn--mgbca7dzdo|xn--mgbcpq6gpa1a|xn--mgberp4a5d4ar|xn--mgbgu82a|xn--mgbi4ecexp|xn--mgbpl2fh|xn--mgbt3dhd|xn--mgbtx2b|xn--mgbx4cd0ab|xn--mix891f|xn--mk1bu44c|xn--mxtq1m|xn--ngbc5azd|xn--ngbe9e0a|xn--ngbrx|xn--node|xn--nqv7f|xn--nqv7fs00ema|xn--nyqy26a|xn--o3cw4h|xn--ogbpf8fl|xn--otu796d|xn--p1acf|xn--p1ai|xn--pgbs0dh|xn--pssy2u|xn--q7ce6a|xn--q9jyb4c|xn--qcka1pmc|xn--qxa6a|xn--qxam|xn--rhqv96g|xn--rovu88b|xn--rvc1e0am3e|xn--s9brj9c|xn--ses554g|xn--t60b56a|xn--tckwe|xn--tiq49xqyj|xn--unup4y|xn--vermgensberater-ctb|xn--vermgensberatung-pwb|xn--vhquv|xn--vuq861b|xn--w4r85el8fhu5dnra|xn--w4rs40l|xn--wgbh1c|xn--wgbl6a|xn--xhq521b|xn--xkc2al3hye2a|xn--xkc2dl3a5ee0h|xn--y9a3aq|xn--yfro4i67o|xn--ygbi2ammx|xn--zfr164b|xxx|xyz|yachts|yahoo|yamaxun|yandex|ye|yodobashi|yoga|yokohama|you|youtube|yt|yun|za|zappos|zara|zero|zip|zm|zone|zuerich|zw))\\s$/;\nfunction autoLinkInputRule(type) {\n    return new InputRule(URL_REGEX, (state, match, start, end) => {\n        if (!match[0]) {\n            return null;\n        }\n        const [_, leadingSpace, text, scheme] = match;\n        if (!leadingSpace) {\n            // Do nothing if there is already a link within [start, end]. This is for\n            // cases like \"<link>abc.com</link>def.com[]\". In such case typing a space\n            // after def.com should not auto link.\n            let ignore = false;\n            state.doc.nodesBetween(start, end, (node) => {\n                if (ignore) {\n                    return false;\n                }\n                if (type.isInSet(node.marks)) {\n                    ignore = true;\n                    return false;\n                }\n                return true;\n            });\n            if (ignore) {\n                return null;\n            }\n        }\n        // If no scheme, use default scheme \"http://\". Most https sites would do a\n        // redirect for http request anyway.\n        const href = scheme ? text : `http://${text}`;\n        const tr = state.tr;\n        tr.addMark(\n        // Ignore the leading space, if any\n        leadingSpace && leadingSpace.length > 0 ? start + 1 : start, end, type.create({ href: href }));\n        // Append the space after the link\n        tr.insertText(' ', end);\n        return tr;\n    });\n}\nfunction pasteLink(regexp) {\n    return new Plugin({\n        props: {\n            handlePaste: function handlePastedLink(view, rawEvent) {\n                const event = rawEvent;\n                if (!event.clipboardData) {\n                    return false;\n                }\n                let text = event.clipboardData.getData('text/plain');\n                const html = event.clipboardData.getData('text/html');\n                const isPlainText = text && !html;\n                if (!isPlainText || view.state.selection.empty) {\n                    return false;\n                }\n                const { state, dispatch } = view;\n                const match = matchAllPlus(regexp, text);\n                const singleMatch = match.length === 1 && match.every((m) => m.match);\n                // Only handle if paste has one URL\n                if (!singleMatch) {\n                    return false;\n                }\n                return createLink(text)(state, dispatch);\n            },\n        },\n    });\n}\nfunction markPasteRule(regexp, type, getAttrs) {\n    return new Plugin({\n        props: {\n            transformPasted: function transformPasted(slice) {\n                return mapSlice(slice, (node) => {\n                    if (!node.isText) {\n                        return node;\n                    }\n                    const text = node.text;\n                    const matches = matchAllPlus(regexp, text);\n                    return matches.map(({ start, end, match, subString }) => {\n                        let newNode = node.cut(start, end);\n                        if (match) {\n                            var attrs = getAttrs instanceof Function ? getAttrs(subString) : getAttrs;\n                            newNode = newNode.mark(type.create(attrs).addToSet(node.marks));\n                        }\n                        return newNode;\n                    });\n                });\n            },\n        },\n    });\n}\nfunction isPlainURL(link, parent, index, side) {\n    if (link.attrs['title'] || !/^\\w+:/.test(link.attrs['href'])) {\n        return false;\n    }\n    let content = parent.child(index + (side < 0 ? -1 : 0));\n    if (!content.isText ||\n        content.text !== link.attrs['href'] ||\n        content.marks[content.marks.length - 1] !== link) {\n        return false;\n    }\n    if (index === (side < 0 ? 1 : parent.childCount - 1)) {\n        return true;\n    }\n    let next = parent.child(index + (side < 0 ? -2 : 1));\n    return !link.isInSet(next.marks);\n}\nfunction isTextAtPos(pos) {\n    return (state) => {\n        const node = state.doc.nodeAt(pos);\n        return !!node && node.isText;\n    };\n}\nfunction setLink(from, to, href) {\n    href = href && href.trim();\n    return filter((state) => isTextAtPos(from)(state), (state, dispatch) => {\n        const linkMark = getTypeFromSchema$2(state.schema);\n        let tr = state.tr.removeMark(from, to, linkMark);\n        if (href) {\n            const mark = getTypeFromSchema$2(state.schema).create({\n                href: href,\n            });\n            tr.addMark(from, to, mark);\n        }\n        if (dispatch) {\n            dispatch(tr);\n        }\n        return true;\n    });\n}\n/**\n *\n * Commands\n *\n */\n/**\n * Sets the selection to href\n * @param {*} href\n */\nfunction createLink(href) {\n    return filter((state) => queryIsLinkAllowedInRange(state.selection.$from.pos, state.selection.$to.pos)(state), (state, dispatch) => {\n        const [from, to] = [state.selection.$from.pos, state.selection.$to.pos];\n        const linkMark = getTypeFromSchema$2(state.schema);\n        let tr = state.tr.removeMark(from, to, linkMark);\n        if (href.trim()) {\n            const mark = getTypeFromSchema$2(state.schema).create({\n                href: href,\n            });\n            tr.addMark(from, to, mark);\n        }\n        if (dispatch) {\n            dispatch(tr);\n        }\n        return true;\n    });\n}\nfunction updateLink(href) {\n    return (state, dispatch) => {\n        if (!state.selection.empty) {\n            return setLink(state.selection.$from.pos, state.selection.$to.pos, href)(state, dispatch);\n        }\n        const { $from } = state.selection;\n        const pos = $from.pos - $from.textOffset;\n        const node = state.doc.nodeAt(pos);\n        let to = pos;\n        if (node) {\n            to += node.nodeSize;\n        }\n        return setLink(pos, to, href)(state, dispatch);\n    };\n}\nfunction queryLinkAttrs() {\n    return (state) => {\n        const { $from } = state.selection;\n        const pos = $from.pos - $from.textOffset;\n        const $pos = state.doc.resolve(pos);\n        const node = state.doc.nodeAt(pos);\n        const { nodeAfter } = $pos;\n        if (!nodeAfter) {\n            return undefined;\n        }\n        const type = getTypeFromSchema$2(state.schema);\n        const mark = type.isInSet(nodeAfter.marks || []);\n        if (mark) {\n            return {\n                href: mark.attrs['href'],\n                text: node.textContent,\n            };\n        }\n        return undefined;\n    };\n}\nfunction queryIsLinkAllowedInRange(from, to) {\n    return (state) => {\n        const $from = state.doc.resolve(from);\n        const $to = state.doc.resolve(to);\n        const link = getTypeFromSchema$2(state.schema);\n        if ($from.parent === $to.parent && $from.parent.isTextblock) {\n            return $from.parent.type.allowsMarkType(link);\n        }\n        return undefined;\n    };\n}\nfunction queryIsLinkActive() {\n    return (state) => Boolean(getTypeFromSchema$2(state.schema).isInSet(state.selection.$from.marks()));\n}\nfunction queryIsSelectionAroundLink() {\n    return (state) => {\n        const { $from, $to } = state.selection;\n        const node = $from.nodeAfter;\n        return (!!node &&\n            $from.textOffset === 0 &&\n            $to.pos - $from.pos === node.nodeSize &&\n            Boolean(getTypeFromSchema$2(state.schema).isInSet(node.marks)));\n    };\n}\n\nvar link = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec$4,\n    plugins: plugins$4,\n    commands: commands$4,\n    URL_REGEX: URL_REGEX,\n    createLink: createLink,\n    updateLink: updateLink,\n    queryLinkAttrs: queryLinkAttrs,\n    queryIsLinkAllowedInRange: queryIsLinkAllowedInRange,\n    queryIsLinkActive: queryIsLinkActive,\n    queryIsSelectionAroundLink: queryIsSelectionAroundLink\n});\n\nlet log = () => { };\nfunction listItemNodeViewPlugin(name) {\n    const checkParentBulletList = (state, pos) => {\n        if (pos === undefined) {\n            return false;\n        }\n        return state.doc.resolve(pos).parent.type.name === 'bulletList';\n    };\n    const removeCheckbox = (instance) => {\n        // already removed\n        if (!instance.containerDOM.hasAttribute('data-bangle-is-todo')) {\n            return;\n        }\n        instance.containerDOM.removeAttribute('data-bangle-is-todo');\n        instance.containerDOM.removeChild(instance.containerDOM.firstChild);\n    };\n    const setupCheckbox = (attrs, updateAttrs, instance) => {\n        // no need to create as it is already created\n        if (instance.containerDOM.hasAttribute('data-bangle-is-todo')) {\n            return;\n        }\n        const checkbox = createCheckbox(attrs['todoChecked'], (newValue) => {\n            updateAttrs({\n                // Fetch latest attrs as the one in outer\n                // closure can be stale.\n                todoChecked: newValue,\n            });\n        });\n        instance.containerDOM.setAttribute('data-bangle-is-todo', '');\n        instance.containerDOM.prepend(checkbox);\n    };\n    const createCheckbox = (todoChecked, onUpdate) => {\n        const checkBox = createElement([\n            'span',\n            // @ts-ignore DOMOutputSpec from @types/prosemirror-model is buggy\n            { contentEditable: false },\n            [\n                'input',\n                {\n                    type: 'checkbox',\n                },\n            ],\n        ]);\n        const inputElement = checkBox.querySelector('input');\n        if (todoChecked) {\n            inputElement.setAttribute('checked', '');\n        }\n        inputElement.addEventListener('input', (_event) => {\n            log('change event', inputElement.checked);\n            onUpdate(\n            // note:  inputElement.checked is a bool\n            inputElement.checked);\n        });\n        return checkBox;\n    };\n    return NodeView.createPlugin({\n        name,\n        containerDOM: [\n            'li',\n            {\n                // To style our todo friend different than a regular li\n                'data-bangle-name': name,\n            },\n        ],\n        contentDOM: ['span', {}],\n        renderHandlers: {\n            create: (instance, { attrs, updateAttrs, getPos, view }) => {\n                const todoChecked = attrs['todoChecked'];\n                // branch if todo needs to be created\n                if (todoChecked != null) {\n                    // todo only makes sense if parent is bullet list\n                    if (checkParentBulletList(view.state, getPos())) {\n                        setupCheckbox(attrs, updateAttrs, instance);\n                    }\n                }\n                // Connect the two contentDOM and containerDOM for pm to write to\n                instance.containerDOM.appendChild(instance.contentDOM);\n            },\n            // We need to achieve a two way binding of the todoChecked state.\n            // First binding: dom -> editor : done by  inputElement's `input` event listener\n            // Second binding: editor -> dom: Done by the `update` handler below\n            update: (instance, { attrs, view, getPos, updateAttrs }) => {\n                const { todoChecked } = attrs;\n                if (todoChecked == null) {\n                    removeCheckbox(instance);\n                    return;\n                }\n                // if parent is not bulletList i.e. it is orderedList\n                if (!checkParentBulletList(view.state, getPos())) {\n                    return;\n                }\n                // assume nothing about the dom elements state.\n                // for example it is possible that the checkbox is not created\n                // when a regular list is converted to todo list only update handler\n                // will be called. The create handler was called in the past\n                // but without the checkbox element, hence the checkbox wont be there\n                setupCheckbox(attrs, updateAttrs, instance);\n                const checkbox = instance.containerDOM.firstChild\n                    .firstChild;\n                checkbox.checked = todoChecked;\n            },\n            destroy: () => { },\n        },\n    });\n}\n\nconst spec$3 = specFactory$3;\nconst plugins$3 = pluginsFactory$3;\nconst commands$3 = {\n    indentListItem,\n    outdentListItem,\n    moveListItemUp,\n    moveListItemDown,\n};\nconst defaultKeys$3 = {\n    toggleDone: browser.mac ? 'Ctrl-Enter' : 'Ctrl-I',\n    indent: 'Tab',\n    outdent: 'Shift-Tab',\n    moveDown: 'Alt-ArrowDown',\n    moveUp: 'Alt-ArrowUp',\n    emptyCopy: 'Mod-c',\n    emptyCut: 'Mod-x',\n    insertEmptyListAbove: 'Mod-Shift-Enter',\n    insertEmptyListBelow: 'Mod-Enter',\n};\nconst name$3 = 'listItem';\nconst isValidList = (state) => {\n    const type = getNodeType(state, name$3);\n    return parentHasDirectParentOfType(type, [\n        getNodeType(state, 'bulletList'),\n        getNodeType(state, 'orderedList'),\n    ]);\n};\nfunction specFactory$3() {\n    const { toDOM, parseDOM } = domSerializationHelpers(name$3, {\n        tag: 'li',\n        // @ts-ignore DOMOutputSpec in @types is buggy\n        content: 0,\n    });\n    return {\n        type: 'node',\n        name: name$3,\n        schema: {\n            content: '(paragraph) (paragraph | bulletList | orderedList)*',\n            defining: true,\n            draggable: true,\n            attrs: {\n                // We overload the todoChecked value to\n                // decide if its a regular bullet list or a list with todo\n                // todoChecked can take following values:\n                //   null => regular bullet list\n                //   true => todo list with checked\n                //   false => todo list with no check\n                todoChecked: {\n                    default: null,\n                },\n            },\n            toDOM,\n            parseDOM,\n        },\n        markdown: {\n            toMarkdown(state, node) {\n                if (node.attrs['todoChecked'] != null) {\n                    state.write(node.attrs['todoChecked'] ? '[x] ' : '[ ] ');\n                }\n                state.renderContent(node);\n            },\n            parseMarkdown: {\n                list_item: {\n                    block: name$3,\n                    getAttrs: (tok) => {\n                        let todoChecked = null;\n                        const todoIsDone = tok.attrGet('isDone');\n                        if (todoIsDone === 'yes') {\n                            todoChecked = true;\n                        }\n                        else if (todoIsDone === 'no') {\n                            todoChecked = false;\n                        }\n                        return {\n                            todoChecked,\n                        };\n                    },\n                },\n            },\n        },\n    };\n}\nfunction pluginsFactory$3({ keybindings = defaultKeys$3, nodeView = true, } = {}) {\n    return ({ schema }) => {\n        const type = getNodeType(schema, name$3);\n        return [\n            keybindings &&\n                keymap({\n                    [keybindings.toggleDone]: filter(isValidList, updateNodeAttrs(getNodeType(schema, 'listItem'), (attrs) => ({\n                        ...attrs,\n                        todoChecked: attrs['todoChecked'] == null ? false : !attrs['todoChecked'],\n                    }))),\n                    Backspace: backspaceKeyCommand(type),\n                    Enter: enterKeyCommand(type),\n                    ...createObject([\n                        [keybindings.indent, indentListItem()],\n                        [keybindings.outdent, outdentListItem()],\n                        [keybindings.moveUp, moveListItemUp()],\n                        [keybindings.moveDown, moveListItemDown()],\n                        [keybindings.emptyCut, filter(isValidList, cutEmptyCommand(type))],\n                        [\n                            keybindings.emptyCopy,\n                            filter(isValidList, copyEmptyCommand(type)),\n                        ],\n                        [keybindings.insertEmptyListAbove, insertEmptySiblingListAbove()],\n                        [keybindings.insertEmptyListBelow, insertEmptySiblingListBelow()],\n                    ]),\n                }),\n            nodeView && listItemNodeViewPlugin(name$3),\n        ];\n    };\n}\nfunction indentListItem() {\n    return (state, dispatch) => {\n        const type = getNodeType(state, name$3);\n        return indentList(type)(state, dispatch);\n    };\n}\nfunction outdentListItem() {\n    return (state, dispatch, view) => {\n        const type = getNodeType(state, name$3);\n        return outdentList(type)(state, dispatch, view);\n    };\n}\nconst isSelectionInsideTodo = (state) => {\n    return isNodeTodo(state.selection.$from.node(-1), state.schema);\n};\nfunction moveListItem(dir) {\n    return (state, dispatch, view) => {\n        const type = getNodeType(state, name$3);\n        const isBulletList = parentHasDirectParentOfType(type, [\n            getNodeType(state, 'bulletList'),\n            getNodeType(state, 'orderedList'),\n        ]);\n        const move = (dir) => chainCommands(moveNode(type, dir), (state, dispatch, view) => {\n            const node = state.selection.$from.node(-3);\n            const isParentTodo = isNodeTodo(node, state.schema);\n            const result = moveEdgeListItem(type, dir)(state, dispatch, view);\n            if (!result) {\n                return false;\n            }\n            // if parent was a todo convert the moved edge node\n            // to todo bullet item\n            if (isParentTodo && dispatch) {\n                const state = view.state;\n                let { tr, schema } = state;\n                tr = setTodoCheckedAttr(tr, schema, state.selection.$from.node(-1), state.selection.$from.before(-1));\n                dispatch(tr);\n            }\n            return true;\n        });\n        return filter(isBulletList, move(dir))(state, dispatch, view);\n    };\n}\nfunction moveListItemUp() {\n    return moveListItem('UP');\n}\nfunction moveListItemDown() {\n    return moveListItem('DOWN');\n}\nfunction insertEmptySiblingList(isAbove = true) {\n    return (state, dispatch, view) => {\n        const type = getNodeType(state, name$3);\n        return chainCommands(filter(isSelectionInsideTodo, insertEmpty(type, isAbove ? 'above' : 'below', true, {\n            todoChecked: false,\n        })), filter(isValidList, insertEmpty(type, isAbove ? 'above' : 'below', true)))(state, dispatch, view);\n    };\n}\nfunction insertEmptySiblingListAbove() {\n    return insertEmptySiblingList(true);\n}\nfunction insertEmptySiblingListBelow() {\n    return insertEmptySiblingList(false);\n}\n\nvar listItemComponent = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec$3,\n    plugins: plugins$3,\n    commands: commands$3,\n    defaultKeys: defaultKeys$3,\n    indentListItem: indentListItem,\n    outdentListItem: outdentListItem,\n    moveListItemUp: moveListItemUp,\n    moveListItemDown: moveListItemDown,\n    insertEmptySiblingList: insertEmptySiblingList,\n    insertEmptySiblingListAbove: insertEmptySiblingListAbove,\n    insertEmptySiblingListBelow: insertEmptySiblingListBelow\n});\n\nconst spec$2 = specFactory$2;\nconst plugins$2 = pluginsFactory$2;\nconst commands$2 = {\n    toggleOrderedList,\n    queryIsOrderedListActive,\n};\nconst defaultKeys$2 = {\n    toggle: 'Shift-Ctrl-9',\n};\nconst name$2 = 'orderedList';\nfunction specFactory$2() {\n    return {\n        type: 'node',\n        name: name$2,\n        schema: {\n            attrs: {\n                order: {\n                    default: 1,\n                },\n                // a style preference attribute which be used for\n                // rendering output.\n                // For example markdown serializer can render a new line in\n                // between or not.\n                tight: {\n                    default: false,\n                },\n            },\n            content: 'listItem+',\n            group: 'block',\n            parseDOM: [\n                {\n                    tag: 'ol',\n                    getAttrs: (dom) => ({\n                        order: dom.hasAttribute('start') ? +dom.getAttribute('start') : 1,\n                    }),\n                },\n            ],\n            toDOM: (node) => node.attrs['order'] === 1\n                ? ['ol', 0]\n                : ['ol', { start: node.attrs['order'] }, 0],\n        },\n        markdown: {\n            toMarkdown(state, node) {\n                let start = node.attrs['order'] || 1;\n                let maxW = String(start + node.childCount - 1).length;\n                let space = state.repeat(' ', maxW + 2);\n                state.renderList(node, space, (i) => {\n                    let nStr = String(start + i);\n                    return state.repeat(' ', maxW - nStr.length) + nStr + '. ';\n                });\n            },\n            parseMarkdown: {\n                ordered_list: {\n                    block: name$2,\n                    getAttrs: (tok, tokens, i) => {\n                        var _a;\n                        return {\n                            tight: listIsTight(tokens, i),\n                            order: +((_a = tok.attrGet('start')) !== null && _a !== void 0 ? _a : 1),\n                        };\n                    },\n                },\n            },\n        },\n    };\n}\nfunction pluginsFactory$2({ keybindings = defaultKeys$2 } = {}) {\n    return ({ schema }) => {\n        const type = getNodeType(schema, name$2);\n        return [\n            wrappingInputRule(/^(1)[.)]\\s$/, type, (match) => ({ order: +match[1] }), (match, node) => node.childCount + node.attrs['order'] === +match[1]),\n            keybindings &&\n                keymap(createObject([[keybindings.toggle, toggleList(type)]])),\n        ];\n    };\n}\nfunction toggleOrderedList() {\n    return (state, dispatch, view) => {\n        return toggleList(getNodeType(state, name$2), getNodeType(state, 'listItem'))(state, dispatch, view);\n    };\n}\nfunction queryIsOrderedListActive() {\n    return (state) => {\n        return parentHasDirectParentOfType(getNodeType(state, 'listItem'), [\n            getNodeType(state, name$2),\n        ])(state);\n    };\n}\n\nvar orderedList = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec$2,\n    plugins: plugins$2,\n    commands: commands$2,\n    defaultKeys: defaultKeys$2,\n    toggleOrderedList: toggleOrderedList,\n    queryIsOrderedListActive: queryIsOrderedListActive\n});\n\nconst spec$1 = specFactory$1;\nconst plugins$1 = pluginsFactory$1;\nconst commands$1 = {\n    toggleStrike,\n    queryIsStrikeActive,\n};\nconst defaultKeys$1 = {\n    toggleStrike: 'Mod-d',\n};\nconst name$1 = 'strike';\nconst getTypeFromSchema$1 = (schema) => {\n    const markType = schema.marks[name$1];\n    assertNotUndefined(markType, `markType ${name$1} not found`);\n    return markType;\n};\nfunction specFactory$1() {\n    return {\n        type: 'mark',\n        name: name$1,\n        schema: {\n            parseDOM: [\n                {\n                    tag: 's',\n                },\n                {\n                    tag: 'del',\n                },\n                {\n                    tag: 'strike',\n                },\n                {\n                    style: 'text-decoration',\n                    getAttrs: (value) => value === 'line-through' && null,\n                },\n            ],\n            toDOM: () => ['s', 0],\n        },\n        markdown: {\n            toMarkdown: {\n                open: '~~',\n                close: '~~',\n                mixable: true,\n                expelEnclosingWhitespace: true,\n            },\n            parseMarkdown: {\n                s: { mark: 'strike' },\n            },\n        },\n    };\n}\nfunction pluginsFactory$1({ keybindings = defaultKeys$1 } = {}) {\n    return ({ schema }) => {\n        const type = getTypeFromSchema$1(schema);\n        return [\n            markPasteRule$1(/(?:^|\\s)((?:~~)((?:[^~]+))(?:~~))/g, type),\n            markInputRule(/(?:^|\\s)((?:~~)((?:[^~]+))(?:~~))$/, type),\n            keybindings &&\n                keymap(createObject([[keybindings.toggleStrike, toggleMark(type)]])),\n        ];\n    };\n}\nfunction toggleStrike() {\n    return (state, dispatch, _view) => {\n        const markType = state.schema.marks[name$1];\n        assertNotUndefined(markType, `markType ${name$1} not found`);\n        return toggleMark(markType)(state, dispatch);\n    };\n}\nfunction queryIsStrikeActive() {\n    return (state) => {\n        const markType = state.schema.marks[name$1];\n        assertNotUndefined(markType, `markType ${name$1} not found`);\n        return isMarkActiveInSelection(markType)(state);\n    };\n}\n\nvar strike = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec$1,\n    plugins: plugins$1,\n    commands: commands$1,\n    defaultKeys: defaultKeys$1,\n    toggleStrike: toggleStrike,\n    queryIsStrikeActive: queryIsStrikeActive\n});\n\nconst spec = specFactory;\nconst plugins = pluginsFactory;\nconst commands = {\n    toggleUnderline,\n    queryIsUnderlineActive,\n};\nconst defaultKeys = {\n    toggleUnderline: 'Mod-u',\n};\nconst name = 'underline';\nconst getTypeFromSchema = (schema) => {\n    const markType = schema.marks[name];\n    assertNotUndefined(markType, `markType ${name} not found`);\n    return markType;\n};\nfunction specFactory() {\n    return {\n        type: 'mark',\n        name,\n        schema: {\n            parseDOM: [\n                {\n                    tag: 'u',\n                },\n                {\n                    style: 'text-decoration',\n                    getAttrs: (value) => value === name && null,\n                },\n            ],\n            toDOM: () => ['u', 0],\n        },\n        markdown: {\n            // TODO underline is not a real thing in markdown, what is the best option here?\n            // I know this is cheating, but underlines are confusing\n            // this moves them italic\n            toMarkdown: {\n                open: '_',\n                close: '_',\n                mixable: true,\n                expelEnclosingWhitespace: true,\n            },\n        },\n    };\n}\nfunction pluginsFactory({ keybindings = defaultKeys } = {}) {\n    return ({ schema }) => {\n        const type = getTypeFromSchema(schema);\n        return [\n            markInputRule(/~([^~]+)~$/, type),\n            markPasteRule$1(/~([^~]+)~/g, type),\n            keybindings\n                ? keymap(createObject([[keybindings.toggleUnderline, toggleMark(type)]]))\n                : undefined,\n        ];\n    };\n}\nfunction toggleUnderline() {\n    return (state, dispatch, _view) => {\n        const markType = state.schema.marks[name];\n        assertNotUndefined(markType, `markType ${name} not found`);\n        return toggleMark(markType)(state, dispatch);\n    };\n}\nfunction queryIsUnderlineActive() {\n    return (state) => {\n        const markType = state.schema.marks[name];\n        assertNotUndefined(markType, `markType ${name} not found`);\n        return isMarkActiveInSelection(markType)(state);\n    };\n}\n\nvar underline = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec,\n    plugins: plugins,\n    commands: commands,\n    defaultKeys: defaultKeys,\n    toggleUnderline: toggleUnderline,\n    queryIsUnderlineActive: queryIsUnderlineActive\n});\n\nexport { blockquote, bold, bulletList, code, codeBlock, hardBreak, heading, horizontalRule, image, italic, link, listItemComponent as listItem, orderedList, strike, underline };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,aAAa;AAAA,EACf;AAAA,EACA;AACJ;AACA,IAAM,gBAAgB;AAAA,EAClB,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,WAAW;AAAA,EACX,UAAU;AAAA,EACV,sBAAsB;AAAA,EACtB,sBAAsB;AAC1B;AACA,IAAM,SAAS;AACf,SAAS,gBAAgB;AACrB,SAAO;AAAA,IACH,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,MACJ,SAAS;AAAA,MACT,OAAO;AAAA,MACP,UAAU;AAAA,MACV,WAAW;AAAA,MACX,UAAU,CAAC,EAAE,KAAK,aAAa,CAAC;AAAA,MAChC,OAAO,MAAM;AACT,eAAO,CAAC,cAAc,CAAC;AAAA,MAC3B;AAAA,IACJ;AAAA,IACA,UAAU;AAAA,MACN,YAAY,CAAC,OAAO,SAAS;AACzB,cAAM,UAAU,MAAM,MAAM,MAAM,MAAM,MAAM,cAAc,IAAI,CAAC;AAAA,MACrE;AAAA,MACA,eAAe;AAAA,QACX,YAAY;AAAA,UACR,OAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;AACA,SAAS,iBAAiB,EAAE,mBAAmB,MAAM,cAAc,cAAe,IAAI,CAAC,GAAG;AACtF,SAAO,CAAC,EAAE,OAAO,MAAM;AACnB,UAAM,OAAO,YAAY,QAAQ,MAAM;AACvC,WAAO;AAAA,MACH,oBAAoB,kBAAkB,YAAY,IAAI;AAAA,MACtD,eACI,OAAO,aAAa;AAAA,QAChB,CAAC,YAAY,QAAQ,iBAAiB,CAAC;AAAA,QACvC,CAAC,YAAY,QAAQ,SAAS,MAAM,IAAI,CAAC;AAAA,QACzC,CAAC,YAAY,UAAU,SAAS,MAAM,MAAM,CAAC;AAAA,QAC7C,CAAC,YAAY,WAAW,iBAAiB,IAAI,CAAC;AAAA,QAC9C,CAAC,YAAY,UAAU,gBAAgB,IAAI,CAAC;AAAA,QAC5C,CAAC,YAAY,sBAAsB,uBAAuB,CAAC;AAAA,QAC3D,CAAC,YAAY,sBAAsB,uBAAuB,CAAC;AAAA,MAC/D,CAAC,CAAC;AAAA,IACV;AAAA,EACJ;AACJ;AACA,SAAS,0BAA0B;AAC/B,SAAO,CAAC,UAAU;AACd,UAAM,OAAO,YAAY,OAAO,MAAM;AACtC,WAAO,QAAQ,qBAAqB,IAAI,EAAE,MAAM,SAAS,CAAC;AAAA,EAC9D;AACJ;AACA,SAAS,mBAAmB;AACxB,SAAO,OAAO,CAAC,UAAU,CAAC,wBAAwB,EAAE,KAAK,GAAG,CAAC,OAAO,UAAU,UAAU;AACpF,UAAM,OAAO,YAAY,OAAO,MAAM;AACtC,WAAO,OAAO,IAAI,EAAE,OAAO,QAAQ;AAAA,EACvC,CAAC;AACL;AACA,SAAS,yBAAyB;AAC9B,QAAM,iBAAiB,wBAAwB;AAC/C,SAAO,CAAC,OAAO,UAAU,SAAS;AAC9B,UAAM,OAAO,gBAAgB,KAAK;AAClC,WAAO,OAAO,gBAAgB,YAAY,MAAM,SAAS,IAAI,CAAC,EAAE,OAAO,UAAU,IAAI;AAAA,EACzF;AACJ;AACA,SAAS,yBAAyB;AAC9B,QAAM,iBAAiB,wBAAwB;AAC/C,SAAO,CAAC,OAAO,UAAU,SAAS;AAC9B,UAAM,OAAO,gBAAgB,KAAK;AAClC,WAAO,OAAO,gBAAgB,YAAY,MAAM,SAAS,IAAI,CAAC,EAAE,OAAO,UAAU,IAAI;AAAA,EACzF;AACJ;AAEA,IAAI,aAA0B,OAAO,OAAO;AAAA,EACxC,WAAW;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AAAA,EACV,aAAa;AAAA,EACb;AAAA,EACA;AAAA,EACA,sBAAsB;AAAA,EACtB,sBAAsB;AAC1B,CAAC;AAED,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,aAAa;AAAA,EACf;AAAA,EACA;AACJ;AACA,IAAM,gBAAgB;AAAA,EAClB,YAAY;AAChB;AACA,IAAM,SAAS;AACf,IAAM,sBAAsB,CAAC,WAAW;AACpC,QAAM,WAAW,OAAO,MAAM,MAAM;AACpC,qBAAmB,UAAU,YAAY,MAAM,YAAY;AAC3D,SAAO;AACX;AACA,SAAS,gBAAgB;AACrB,SAAO;AAAA,IACH,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,MACJ,UAAU;AAAA,QACN;AAAA,UACI,KAAK;AAAA,QACT;AAAA,QACA;AAAA,UACI,KAAK;AAAA;AAAA,UAEL,UAAU,CAAC,SAAS,KAAK,MAAM,eAAe,YAAY;AAAA,QAC9D;AAAA,QACA;AAAA,UACI,OAAO;AAAA,UACP,UAAU,CAAC,UAAU,4BAA4B,KAAK,KAAK,KAAK;AAAA,QACpE;AAAA,MACJ;AAAA,MACA,OAAO,MAAM,CAAC,UAAU,CAAC;AAAA,IAC7B;AAAA,IACA,UAAU;AAAA,MACN,YAAY;AAAA,QACR,MAAM;AAAA,QACN,OAAO;AAAA,QACP,SAAS;AAAA,QACT,0BAA0B;AAAA,MAC9B;AAAA,MACA,eAAe;AAAA,QACX,QAAQ,EAAE,MAAM,OAAO;AAAA,MAC3B;AAAA,IACJ;AAAA,EACJ;AACJ;AACA,SAAS,iBAAiB,EAAE,mBAAmB,MAAM,cAAc,cAAe,IAAI,CAAC,GAAG;AACtF,SAAO,CAAC,EAAE,OAAO,MAAM;AACnB,UAAM,OAAO,oBAAoB,MAAM;AACvC,WAAO;AAAA,MACH,oBACI,cAAgB,0CAA0C,IAAI;AAAA,MAClE,oBACI,cAAgB,uCAAuC,IAAI;AAAA,MAC/D,oBACI,cAAc,uCAAuC,IAAI;AAAA,MAC7D,oBACI,cAAc,0CAA0C,IAAI;AAAA,MAChE,eACI,OAAO,aAAa,CAAC,CAAC,YAAY,YAAY,WAAW,CAAC,CAAC,CAAC,CAAC;AAAA,IACrE;AAAA,EACJ;AACJ;AACA,SAAS,aAAa;AAClB,SAAO,CAAC,OAAO,UAAU,UAAU;AAC/B,UAAM,WAAW,MAAM,OAAO,MAAM,MAAM;AAC1C,uBAAmB,UAAU,YAAY,MAAM,YAAY;AAC3D,WAAO,WAAW,QAAQ,EAAE,OAAO,QAAQ;AAAA,EAC/C;AACJ;AACA,SAAS,oBAAoB;AACzB,SAAO,CAAC,UAAU;AACd,UAAM,WAAW,MAAM,OAAO,MAAM,MAAM;AAC1C,uBAAmB,UAAU,YAAY,MAAM,YAAY;AAC3D,WAAO,wBAAwB,QAAQ,EAAE,KAAK;AAAA,EAClD;AACJ;AAEA,IAAI,OAAoB,OAAO,OAAO;AAAA,EAClC,WAAW;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AAAA,EACV,aAAa;AAAA,EACb;AAAA,EACA;AACJ,CAAC;AAED,IAAM,aAAa,CAAC,MAAM,WAAW;AACjC,SAAQ,KAAK,SAAS,YAAY,QAAQ,UAAU,KAChD,OAAO,KAAK,MAAM,aAAa,MAAM;AAC7C;AASA,IAAM,wBAAwB,CAAC,IAAI,QAAQ,MAAM,QAAQ;AACrD,MAAI,WAAW,MAAM,MAAM,GAAG;AAC1B,SAAK,GAAG,cAAc,KAAK,QAAW,OAAO,OAAO,CAAC,GAAG,KAAK,OAAO,EAAE,aAAa,KAAK,CAAC,CAAC;AAAA,EAC9F;AACA,SAAO;AACX;AASA,IAAM,qBAAqB,CAAC,IAAI,QAAQ,MAAM,QAAQ;AAClD,MAAI,KAAK,SAAS,YAAY,QAAQ,UAAU,KAC5C,CAAC,WAAW,MAAM,MAAM,GAAG;AAC3B,SAAK,GAAG,cAAc,KAAK,QAAW,OAAO,OAAO,CAAC,GAAG,KAAK,OAAO,EAAE,aAAa,MAAM,CAAC,CAAC;AAAA,EAC/F;AACA,SAAO;AACX;AAMA,IAAM,aAAa,OAAO,CAAC,6BAA6B,CAAC,UAAU,UAAU,KAAK,EAAE,UAAU,CAAC,GAAG,CAAC,OAAO,aAAa;AACnH,QAAM,EAAE,OAAO,IAAI;AACnB,MAAI,KAAK,MAAM;AACf,0BAAwB,OAAO,CAAC,MAAM,QAAQ;AAC1C,SAAK,sBAAsB,IAAI,QAAQ,MAAM,GAAG;AAAA,EACpD,CAAC;AACD,MAAI,UAAU;AACV,aAAS,EAAE;AAAA,EACf;AACA,SAAO;AACX,CAAC;AAMD,IAAM,UAAU,OAAO;AAAA,EACnB;AAAA,EACA,CAAC,UAAU;AACP,UAAM,EAAE,OAAO,MAAM,IAAI,UAAU,KAAK;AAGxC,WAAO,UAAU;AAAA,EACrB;AACJ,GAAG,CAAC,OAAO,aAAa;AACpB,MAAI,EAAE,IAAI,OAAO,IAAI;AACrB,0BAAwB,OAAO,CAAC,MAAM,QAAQ;AAC1C,SAAK,mBAAmB,IAAI,QAAQ,MAAM,GAAG;AAAA,EACjD,CAAC;AACD,MAAI,UAAU;AACV,aAAS,EAAE;AAAA,EACf;AACA,SAAO;AACX,CAAC;AAED,SAAS,yBAAyB,QAAQ,UAAU;AAChD,SAAO,IAAI,UAAU,QAAQ,SAAU,OAAO,OAAO,OAAO,KAAK;AAC7D,UAAM,WAAW,YAAY,OAAO,UAAU;AAC9C,QAAI,QAAQ,oBAAoB,WAAW,SAAS,KAAK,IAAI;AAC7D,QAAI,KAAK,MAAM,GAAG,OAAO,OAAO,GAAG;AACnC,QAAI,SAAS,GAAG,IAAI,QAAQ,KAAK,GAAG,QAAQ,OAAO,WAAW,GAAG,WAAW,SAAS,aAAa,OAAO,UAAU,KAAK;AACxH,QAAI,CAAC,UAAU;AACX,aAAO;AAAA,IACX;AACA,OAAG,KAAK,OAAO,QAAQ;AACvB,QAAI,SAAS,GAAG,IAAI,QAAQ,QAAQ,CAAC,EAAE;AACvC,QAAI,UACA,OAAO,SAAS,YAAY,OAAO,YAAY,KAC/C,QAAQ,GAAG,KAAK,QAAQ,CAAC,KACzB,OAAO;AAAA,IAEP,WAAW,OAAO,WAAW,MAAM,MAAM,GAAG;AAC5C,SAAG,KAAK,QAAQ,CAAC;AAAA,IACrB;AACA,WAAO;AAAA,EACX,CAAC;AACL;AAqBA,SAAS,wBAAwB,OAAO,UAAU;AAC9C,QAAM,EAAE,QAAQ,WAAW,EAAE,OAAO,IAAI,EAAG,IAAI;AAC/C,QAAM,QAAQ,MAAM,WAAW,KAAK,CAAC,SAAS,KAAK,aAAa,KAC5D,KAAK,WAAW,SAAS,YAAY,QAAQ,UAAU,CAAC;AAC5D,MAAI,CAAC,OAAO;AACR;AAAA,EACJ;AACA,QAAM,EAAE,QAAQ,YAAY,SAAS,IAAI;AAIzC,MAAI,WAAW,MAAM,MAAM,MAAM,MAAM,KAAK;AAC5C,WAAS,IAAI,GAAG,IAAI,OAAO,YAAY,KAAK;AACxC,UAAM,QAAQ,OAAO,MAAM,CAAC;AAC5B,aAAS,OAAO,QAAQ;AAGxB,QAAI,KAAK,cAAc,IAAI,WAAW,GAAG;AACrC,YAAM,aAAa,GAAG,MAAM,QAAQ,MAAM,UAAU,WAAW,CAAC;AAAA,IACpE;AACA,gBAAY,MAAM;AAAA,EACtB;AACA;AACJ;AACA,SAAS,4BAA4B,OAAO;AACxC,QAAM,EAAE,UAAU,IAAI;AACtB,QAAM,WAAW,UAAU,MAAM,KAAK,EAAE;AACxC,QAAM,UAAU,UAAU,IAAI,KAAK,EAAE;AACrC,SAAQ,YACJ,SAAS,SAAS,YAAY,OAAO,YAAY,KACjD,WACA,QAAQ,SAAS,YAAY,OAAO,YAAY;AACxD;AACA,SAAS,UAAU,OAAO;AACtB,MAAI,QAAQ;AACZ,MAAI,QAAQ;AACZ,QAAM,EAAE,OAAO,IAAI;AACnB,0BAAwB,OAAO,CAAC,MAAM,SAAS;AAE3C,QAAI,KAAK,SAAS,YAAY,QAAQ,UAAU,GAAG;AAC/C;AAAA,IACJ;AACA,QAAI,WAAW,MAAM,MAAM,GAAG;AAC1B;AAAA,IACJ;AAAA,EACJ,CAAC;AACD,SAAO;AAAA,IACH;AAAA,IACA;AAAA,EACJ;AACJ;AAEA,SAASA,cAAa,MAAM,OAAO,WAAW,IAAI;AAC9C,MAAI,EAAE,OAAO,IAAI,IAAI;AACrB,MAAI,WAAW;AACf,MAAI,CAAC,UAAU;AACX,eAAW,YAAY,OAAO,UAAU;AAAA,EAC5C;AACA,MAAI,QAAQ,MAAM,WAAW,KAAK,CAAC,SAAS,CAAC,CAAC,KAAK,cAC/C,CAAC,CAAC,KAAK,cACP,KAAK,WAAW,SAAS,QAAQ;AACrC,MAAI,CAAC,SACD,MAAM,QAAQ,KACd,MAAM,KAAK,MAAM,QAAQ,CAAC,EAAE,SAAS,UAAU;AAC/C,WAAO;AAAA,EACX;AACA,MAAI,MAAM,MAAM;AAChB,MAAI,YAAY,IAAI,IAAI,MAAM,KAAK;AACnC,MAAI,MAAM,WAAW;AACjB,OAAG,KAAK,IAAI,kBAAkB,MAAM,GAAG,WAAW,KAAK,WAAW,IAAI,MAAM,SAAS,KAAK,SAAS,OAAO,QAAW,MAAM,OAAO,KAAK,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG,IAAI,CAAC;AAC3J,YAAQ,IAAI,UAAU,GAAG,IAAI,QAAQ,MAAM,GAAG,GAAG,GAAG,IAAI,QAAQ,SAAS,GAAG,MAAM,KAAK;AAAA,EAC3F;AACA,SAAO,GAAG,KAAK,OAAO,WAAW,KAAK,CAAC,EAAE,eAAe;AAC5D;AAEA,SAAS,kBAAkB,MAAM,OAAO,MAAM,IAAIC,gBAAe,IAAI;AACjE,MAAI,WAAW;AACf,MAAI,CAAC,UAAU;AACX,eAAW,YAAY,OAAO,UAAU;AAAA,EAC5C;AACA,MAAI,SAAS;AACb,KAAG,IAAI,aAAa,MAAM,IAAI,CAAC,MAAM,QAAQ;AACzC,QAAI,CAAC,UAAU,KAAK,SAAS,YAAY,MAAM,MAAM;AACjD,eAAS;AACT,UAAI,YAAYA,iBAAgB;AAChC,aAAO,YAAYA,iBAAgB,GAAG;AAClC,cAAM,QAAQ,GAAG,IAAI,QAAQ,GAAG,QAAQ,IAAI,GAAG,CAAC;AAChD,oBAAY,MAAM;AAClB,cAAM,MAAM,GAAG,IAAI,QAAQ,GAAG,QAAQ,IAAI,MAAM,KAAK,QAAQ,IAAI,CAAC;AAClE,cAAM,MAAM,IAAI,cAAc,OAAO,GAAG;AACxC,aAAKD,cAAa,UAAU,OAAO,KAAK,EAAE;AAAA,MAC9C;AAAA,IACJ;AAAA,EACJ,CAAC;AACD,SAAO;AACX;AAEA,SAAS,kBAAkB,MAAM,OAAO,IAAI;AACxC,QAAM,EAAE,MAAM,GAAG,IAAI,MAAM;AAC3B,QAAM,EAAE,WAAAE,WAAU,IAAI,MAAM,OAAO;AACnC,QAAM,UAAU,CAAC;AACjB,KAAG,IAAI,aAAa,MAAM,IAAI,CAAC,MAAM,QAAQ;AACzC,QAAI,KAAK,SAASA,YAAW;AACzB,cAAQ,KAAK,EAAE,MAAM,IAAI,CAAC;AAAA,IAC9B;AAAA,EACJ,CAAC;AACD,WAAS,IAAI,QAAQ,SAAS,GAAG,KAAK,GAAG,KAAK;AAC1C,UAAMA,aAAY,QAAQ,CAAC;AAC3B,UAAM,QAAQ,GAAG,IAAI,QAAQ,GAAG,QAAQ,IAAIA,WAAU,GAAG,CAAC;AAC1D,QAAI,MAAM,QAAQ,GAAG;AACjB,UAAI;AACJ,UAAIA,WAAU,KAAK,eAAeA,WAAU,KAAK,YAAY,SAAS,GAAG;AACrE,cAAM,GAAG,IAAI,QAAQ,GAAG,QAAQ,IAAIA,WAAU,MAAMA,WAAU,KAAK,YAAY,MAAM,CAAC;AAAA,MAC1F,OACK;AACD,cAAM,GAAG,IAAI,QAAQ,GAAG,QAAQ,IAAIA,WAAU,MAAM,CAAC,CAAC;AAAA,MAC1D;AACA,YAAM,QAAQ,MAAM,WAAW,GAAG;AAClC,UAAI,OAAO;AACP,WAAG,KAAK,OAAO,kBAAkB,MAAM,MAAM,QAAQ,KAAK,CAAC;AAAA,MAC/D;AAAA,IACJ;AAAA,EACJ;AACA,SAAO;AACX;AAEA,IAAM,iBAAiB;AAEvB,IAAM,oBAAoB,CAAC,aAAa,UAAU;AAC9C,QAAM,EAAE,YAAAC,aAAY,aAAAC,aAAY,IAAI;AACpC,MAAI,QAAQ;AACZ,WAAS,IAAI,YAAY,QAAQ,GAAG,IAAI,GAAG,KAAK;AAC5C,UAAM,OAAO,YAAY,KAAK,CAAC;AAC/B,QAAI,KAAK,SAASD,eAAc,KAAK,SAASC,cAAa;AACvD,eAAS;AAAA,IACb;AAAA,EACJ;AACA,SAAO;AACX;AACA,IAAM,eAAe,CAAC,OAAO,aAAa;AACtC,QAAM,EAAE,MAAM,IAAI,MAAM;AACxB,QAAM,SAAS,MAAM,KAAK,EAAE;AAC5B,QAAM,mBAAmB,MAAM,KAAK,EAAE;AACtC,SAAS,UAAU,OAAO,SAAS,YAC9B,oBAAoB,iBAAiB,SAAS;AACvD;AACA,IAAM,aAAa,CAAC,SAAS,CAAC,UAAU;AACpC,QAAM,EAAE,OAAO,IAAI,MAAM,UAAU;AACnC,MAAI,WAAW;AACf,MAAI,CAAC,UAAU;AACX,KAAC,EAAE,SAAS,IAAI,MAAM,OAAO;AAAA,EACjC;AACA,QAAM,EAAE,WAAAF,WAAU,IAAI,MAAM,OAAO;AACnC,MAAI,MAAM,qBAAqB,oBAAoB;AAC/C,WAAO,OAAO,SAAS;AAAA,EAC3B;AACA,SAAQ,OAAO,SAASA,cAAa,oBAAoB,QAAQ,EAAE,MAAM,SAAS;AACtF;AAMA,SAAS,QAAQ,yBAAyB,OAAO;AAK7C,MAAI;AACJ,MAAI,aAAa,MAAM,GAAG,UAAU,IAAI;AACxC,KAAG;AACC,UAAM,cAAc,MAAM,IAAI,QAAQ,UAAU;AAChD,8BAA0B,kBAAkB,aAAa,MAAM,OAAO,KAAK;AAC3E,QAAI,0BAA0B,gBAAgB;AAI1C,aAAO;AAAA,IACX;AACA;AAAA,EACJ,SAAS,2BAA2B;AACpC,SAAO;AACX;AACA,IAAM,mBAAmB,CAAC,SAAS,CAAC,UAAU;AAC1C,QAAM,EAAE,MAAM,IAAI,MAAM;AACxB,MAAI,WAAW;AACf,MAAI,CAAC,UAAU;AACX,eAAW,YAAY,OAAO,UAAU;AAAA,EAC5C;AACA,QAAM,EAAE,WAAAA,WAAU,IAAI,MAAM,OAAO;AACnC,MAAI,MAAM,qBAAqB,oBAAoB;AAC/C,WAAO,MAAM,OAAO,SAAS;AAAA,EACjC;AACA,SAAQ,oBAAoB,QAAQ,EAAE,MAAM,SAAS,KACjD,MAAM,OAAO,SAASA;AAC9B;AAEA,IAAM,gBAAgB,CAAC,MAAM,KAAK,UAAU;AACxC,MAAI,WAAW;AACf,QAAM,EAAE,YAAAC,aAAY,aAAAC,aAAY,IAAI;AACpC,MAAI;AACJ,WAAS,IAAI,IAAI,QAAQ,GAAG,IAAI,GAAG,KAAK;AACpC,UAAM,OAAO,IAAI,KAAK,CAAC;AACvB,QAAI,KAAK,SAASD,eAAc,KAAK,SAASC,cAAa;AACvD,cAAQ;AAAA,IACZ;AACA,QAAI,KAAK,SAASD,eACd,KAAK,SAASC,gBACd,KAAK,SAAS,UAAU;AACxB;AAAA,IACJ;AAAA,EACJ;AACA,SAAO;AACX;AACA,SAAS,4BAA4B,OAAO;AACxC,QAAM,EAAE,MAAM,IAAI,MAAM;AACxB,QAAM,EAAE,YAAAD,aAAY,aAAAC,aAAY,IAAI,MAAM,OAAO;AACjD,QAAM,UAAU,MAAM,IAAI,QAAQ,MAAM,MAAM,CAAC;AAC/C,MAAI,aAAa,UAAU,QAAQ,aAAa;AAChD,MAAI,MAAM,qBAAqB,oBAAoB;AAC/C,iBAAa,MAAM;AAAA,EACvB;AACA,SAAQ,CAAC,CAAC,cAAc,CAACD,aAAYC,YAAW,EAAE,QAAQ,WAAW,IAAI,IAAI;AACjF;AAaA,SAAS,WAAW,UAAU,UAAU,MAAM;AAC1C,SAAO,CAAC,OAAO,UAAU,SAAS;AAC9B,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,WAAW,UAAU,MAAM,KAAK,UAAU,MAAM,QAAQ,CAAC;AAC/D,UAAM,UAAU,UAAU,IAAI,KAAK,UAAU,IAAI,QAAQ,CAAC;AAC1D,QAAI,CAAC,YACD,SAAS,KAAK,SAAS,SAAS,QAChC,CAAC,WACD,QAAQ,KAAK,SAAS,SAAS,MAAM;AACrC,aAAO,kBAAkB,UAAU,IAAI,EAAE,OAAO,UAAU,IAAI;AAAA,IAClE,OACK;AAGD,YAAM,WAAW,WAAW,WAAW,YAAY,OAAO,UAAU;AACpE,YAAM,QAAQ,cAAc,UAAU,UAAU,KAAK,MAAM,OAAO,KAAK;AACvE,UAAI,WAAW,UAAU,IAAI;AAI7B,UAAI,qBAAqB,iBACrB,UAAU,KAAK,SAAS,UAAU;AAClC,mBACI,UAAU,MAAM,MAAM,UAAU,KAAK,WAAW,QAAQ;AAAA,MAChE;AACA,UAAI,SAAS,MAAM;AACnB,UAAI,KAAK,kBAAkB,UAAU,OAAO,UAAU,UAAU,IAAI,IAAI,KAAK,GAAG,SAAS,GAAG,MAAM;AAClG,WAAK,kBAAkB,UAAU,OAAO,EAAE;AAC1C,UAAI,UAAU;AACV,iBAAS,EAAE;AAAA,MACf;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AACJ;AACA,SAAS,kBAAkB,UAAU,OAAO,OAAO;AAK/C,QAAM,gBAAgB,CAAC,WAAW,CAAC,OAAO;AACtC,QAAI,CAAC,GAAG,WAAW;AACf,aAAO;AAAA,IACX;AAIA,QAAI,SAAS,CAAC;AACd,aAAS,IAAI,GAAG,IAAI,GAAG,QAAQ,KAAK,QAAQ,KAAK;AAC7C,UAAI,MAAM,GAAG,QAAQ,KAAK,CAAC;AAC3B,eAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,eAAO,CAAC,IAAI,IAAI,IAAI,OAAO,CAAC,CAAC;AAAA,MACjC;AACA,UAAI,QAAQ,CAAC,IAAI,IAAI,MAAM,OAAO;AAC9B,eAAO,KAAK,MAAM,EAAE;AAAA,MACxB,CAAC;AAAA,IACL;AACA,UAAM,YAAY,CAAC,MAAM,eAAe,KAAK,SAAS,YAAY,QAAQ,UAAU,MAC/E,eAAe,QAAQ,eAAe,SAAS,SAAS,WAAW,UAAU,YAAY,QAAQ,YAAY;AAClH,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GAAG;AACvC,UAAI,OAAO,OAAO,CAAC;AACnB,UAAI,KAAK,OAAO,IAAI,CAAC;AACrB,SAAG,IAAI,aAAa,MAAM,IAAI,CAAC,MAAM,KAAK,eAAe;AACrD,YAAI,OAAO,QAAQ,MAAM,MAAM,UAAU,MAAM,UAAU,GAAG;AACxD,6BAAmB,IAAI,QAAQ,MAAM,GAAG;AAAA,QAC5C;AAAA,MACJ,CAAC;AAAA,IACL;AACA,WAAO;AAAA,EACX;AACA,SAAO,SAAU,OAAO,UAAU,MAAM;AACpC,QAAI,UAAU;AACV,eAAS,MAAM,GAAG,aAAa,sBAAsB,MAAM,KAAK,MAAM,SAAS,CAAC,CAAC;AAAA,IACrF;AACA,QAAI,CAAC,MAAM;AACP,aAAO;AAAA,IACX;AACA,YAAQ,KAAK;AACb,UAAM,EAAE,OAAO,IAAI,IAAI,MAAM;AAC7B,UAAM,sBAAsB,cAAc,MAAM,KAAK,OAAO,KAAK,QAAQ;AACzE,QAAI,aAAa,OAAO,QAAQ,KAAK,qBAAqB;AACtD,aAAO,cAAc,EAAE,OAAO,QAAQ;AAAA,IAC1C,OACK;AAED,UAAI,CAAC,qBAAqB;AACtB,sBAAc,EAAE,OAAO,QAAQ;AAC/B,gBAAQ,KAAK;AAAA,MACjB;AAEA,YAAM,KAAK,kCAAkC,OAAO,QAAQ;AAC5D,UAAI,MAAM,UAAU;AAChB,iBAAS,EAAE;AACX,gBAAQ,KAAK;AAAA,MACjB;AAEA,aAAOC,YAAW,QAAQ,EAAE,OAAO,OAAO,eAAe,UAAU,cAAc,MAAM,MAAM,CAAC,IAAI,QAAQ;AAAA,IAC9G;AAAA,EACJ;AACJ;AACA,SAASA,YAAW,UAAU,OAAO;AACjC,SAAO,SAAS,WAAa,UAAU,KAAK,GAAG,CAAC,QAAQ,UAAU,OAAO,SAAS,MAAM,QAAQ,OAAO,SAAS,QAAQ;AAC5H;AACA,SAAS,gBAAgB;AACrB,SAAO,SAAU,OAAO,UAAU;AAC9B,UAAM,EAAE,GAAG,IAAI;AACf,UAAM,EAAE,OAAO,IAAI,IAAI,MAAM;AAC7B,OAAG,IAAI,aAAa,MAAM,KAAK,IAAI,KAAK,CAAC,MAAM,QAAQ;AAGnD,UAAI,KAAK,aAAa;AAClB,cAAM,MAAM,IAAI,cAAc,GAAG,IAAI,QAAQ,GAAG,QAAQ,IAAI,GAAG,CAAC,CAAC;AACjE,cAAM,QAAQ,IAAI,MAAM,WAAW,IAAI,GAAG;AAC1C,YAAI,CAAC,SACD,CAAC,CAAC,YAAY,OAAO,UAAU,CAAC,EAAE,SAAS,IAAI,MAAM,OAAO,IAAI,GAAG;AACnE,iBAAO;AAAA,QACX;AACA,cAAM,SAAS,SAAS,WAAW,KAAK;AACxC,YAAI,WAAW,UAAa,WAAW,MAAM;AACzC,iBAAO;AAAA,QACX;AACA,WAAG,KAAK,OAAO,MAAM;AAAA,MACzB;AACA;AAAA,IACJ,CAAC;AACD,QAAI,UAAU;AACV,eAAS,EAAE;AAAA,IACf;AACA,WAAO;AAAA,EACX;AACJ;AAOA,SAAS,sBAAsBC,MAAK,WAAW;AAC3C,MAAI,EAAE,OAAO,IAAI,IAAI;AACrB,QAAM,aAAa,MAAM,QAAQ,IAAI;AACrC,MAAI,WAAW,MAAM;AACrB,MAAI,SAAS,IAAI;AACjB,MAAI,cAAc,aAAaA,KAAI,WAAW,GAAG;AAE7C,WAAO;AAAA,EACX;AAEA,MAAI,MAAM,cAAc,CAAC,YAAY;AACjC;AACA,QAAI,OAAOA,KAAI,OAAO,QAAQ;AAC9B,WAAO,CAAC,QAAS,QAAQ,CAAC,KAAK,QAAS;AACpC;AACA,aAAOA,KAAI,OAAO,QAAQ;AAAA,IAC9B;AAAA,EACJ;AACA,MAAI,WAAW,UAAU;AACrB,WAAO,IAAI,cAAcA,KAAI,QAAQ,QAAQ,CAAC;AAAA,EAClD;AACA,SAAO,IAAI,cAAcA,KAAI,QAAQ,QAAQ,GAAGA,KAAI,QAAQ,MAAM,CAAC;AACvE;AACA,SAAS,WAAW,MAAM;AACtB,QAAM,aAAa,CAAC,WAAW,CAAC,OAAO;AACnC,QAAI,CAAC,GAAG,WAAW;AACf,aAAO;AAAA,IACX;AACA,UAAM,QAAQ,GAAG,UAAU,MAAM,WAAW,GAAG,UAAU,KAAK,CAAC,SAAS,KAAK,aAAa,KACtF,KAAK,WAAW,SAAS,YAAY,QAAQ,UAAU,CAAC;AAC5D,QAAI,CAAC;AAAA,IAED,MAAM,eAAe,GAAG;AACxB,aAAO;AAAA,IACX;AACA,UAAM,oBAAoB,WAAW,MAAM,OAAO,MAAM,MAAM,aAAa,CAAC,GAAG,MAAM;AACrF,UAAM,EAAE,QAAQ,YAAY,SAAS,IAAI;AACzC,QAAI,SAAS;AACb,aAAS,IAAI,YAAY,IAAI,UAAU,KAAK;AACxC,YAAM,QAAQ,OAAO,MAAM,CAAC;AAC5B,YAAM,MAAM,MAAM,QAAQ;AAC1B,WAAK,oBACC,mBAAmB,IAAI,QAAQ,OAAO,GAAG,IACzC,sBAAsB,IAAI,QAAQ,OAAO,GAAG;AAClD,gBAAU,MAAM;AAAA,IACpB;AACA,WAAO;AAAA,EACX;AACA,SAAO,SAAS,kBAAkB,OAAO,UAAU;AAC/C,QAAI,WAAW;AACf,QAAI,CAAC,UAAU;AACX,iBAAW,YAAY,OAAO,UAAU;AAAA,IAC5C;AACA,QAAI,iBAAiB,QAAQ,EAAE,KAAK,GAAG;AAEnC,YAAM,0BAA0B,kBAAkB,MAAM,UAAU,OAAO,MAAM,OAAO,KAAK;AAC3F,UAAI,QAAQ,yBAAyB,KAAK,GAAG;AACzC,qBAAa,QAAQ,EAAE,OAAO,eAAe,UAAU,WAAW,MAAM,MAAM,CAAC,CAAC;AAAA,MACpF;AACA,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AACJ;AACA,SAAS,YAAY,MAAM;AACvB,SAAO,SAAU,OAAO,UAAU,MAAM;AACpC,QAAI,WAAW;AACf,QAAI,CAAC,UAAU;AACX,iBAAW,YAAY,OAAO,UAAU;AAAA,IAC5C;AACA,UAAM,EAAE,OAAO,IAAI,IAAI,MAAM;AAC7B,QAAI,CAAC,iBAAiB,QAAQ,EAAE,KAAK,GAAG;AACpC,aAAO;AAAA,IACX;AAMA,QAAI,QAAQ,MAAM,WAAW,KAAK,CAAC,SAAS,KAAK,aAAa,KAAK,KAAK,WAAW,SAAS,QAAQ;AACpG,QAAI,CAAC,OAAO;AACR,aAAO;AAAA,IACX;AACA,UAAM,mBAAmB,WAAW,MAAM,UAAU,MAAM,KAAK,EAAE,GAAG,MAAM,MAAM;AAGhF,QAAI,YAAY,MAAM;AAClB,YAAM,cAAc,MAAM,UAAU,MAAM,KAAK,EAAE;AACjD,YAAM,iBAAiB,MAAM,UAAU,MAAM,MAAM,EAAE;AACrD,UAAI,KAAK,MAAM;AACf,iBAAW,EAAE,MAAM,IAAI,KAAK,QAAQ,aAAa,KAAK,GAAG;AACrD,cAAM,SAAS,MAAM;AAErB,YAAI,UAAU,MAAM,UAAU,MAAM,OAAO,EAAE,KACzC,SAAS,MAAM,UAAU,IAAI,MAAM,EAAE,GAAG;AACxC,cAAI,kBAAkB;AAClB,+BAAmB,IAAI,MAAM,QAAQ,MAAM,MAAM;AAAA,UACrD,OACK;AACD,kCAAsB,IAAI,MAAM,QAAQ,MAAM,MAAM;AAAA,UACxD;AAAA,QACJ;AAAA,MACJ;AACA,eAAS,EAAE;AACX,cAAQ,KAAK;AAAA,IACjB;AACA,UAAM,kBAAkB;AAAA,MAAQ,WAAW,UAAU,KAAK;AAAA;AAAA,MAC1D;AAAA,IAAc,EAAE,QAAQ;AACxB,WAAO,gBAAgB,OAAO,UAAU,IAAI;AAAA,EAChD;AACJ;AAQA,SAAS,WAAW,UAAU,OAAO;AACjC,SAAO,CAAC,YAAY;AAChB,WAAO,CAAC,OAAO,UAAU,SAAS;AAC9B,YAAM,cAAc,CAAC,OAAO;AA2BxB,cAAM,SAAS,MAAM,IAAI,QAAQ,MAAM,KAAK;AAC5C,cAAM,OAAO,MAAM,IAAI,QAAQ,MAAM,GAAG;AACxC,cAAM,QAAQ,GAAG,IAAI,QAAQ,GAAG,QAAQ,IAAI,MAAM,MAAM,CAAC,CAAC;AAC1D,YAAI,MAAM,cACN,MAAM,aACN,MAAM,WAAW,SAAS,MAAM,UAAU,MAAM;AAChD,cAAI,KAAK,aACL,KAAK,UAAU,SAAS,YACxB,KAAK,OAAO,SAAS,OAAO,OAAO,MAAM;AACzC,eAAG,KAAK,MAAM,GAAG;AAAA,UACrB;AAAA,QACJ;AACA,YAAI,UAAU;AACV,mBAAS,GAAG,eAAe,CAAC;AAAA,QAChC;AAAA,MACJ;AACA,aAAO,QAAQ,OAAO,aAAa,IAAI;AAAA,IAC3C;AAAA,EACJ;AACJ;AAEA,IAAM,sBAAsB,CAAC,SAAS,CAAC,OAAO,UAAU,SAAS;AAC7D,SAAO;AAAA;AAAA;AAAA,IAGP,OAAO;AAAA,MACH,iBAAiB,IAAI;AAAA,MACrB;AAAA;AAAA,MAEA;AAAA,MACA,WAAW,IAAI;AAAA,IACnB,GAAG,cAAc,4BAA4B,IAAI,GAAG,YAAY,IAAI,CAAC,CAAC;AAAA;AAAA;AAAA,IAGtE,OAAO,CAAC,yBAAyB,2BAA2B,GAAG,uBAAuB,IAAI,CAAC;AAAA,EAAC,EAAE,OAAO,UAAU,IAAI;AACvH;AACA,SAAS,gBAAgB,MAAM;AAC3B,SAAO,CAAC,OAAO,UAAU,SAAS;AAC9B,UAAM,EAAE,UAAU,IAAI;AACtB,QAAI,UAAU,OAAO;AACjB,YAAM,EAAE,MAAM,IAAI;AAClB,UAAI,WAAW;AACf,UAAI,CAAC,UAAU;AACX,mBAAW,YAAY,OAAO,UAAU;AAAA,MAC5C;AACA,YAAM,EAAE,WAAAC,WAAU,IAAI,MAAM,OAAO;AACnC,YAAM,OAAO,MAAM,KAAK,MAAM,KAAK;AACnC,YAAM,UAAU,MAAM,KAAK,MAAM,QAAQ,CAAC;AAC1C,UAAI,WAAW,QAAQ,SAAS,UAAU;AAEtC,cAAM,oBAAoB,kBAAkB,OAAO;AACnD,YAAI,YAAY,IAAI,KAAK,CAAC,mBAAmB;AACzC,gBAAM,cAAc,MAAM,KAAK,MAAM,QAAQ,CAAC;AAG9C,cAAI,WAAW,aAAa,MAAM,MAAM,KACpC,CAAC,WAAW,SAAS,MAAM,MAAM,GAAG;AACpC,mBAAO,YAAY,YAAY,OAAO,UAAU,CAAC,EAAE,OAAO,UAAU,IAAI;AAAA,UAC5E,OACK;AACD,mBAAO,YAAY,QAAQ,EAAE,OAAO,UAAU,IAAI;AAAA,UACtD;AAAA,QACJ,WACS,CAACA,cAAa,CAAC,oBAAoBA,UAAS,EAAE,SAAS,GAAG;AAC/D,iBAAO,cAAc,UAAU,CAACC,UAAS;AACrC,gBAAI,CAAC,WAAWA,OAAM,MAAM,MAAM,GAAG;AACjC,qBAAOA,MAAK;AAAA,YAChB;AACA,mBAAO;AAAA,cACH,GAAGA,MAAK;AAAA,cACR,aAAa;AAAA,YACjB;AAAA,UACJ,CAAC,EAAE,OAAO,QAAQ;AAAA,QACtB;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACJ;AAQA,SAAS,cAAc,UAAU,YAAY;AACzC,SAAO,SAAU,OAAO,UAAU;AAC9B,UAAM,MAAM,MAAM;AAClB,UAAM,QAAQ,IAAI;AAClB,UAAM,MAAM,IAAI;AAChB,UAAM,OAAO,IAAI;AACjB,QAAK,QAAQ,KAAK,WAAY,MAAM,QAAQ,KAAK,CAAC,MAAM,WAAW,GAAG,GAAG;AACrE,aAAO;AAAA,IACX;AACA,UAAM,cAAc,MAAM,KAAK,EAAE;AACjC,QAAI,YAAY,SAAS,UAAU;AAC/B,aAAO;AAAA,IACX;AAEA;AAAA;AAAA,MAEA,YAAY,QAAQ,QAAQ,UAAU,KAClC,MAAM,OAAO,QAAQ,SAAS,KAC9B,EAAE,YAAY,QAAQ,SAAS;AAAA,MAAI;AAInC,UAAI,MAAM,UAAU,KAChB,MAAM,KAAK,EAAE,EAAE,SAAS,YACxB,MAAM,MAAM,EAAE,MAAM,MAAM,KAAK,EAAE,EAAE,aAAa,GAAG;AACnD,eAAO;AAAA,MACX;AACA,UAAI,UAAU;AACV,YAAI,OAAO,SAAS;AACpB,cAAM,WAAW,MAAM,MAAM,EAAE,IAAI;AAGnC,iBAAS,IAAI,MAAM,SAAS,WAAW,IAAI,IAAI,KAAK,MAAM,QAAQ,GAAG,KAAK;AACtE,iBAAO,SAAS,KAAK,MAAM,KAAK,CAAC,EAAE,KAAK,IAAI,CAAC;AAAA,QACjD;AAEA,eAAO,KAAK,OAAO,SAAS,KAAK,SAAS,cAAc,CAAC,CAAC;AAC1D,cAAM,OAAO,MAAM,GAAG,QAAQ,MAAM,OAAO,WAAW,SAAY,EAAE,GAAG,MAAM,MAAM,EAAE,GAAG,IAAI,MAAM,MAAM,WAAW,IAAI,GAAG,CAAC,CAAC;AAC5H,aAAK,aAAa,UAAU,KAAK,KAAK,IAAI,QAAQ,MAAM,OAAO,WAAW,IAAI,EAAE,CAAC,CAAC;AAClF,iBAAS,KAAK,eAAe,CAAC;AAAA,MAClC;AACA,aAAO;AAAA,IACX;AACA,UAAM,WAAW,IAAI,QAAQ,MAAM,IAAI,IACjC,YAAY,eAAe,CAAC,EAAE,cAC9B;AACN,UAAM,KAAK,MAAM,GAAG,OAAO,MAAM,KAAK,IAAI,GAAG;AAC7C,UAAM,QAAQ;AAAA,MACV,aACM,EAAE,MAAM,UAAU,OAAO,WAAW,WAAW,EAAE,IACjD;AAAA,MACN,YAAY,EAAE,MAAM,SAAS;AAAA,IACjC;AACA,QAAI,UAAU;AACV,eAAS,GAAG,MAAM,MAAM,KAAK,GAAG,KAAK,EAAE,eAAe,CAAC;AAAA,IAC3D;AACA,WAAO;AAAA,EACX;AACJ;AACA,SAAS,uBAAuB,MAAM;AAClC,SAAO,CAAC,OAAO,aAAa;AACxB,QAAI,WAAW;AACf,QAAI,CAAC,UAAU;AACX,OAAC,EAAE,SAAS,IAAI,MAAM,OAAO;AAAA,IACjC;AACA,UAAM,EAAE,MAAM,IAAI,MAAM;AACxB,UAAM,EAAE,WAAAN,YAAW,WAAAK,YAAW,SAAAE,UAAS,YAAAN,aAAY,aAAAC,aAAY,IAAI,MAAM,OAAO;AAChF,UAAM,mBAAmB,MAAM,qBAAqB;AACpD,UAAM,UAAU,mBAAmB,MAAM,IAAI,QAAQ,MAAM,MAAM,CAAC,IAAI;AACtE,QAAI,OAAO,cAAc,OAAO;AAChC,QAAI,CAAC,MAAM;AACP,aAAO;AAAA,IACX;AAEA,QAAI,KAAK,cACL,CAACD,aAAYC,YAAW,EAAE,QAAQ,KAAK,WAAW,IAAI,IAAI,IAAI;AAE9D,UAAI,KAAK,aACL,CAACF,YAAWK,YAAWE,QAAO,EAAE,QAAQ,KAAK,UAAU,IAAI,IAAI,IAAI;AAEnE,YAAI,YAAY,KAAK,IAAI,QAAQ,KAAK,MAAM,CAAC;AAC7C,eAAO,UAAU,OAAO,SAASP,YAAW;AACxC,sBAAY,MAAM,IAAI,QAAQ,UAAU,MAAM,CAAC;AAAA,QACnD;AACA,YAAI,EAAE,GAAG,IAAI;AACb,YAAI,kBAAkB;AAClB,gBAAM,gBAAgB,yBAAyB,GAAG,SAAS;AAC3D,cAAI,OAAO,kBAAkB,UAAU;AACnC,mBAAO;AAAA,UACX;AAEA,gBAAM,OAAO,KAAK,WAAW,KAAK,KAAK,WAAW,QAAQ,OAAO,SAAS,KAAK,SAAS,cAAc,CAAC,GAAG,KAAK,SAAS,CAAC,CAAC,CAAC;AAC3H,aAAG,YAAY,eAAe,MAAM,MAAM,KAAK,UAAU,UAAU,IAAI;AAAA,QAC3E,OACK;AAED,eAAK,GAAG,KAAK,IAAI,kBAAkB,UAAU,KAAK,KAAK,MAAM,KAAK,UAAU,UAAU,KAAK,MAAM,GAAG,KAAK,MAAM,KAAK,UAAU,WAAW,GAAG,MAAM,GAAG,IAAI,MAAM,UAAU,KAAK,KAAK,GAAG,GAAG,GAAG,IAAI,CAAC;AAAA,QACrM;AAGA,YAAI,WAAW,GAAG,IAAI,QAAQ,GAAG,QAAQ,IAAI,KAAK,MAAM,KAAK,UAAU,QAAQ,CAAC;AAChF,YAAI,SAAS,cACT,SAAS,aACT,SAAS,WAAW,SAAS,SAAS,UAAU,QAChD,CAACC,aAAYC,YAAW,EAAE,QAAQ,SAAS,WAAW,IAAI,IAAI,IAAI;AAClE,eAAK,GAAG,KAAK,SAAS,GAAG;AAAA,QAC7B;AACA,YAAI,UAAU;AACV,mBAAS,GAAG,eAAe,CAAC;AAAA,QAChC;AACA,eAAO;AAAA,MACX;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACJ;AACA,SAAS,4BAA4B,MAAM;AACvC,SAAO,CAAC,OAAO,aAAa;AACxB,UAAM,EAAE,MAAM,IAAI,MAAM;AACxB,QAAI,WAAW;AACf,QAAI,CAAC,UAAU;AACX,iBAAW,YAAY,OAAO,UAAU;AAAA,IAC5C;AACA,UAAM,OAAO,cAAc,KAAK;AAChC,QAAI,CAAC,QAAQ,CAAC,KAAK,cAAc,EAAE,KAAK,WAAW,SAAS,WAAW;AACnE,aAAO;AAAA,IACX;AACA,UAAM,wBAAwB,KAAK,WAAW,eAAe,KACzD,KAAK,WAAW,WAAW,YAAY;AAC3C,QAAI,uBAAuB;AACvB,YAAM,EAAE,GAAG,IAAI;AACf,UAAI,UAAU;AACV,iBAAS,GACJ,OAAO,KAAK,MAAM,KAAK,WAAW,UAAU,MAAM,GAAG,EACrD,eAAe,CAAC;AAAA,MACzB;AACA,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AACJ;AACA,SAAS,iBAAiB,MAAM,MAAM,MAAM;AACxC,QAAM,SAAS,QAAQ;AACvB,QAAM,eAAe,CAAC,UAAU;AAC5B,UAAM,kBAAkB,qBAAqB,IAAI,EAAE,MAAM,SAAS;AAClE,QAAI,CAAC,iBAAiB;AAClB,aAAO;AAAA,IACX;AACA,UAAM,cAAc,gBAAgB;AACpC,UAAM,EAAE,MAAM,IAAI,MAAM;AACxB,UAAM,SAAS,MAAM,KAAK,gBAAgB,QAAQ,CAAC;AACnD,UAAM,eAAe,UAAU,OAAO,SAAS,cAAc,YAAY;AACzE,QAAI,eAAe,iBAAiB,aAAa;AAC7C,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AACA,QAAM,UAAU,CAAC,OAAO,UAAU,SAAS;AACvC,QAAI,WAAW;AACf,QAAI,CAAC,UAAU;AACX,iBAAW,YAAY,OAAO,UAAU;AAAA,IAC5C;AACA,QAAI,CAAC,MAAM,UAAU,OAAO;AACxB,aAAO;AAAA,IACX;AACA,UAAM,cAAc,eAAe,CAAC,SAAS,gBAAgB,KAAK,MAAM,MAAM,OAAO,KAAK,CAAC,EAAE,MAAM,SAAS;AAC5G,UAAM,SAAS,qBAAqB,QAAQ,EAAE,MAAM,SAAS;AAC7D,QAAI,EAAE,eAAe,YAAY,SAAS,EAAE,UAAU,OAAO,OAAO;AAChE,aAAO;AAAA,IACX;AAEA,QAAI,MAAM,UAAU,MAAM,UAAU,GAAG;AACnC,aAAO,YAAY,QAAQ,EAAE,OAAO,UAAU,IAAI;AAAA,IACtD;AAGA,QAAI,eAAe,YAAY,KAAK,eAAe,IAAI,cAAc;AACrE,QAAI,KAAK,MAAM,GAAG,OAAO,aAAa,KAAK,aAAa,MAAM,aAAa,KAAK,QAAQ;AAIxF,QAAI,YAAY,MAAM,UAAU,MAAM,OAAO,EAAE;AAE/C,QAAI,QAAQ;AACR,UAAI,eAAe,MAAM,UAAU,MAAM,MAAM,EAAE;AACjD,kBAAY,eAAe,aAAa,KAAK;AAC7C,UAAI,QAAQ,SAAS,cAAc,MAAM,GAAG,KAAK,MAAM,IAAI,OAAO,YAAY;AAC9E,UAAI,SAAS,MAAM,SAAS,UAAU;AAOlC,qBAAa,MAAM;AAAA,MACvB;AAAA,IACJ;AACA,QAAI,eAAe,OAAO;AAC1B,UAAM,QAAQ,WAAW,cAAc,SAAS,EAAE,EAAE;AAEpD,QAAI,UAAU,IAAI;AACd,aAAO;AAAA,IACX;AACA,QAAI,UAAU;AACV,eAAS,KAAK;AAAA,IAClB;AACA,WAAO;AAAA,EACX;AACA,SAAO,OAAO,CAAC,YAAY,GAAG,OAAO;AACzC;AACA,SAAS,gBAAgB,MAAM,IAAI;AAC/B,SAAO,CAAC,OAAO,aAAa;AACxB,UAAM,EAAE,MAAM,IAAI,MAAM;AACxB,UAAM,UAAU,MAAM,KAAK,EAAE;AAC7B,QAAI,WAAW,QAAQ,SAAS,MAAM;AAClC,YAAM,EAAE,GAAG,IAAI;AACf,YAAM,UAAU,MAAM,OAAO,EAAE;AAC/B,YAAM,WAAW,GAAG,QAAQ,KAAK;AACjC,UAAI,aAAa,QAAQ,OAAO;AAC5B,WAAG,cAAc,SAAS,QAAW,GAAG,QAAQ,KAAK,CAAC;AACtD,oBAAY,SAAS,EAAE;AACvB,eAAO;AAAA,MACX;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACJ;AAGA,SAAS,YAAY,QAAQ,GAAG;AAC5B,SAAO,EAAE,IAAI,OAAO,QAAQ;AACxB,QAAI,QAAQ,OAAO,CAAC;AACpB,QAAI,SAAS,MAAM,SAAS,kBAAkB;AAC1C,aAAO,MAAM;AAAA,IACjB;AAAA,EACJ;AACA,SAAO;AACX;AAEA,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,aAAa;AAAA,EACf;AAAA,EACA;AACJ;AACA,IAAM,gBAAgB;AAAA,EAClB,QAAQ;AAAA,EACR,YAAY;AAChB;AACA,IAAM,SAAS;AACf,SAAS,gBAAgB;AACrB,SAAO;AAAA,IACH,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,MACJ,SAAS;AAAA,MACT,OAAO;AAAA,MACP,UAAU,CAAC,EAAE,KAAK,KAAK,CAAC;AAAA,MACxB,OAAO,MAAM,CAAC,MAAM,CAAC;AAAA,MACrB,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA,QAKH,OAAO;AAAA,UACH,SAAS;AAAA,QACb;AAAA,MACJ;AAAA,IACJ;AAAA,IACA,UAAU;AAAA,MACN,WAAW,OAAO,MAAM;AACpB,cAAM,WAAW,MAAM,MAAM,MAAM,IAAI;AAAA,MAC3C;AAAA,MACA,eAAe;AAAA,QACX,aAAa;AAAA,UACT,OAAO;AAAA,UACP,UAAU,CAAC,GAAG,QAAQ,MAAM;AACxB,mBAAO,EAAE,OAAO,YAAY,QAAQ,CAAC,EAAE;AAAA,UAC3C;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;AACA,SAAS,iBAAiB,EAAE,mBAAmB,MAAM,uBAAuB,MAAM,cAAc,cAAe,IAAI,CAAC,GAAG;AACnH,SAAO,CAAC,EAAE,OAAO,MAAM;AACnB,UAAM,OAAO,YAAY,QAAQ,MAAM;AACvC,WAAO;AAAA,MACH,eACI,OAAO,aAAa;AAAA,QAChB,CAAC,YAAY,QAAQ,iBAAiB,CAAC;AAAA,QACvC,CAAC,YAAY,YAAY,eAAe,CAAC;AAAA,MAC7C,CAAC,CAAC;AAAA,MACN,oBACI,kBAAkB,kBAAkB,MAAM,QAAW,CAAC,MAAM,SAAS;AACjE,YAAI,KAAK,aAAa,WAAW,KAAK,WAAW,MAAM,GAAG;AACtD,iBAAO;AAAA,QACX;AACA,eAAO;AAAA,MACX,CAAC;AAAA,MACL,wBACI,yBAAyB,kBAAkB;AAAA,QACvC,aAAa;AAAA,MACjB,CAAC;AAAA,IACT;AAAA,EACJ;AACJ;AACA,SAAS,mBAAmB;AACxB,QAAM,oBAAoB,CAAC,OAAO,UAAU,SAAS,WAAW,YAAY,OAAO,YAAY,GAAG,YAAY,OAAO,UAAU,CAAC,EAAE,OAAO,UAAU,IAAI;AACvJ,SAAO,cAAc,YAAY,iBAAiB;AACtD;AACA,SAAS,iBAAiB;AACtB,QAAM,WAAW,CAAC,OAAO,UAAU,SAAS,WAAW,YAAY,OAAO,YAAY,GAAG,YAAY,OAAO,UAAU,GAAG,IAAI,EAAE,OAAO,UAAU,IAAI;AACpJ,SAAO,cAAc,SAAS,QAAQ;AAC1C;AACA,SAAS,0BAA0B;AAC/B,SAAO,CAAC,UAAU;AACd,WAAO,4BAA4B,YAAY,OAAO,UAAU,GAAG;AAAA,MAC/D,YAAY,OAAO,YAAY;AAAA,IACnC,CAAC,EAAE,KAAK;AAAA,EACZ;AACJ;AACA,SAAS,wBAAwB;AAC7B,SAAO,CAAC,UAAU;AACd,UAAM,EAAE,OAAO,IAAI;AACnB,WAAQ,4BAA4B,YAAY,OAAO,UAAU,GAAG;AAAA,MAChE,YAAY,OAAO,YAAY;AAAA,IACnC,CAAC,EAAE,KAAK,KAAK,WAAW,MAAM,UAAU,MAAM,KAAK,EAAE,GAAG,MAAM;AAAA,EAClE;AACJ;AAEA,IAAI,aAA0B,OAAO,OAAO;AAAA,EACxC,WAAW;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AAAA,EACV,aAAa;AAAA,EACb;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ,CAAC;AAED,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,aAAa;AAAA,EACf;AAAA,EACA;AACJ;AACA,IAAM,gBAAgB;AAAA,EAClB,YAAY;AAChB;AACA,IAAM,SAAS;AACf,IAAM,sBAAsB,CAAC,WAAW;AACpC,QAAM,WAAW,OAAO,MAAM,MAAM;AACpC,qBAAmB,UAAU,YAAY,MAAM,YAAY;AAC3D,SAAO;AACX;AACA,IAAM,mBAAmB,CAAC,UAAU;AAChC,QAAM,WAAW,MAAM,OAAO,MAAM,MAAM;AAC1C,qBAAmB,UAAU,YAAY,MAAM,YAAY;AAC3D,SAAO;AACX;AACA,SAAS,gBAAgB;AACrB,SAAO;AAAA,IACH,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,MACJ,UAAU;AAAA,MACV,UAAU,CAAC,EAAE,KAAK,OAAO,CAAC;AAAA,MAC1B,OAAO,MAAM,CAAC,QAAQ,CAAC;AAAA,IAC3B;AAAA,IACA,UAAU;AAAA,MACN,YAAY;AAAA,QACR,KAAK,QAAQ,OAAO,QAAQ,OAAO;AAC/B,iBAAO,aAAa,OAAO,MAAM,KAAK,GAAG,EAAE;AAAA,QAC/C;AAAA,QACA,MAAM,QAAQ,OAAO,QAAQ,OAAO;AAChC,iBAAO,aAAa,OAAO,MAAM,QAAQ,CAAC,GAAG,CAAC;AAAA,QAClD;AAAA,QACA,QAAQ;AAAA,MACZ;AAAA,MACA,eAAe;AAAA,QACX,aAAa,EAAE,MAAM,QAAQ,cAAc,KAAK;AAAA,MACpD;AAAA,IACJ;AAAA,EACJ;AACJ;AACA,SAAS,iBAAiB,EAAE,mBAAmB,MAAM,eAAe,MAAM,cAAc,cAAe,IAAI,CAAC,GAAG;AAC3G,SAAO,CAAC,EAAE,OAAO,MAAM;AACnB,UAAM,OAAO,oBAAoB,MAAM;AACvC,UAAM,gBAAgB;AAAA;AAAA;AAAA;AAAA,MAIlB,CAAC,UAAU,MAAM,UAAU,SAAS,MAAM,UAAU;AAAA,IACxD;AACA,WAAO;AAAA,MACH,oBAAoB,cAAgB,sBAAsB,IAAI;AAAA,MAC9D,oBAAoB,cAAc,sBAAsB,IAAI;AAAA,MAC5D,eACI,OAAO,aAAa,CAAC,CAAC,YAAY,YAAY,WAAW,IAAI,CAAC,CAAC,CAAC,CAAC;AAAA,MACrE,gBACI,OAAO;AAAA,QACH,YAAY,OAAO,eAAe,SAAS;AAAA,QAC3C,WAAW,OAAO,eAAe,QAAQ;AAAA,MAC7C,CAAC;AAAA,IACT;AAAA,EACJ;AACJ;AACA,IAAM,aAAa,CAAC,OAAO,QAAQ;AAc/B,MAAI,MAAM,KAAK,MAAM,MAAM,IAAI,QAAQ,MAAM;AACzC,WAAO;AAAA,EACX;AACA,QAAMM,QAAO,iBAAiB,KAAK;AACnC,QAAM,OAAO,MAAM,IAAI,OAAO,GAAG;AACjC,SAAO,OAAO,KAAK,MAAM,KAAK,CAAC,SAAS,KAAK,SAASA,KAAI,IAAI;AAClE;AACA,IAAI,YAAY,CAAC,OAAO,aAAa;AACjC,QAAMA,QAAO,iBAAiB,KAAK;AACnC,QAAM,UAAU,MAAM,UAAU;AAChC,MAAI,cAAc,MAAM,GAAG;AAC3B,QAAM,aAAa,WAAW,OAAOA,KAAI;AACzC,QAAM,oBAAoB,MAAM,IAAI,aAAa,QAAQ,KAAK,QAAQ,KAAKA,KAAI;AAC/E,QAAM,iBAAiB,MAAM,IAAI,aAAa,QAAQ,KAAK,QAAQ,MAAM,GAAGA,KAAI;AAChF,QAAM,eAAe,CAAC,qBAClB,kBACA,EAAE,eAAe,YAAY,SAAS;AAE1C,MAAI,CAAC,cAAc,cAAc;AAC7B,QAAI,UAAU;AACV,eAAS,MAAM,GAAG,cAAcA,MAAK,OAAO,CAAC,CAAC;AAAA,IAClD;AACA,WAAO;AAAA,EACX;AACA,QAAM,cAAc,CAAC,qBACjB,CAAC,kBACD,EAAE,eAAe,YAAY,WAAW;AAE5C,MAAI,cAAc,aAAa;AAC3B,QAAI,UAAU;AACV,eAAS,MAAM,GAAG,iBAAiBA,KAAI,CAAC;AAAA,IAC5C;AACA,WAAO;AAAA,EACX;AACA,SAAO;AACX;AACA,IAAI,WAAW,CAAC,OAAO,aAAa;AAChC,QAAMA,QAAO,iBAAiB,KAAK;AACnC,QAAM,aAAa,WAAW,OAAOA,KAAI;AACzC,QAAM,UAAU,MAAM,UAAU;AAChC,QAAM,EAAE,YAAY,IAAI,MAAM;AAC9B,QAAM,oBAAoB,WAAW,OAAO,QAAQ,GAAG;AACvD,QAAM,iBAAiB,WAAW,OAAO,QAAQ,MAAM,CAAC;AACxD,QAAM,qBAAqB,WAAW,OAAO,QAAQ,MAAM,CAAC;AAC5D,QAAM,cAAc,qBAAqB,CAAC,kBAAkB,MAAM,QAAQ,WAAW;AACrF,QAAM,aAAa,kBACf,CAAC,uBACA,gBAAgB,QACZ,MAAM,QAAQ,WAAW,KAAK,CAAC,CAAC,YAAY;AACrD,QAAM,eAAgB,eAAe,MAAM,QAAQ,WAAW,KAAK,CAAC,YAAY,UAC3E,CAAC,eAAe,gBAAgB,SACjC,CAAC,kBACD;AACJ,QAAM,eAAe,CAAC,qBAClB,kBACA,MAAM,QAAQ,WAAW,KACzB,CAAC,YAAY;AAEjB,MAAI,CAAC,cAAc,aAAa;AAC5B,UAAM,KAAK,MAAM,GAAG,aAAa,UAAU,KAAK,MAAM,IAAI,QAAQ,QAAQ,MAAM,CAAC,CAAC,CAAC;AACnF,QAAI,UAAU;AACV,eAAS,GAAG,iBAAiBA,KAAI,CAAC;AAAA,IACtC;AACA,WAAO;AAAA,EACX;AAEA,MAAI,CAAC,cAAc,cAAc;AAC7B,QAAI,UAAU;AACV,eAAS,MAAM,GAAG,cAAcA,MAAK,OAAO,CAAC,CAAC;AAAA,IAClD;AACA,WAAO;AAAA,EACX;AAEA,MAAI,cAAc,YAAY;AAC1B,UAAM,KAAK,MAAM,GAAG,aAAa,UAAU,KAAK,MAAM,IAAI,QAAQ,QAAQ,MAAM,CAAC,CAAC,CAAC;AACnF,QAAI,UAAU;AACV,eAAS,GAAG,cAAcA,MAAK,OAAO,CAAC,CAAC;AAAA,IAC5C;AACA,WAAO;AAAA,EACX;AAEA,QAAM,eAAe,QAAQ,MAAM,QAAQ,QAAQ,CAAC,MAAM;AAC1D,MAAI,eAAe,eAAgB,CAAC,QAAQ,cAAc,eAAgB;AACtE,QAAI,UAAU;AACV,eAAS,MAAM,GAAG,iBAAiBA,KAAI,CAAC;AAAA,IAC5C;AACA,WAAO;AAAA,EACX;AACA,SAAO;AACX;AACA,SAAS,aAAa,MAAM,MAAM;AAC9B,MAAI,QAAQ;AACZ,MAAI;AACJ,MAAI,MAAM;AACV,MAAI,KAAK,QAAQ;AACb,WAAQ,IAAI,MAAM,KAAK,KAAK,IAAI,GAAI;AAChC,UAAI,MAAM,EAAE,CAAC;AACb,UAAI,OAAO,QAAQ,UAAU;AACzB,cAAM,KAAK,IAAI,KAAK,IAAI,MAAM;AAAA,MAClC;AAAA,IACJ;AAAA,EACJ;AACA,MAAI,SAAS,MAAM,KAAK,OAAO,IAAI,OAAO;AAC1C,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC1B,cAAU;AAAA,EACd;AACA,MAAI,MAAM,KAAK,OAAO,GAAG;AACrB,cAAU;AAAA,EACd;AACA,SAAO;AACX;AACA,SAAS,WAAW,OAAO,MAAM;AAC7B,QAAM,EAAE,MAAM,IAAI,MAAM,IAAI,MAAM;AAElC,MAAI,OAAO;AACP,WAAO,CAAC,CAAC,KAAK,QAAQ,MAAM,GAAG,eAAe,MAAM,UAAU,MAAM,MAAM,CAAC;AAAA,EAC/E;AAEA,MAAI,QAAQ;AACZ,QAAM,IAAI,aAAa,MAAM,IAAI,CAAC,SAAS;AACvC,YAAQ,SAAS,CAAC,CAAC,KAAK,QAAQ,KAAK,KAAK;AAAA,EAC9C,CAAC;AACD,SAAO;AACX;AACA,SAAS,aAAa;AAClB,SAAO,CAAC,OAAO,aAAa;AACxB,UAAM,WAAW,MAAM,OAAO,MAAM,MAAM;AAC1C,uBAAmB,UAAU,YAAY,MAAM,YAAY;AAC3D,WAAO,WAAW,QAAQ,EAAE,OAAO,QAAQ;AAAA,EAC/C;AACJ;AACA,SAAS,oBAAoB;AACzB,SAAO,CAAC,UAAU;AACd,UAAM,WAAW,MAAM,OAAO,MAAM,MAAM;AAC1C,uBAAmB,UAAU,YAAY,MAAM,YAAY;AAC3D,WAAO,wBAAwB,QAAQ,EAAE,KAAK;AAAA,EAClD;AACJ;AAEA,IAAI,OAAoB,OAAO,OAAO;AAAA,EAClC,WAAW;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AAAA,EACV,aAAa;AAAA,EACb;AAAA,EACA;AACJ,CAAC;AAED,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,aAAa;AAAA,EACf;AACJ;AACA,IAAM,gBAAgB;AAAA,EAClB,aAAa;AAAA,EACb,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,sBAAsB;AAAA,EACtB,sBAAsB;AAC1B;AACA,IAAM,SAAS;AACf,SAAS,gBAAgB;AACrB,SAAO;AAAA,IACH,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,MACJ,OAAO;AAAA,QACH,UAAU,EAAE,SAAS,GAAG;AAAA,MAC5B;AAAA,MACA,SAAS;AAAA,MACT,OAAO;AAAA,MACP,OAAO;AAAA,MACP,MAAM;AAAA,MACN,UAAU;AAAA,MACV,WAAW;AAAA,MACX,UAAU,CAAC,EAAE,KAAK,OAAO,oBAAoB,OAAO,CAAC;AAAA,MACrD,OAAO,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;AAAA,IACpC;AAAA,IACA,UAAU;AAAA,MACN,WAAW,OAAO,MAAM;AACpB,cAAM,MAAM,SAAS,KAAK,MAAM,UAAU,KAAK,MAAM,IAAI;AACzD,cAAM,KAAK,KAAK,aAAa,KAAK;AAClC,cAAM,cAAc;AACpB,cAAM,MAAM,KAAK;AACjB,cAAM,WAAW,IAAI;AAAA,MACzB;AAAA,MACA,eAAe;AAAA,QACX,YAAY,EAAE,OAAO,QAAQ,cAAc,KAAK;AAAA,QAChD,OAAO;AAAA,UACH,OAAO;AAAA,UACP,UAAU,CAAC,SAAS,EAAE,UAAU,IAAI,QAAQ,GAAG;AAAA,UAC/C,cAAc;AAAA,QAClB;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;AACA,SAAS,iBAAiB,EAAE,mBAAmB,MAAM,cAAc,cAAe,IAAI,CAAC,GAAG;AACtF,SAAO,CAAC,EAAE,OAAO,MAAM;AACnB,UAAM,OAAO,YAAY,QAAQ,MAAM;AACvC,WAAO;AAAA,MACH,oBAAoB,uBAAuB,SAAS,IAAI;AAAA,MACxD,eACI,OAAO,aAAa;AAAA,QAChB,CAAC,YAAY,aAAa,aAAa,IAAI,CAAC;AAAA,QAC5C,CAAC,YAAY,QAAQ,SAAS,MAAM,IAAI,CAAC;AAAA,QACzC,CAAC,YAAY,UAAU,SAAS,MAAM,MAAM,CAAC;AAAA,QAC7C;AAAA,UACI,YAAY;AAAA,UACZ,OAAO,uBAAuB,GAAG,YAAY,gBAAgB,MAAM,GAAG,SAAS,KAAK,CAAC;AAAA,QACzF;AAAA,QACA;AAAA,UACI,YAAY;AAAA,UACZ,OAAO,uBAAuB,GAAG,YAAY,gBAAgB,MAAM,GAAG,SAAS,KAAK,CAAC;AAAA,QACzF;AAAA,MACJ,CAAC,CAAC;AAAA,IACV;AAAA,EACJ;AACJ;AACA,SAAS,yBAAyB;AAC9B,SAAO,CAAC,UAAU;AACd,UAAM,OAAO,YAAY,OAAO,MAAM;AACtC,WAAO,QAAQ,qBAAqB,IAAI,EAAE,MAAM,SAAS,CAAC;AAAA,EAC9D;AACJ;AAEA,IAAI,YAAyB,OAAO,OAAO;AAAA,EACvC,WAAW;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AAAA,EACV,aAAa;AAAA,EACb;AACJ,CAAC;AAED,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,gBAAgB;AAAA,EAClB,QAAQ;AACZ;AACA,IAAM,SAAS;AACf,SAAS,gBAAgB;AACrB,SAAO;AAAA,IACH,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,MACJ,QAAQ;AAAA,MACR,OAAO;AAAA,MACP,YAAY;AAAA,MACZ,UAAU,CAAC,EAAE,KAAK,KAAK,CAAC;AAAA,MACxB,OAAO,MAAM,CAAC,IAAI;AAAA,IACtB;AAAA,IACA,UAAU;AAAA,MACN,WAAW,OAAO,MAAM,QAAQ,OAAO;AACnC,iBAAS,IAAI,QAAQ,GAAG,IAAI,OAAO,YAAY,KAAK;AAChD,cAAI,OAAO,MAAM,CAAC,EAAE,SAAS,KAAK,MAAM;AACpC,kBAAM,MAAM,MAAM;AAClB;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,eAAe;AAAA,QACX,WAAW,EAAE,MAAM,YAAY;AAAA,MACnC;AAAA,IACJ;AAAA,EACJ;AACJ;AACA,SAAS,iBAAiB,EAAE,cAAc,cAAc,IAAI,CAAC,GAAG;AAC5D,SAAO,CAAC,EAAE,OAAO,MAAM;AACnB,UAAM,OAAO,YAAY,QAAQ,MAAM;AACvC,UAAM,UAAU,cAAc,UAAU,CAAC,OAAO,aAAa;AACzD,UAAI,UAAU;AACV,iBAAS,MAAM,GAAG,qBAAqB,KAAK,OAAO,CAAC,EAAE,eAAe,CAAC;AAAA,MAC1E;AACA,aAAO;AAAA,IACX,CAAC;AACD,WAAO;AAAA,MACH,eAAe,OAAO,aAAa,CAAC,CAAC,YAAY,QAAQ,OAAO,CAAC,CAAC,CAAC;AAAA,IACvE;AAAA,EACJ;AACJ;AAEA,IAAI,YAAyB,OAAO,OAAO;AAAA,EACvC,WAAW;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,EACT,aAAa;AACjB,CAAC;AAED,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,aAAa;AAAA,EACf;AAAA,EACA;AACJ;AACA,IAAM,gBAAgB;AAAA,EAClB,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,WAAW;AAAA,EACX,UAAU;AAAA,EACV,sBAAsB;AAAA,EACtB,sBAAsB,QAAQ,MAAM,WAAW;AAAA,EAC/C,oBAAoB,QAAQ,MAAM,WAAW;AAAA,EAC7C,sBAAsB;AAAA,EACtB,gBAAgB;AACpB;AACA,IAAM,SAAS;AACf,IAAM,gBAAgB,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AACvC,IAAM,mBAAmB,CAAC,UAAU;AAChC,QAAM,OAAO,YAAY,OAAO,MAAM;AACtC,SAAO,qBAAqB,IAAI,EAAE,MAAM,SAAS;AACrD;AACA,IAAM,aAAa,CAAC,aAAa;AAC7B,QAAM,QAAQ,SAAS,UAAU,EAAE;AACnC,SAAO,OAAO,MAAM,KAAK,IAAI,SAAY;AAC7C;AACA,SAAS,cAAc,EAAE,SAAS,cAAc,IAAI,CAAC,GAAG;AACpD,MAAI,OAAO,KAAK,CAAC,MAAM,OAAO,MAAM,QAAQ,GAAG;AAC3C,UAAM,IAAI,MAAM,uBAAuB;AAAA,EAC3C;AACA,QAAM,UAAU;AAAA,IACZ;AAAA,EACJ;AACA,SAAO;AAAA,IACH,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,MACJ,OAAO;AAAA,QACH,OAAO;AAAA,UACH,SAAS;AAAA,QACb;AAAA,QACA,iBAAiB;AAAA,UACb,SAAS;AAAA,QACb;AAAA,MACJ;AAAA,MACA,SAAS;AAAA,MACT,OAAO;AAAA,MACP,UAAU;AAAA,MACV,WAAW;AAAA,MACX,UAAU,OAAO,IAAI,CAAC,UAAU;AAC5B,eAAO;AAAA,UACH,KAAK,IAAI,KAAK;AAAA,UACd,UAAU,CAAC,QAAQ;AACf,kBAAM,SAAS,EAAE,OAAO,WAAW,KAAK,EAAE;AAC1C,kBAAM,QAAQ,IAAI,aAAa,mBAAmB;AAClD,gBAAI,CAAC,OAAO;AACR,qBAAO;AAAA,YACX;AACA,kBAAM,MAAM,KAAK,MAAM,KAAK;AAC5B,mBAAO,OAAO,OAAO,CAAC,GAAG,QAAQ,GAAG;AAAA,UACxC;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,MACD,OAAO,CAAC,SAAS;AACb,cAAM,SAAS,CAAC,IAAI,KAAK,MAAM,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC;AAChD,YAAI,KAAK,MAAM,iBAAiB,GAAG;AAC/B,iBAAO,CAAC,EAAE,mBAAmB,IAAI,KAAK,UAAU;AAAA,YAC5C,iBAAiB,KAAK,MAAM,iBAAiB;AAAA,UACjD,CAAC;AACD,iBAAO,CAAC,EAAE,OAAO,IAAI;AAAA,QACzB;AACA,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,IACA,UAAU;AAAA,MACN,WAAW,OAAO,MAAM;AACpB,cAAM,MAAM,MAAM,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC,IAAI,GAAG;AACxD,cAAM,aAAa,IAAI;AACvB,cAAM,WAAW,IAAI;AAAA,MACzB;AAAA,MACA,eAAe;AAAA,QACX,SAAS;AAAA,UACL,OAAO;AAAA,UACP,UAAU,CAAC,QAAQ;AACf,mBAAO,EAAE,OAAO,WAAW,IAAI,IAAI,MAAM,CAAC,CAAC,EAAE;AAAA,UACjD;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,EACJ;AACJ;AACA,SAAS,iBAAiB,EAAE,mBAAmB,MAAM,cAAc,cAAe,IAAI,CAAC,GAAG;AACtF,SAAO,CAAC,EAAE,QAAQ,aAAa,MAAM;AACjC,UAAM,EAAE,OAAO,IAAI,aAAa,QAAQ,MAAM;AAC9C,UAAM,OAAO,YAAY,QAAQ,MAAM;AACvC,UAAM,gBAAgB,OAAO,YAAY,OAAO,IAAI,CAAC,UAAU;AAAA,MAC3D,YAAY,MAAM,KAAK,EAAE;AAAA,MACzB,aAAa,MAAM,EAAE,MAAM,CAAC;AAAA,IAChC,CAAC,CAAC;AACF,WAAO;AAAA,MACH,eACI,OAAO;AAAA,QACH,GAAG;AAAA,QACH,GAAG,aAAa;AAAA,UACZ,CAAC,YAAY,QAAQ,GAAG,SAAS,MAAM,IAAI,CAAC;AAAA,UAC5C,CAAC,YAAY,UAAU,GAAG,SAAS,MAAM,MAAM,CAAC;AAAA,UAChD,CAAC,YAAY,sBAAsB,GAAG,kBAAkB,IAAI,CAAC;AAAA,UAC7D,CAAC,YAAY,oBAAoB,GAAG,gBAAgB,IAAI,CAAC;AAAA,UACzD,CAAC,YAAY,WAAW,GAAG,iBAAiB,IAAI,CAAC;AAAA,UACjD,CAAC,YAAY,UAAU,GAAG,gBAAgB,IAAI,CAAC;AAAA,UAC/C,CAAC,YAAY,sBAAsB,GAAG,qBAAqB,CAAC;AAAA,UAC5D,CAAC,YAAY,sBAAsB,GAAG,qBAAqB,CAAC;AAAA,UAC5D,CAAC,YAAY,gBAAgB,GAAG,sBAAsB,CAAC;AAAA,QAC3D,CAAC;AAAA,MACL,CAAC;AAAA,MACL,IAAI,mBAAmB,SAAS,CAAC,GAAG,IAAI,CAAC,UAAU,uBAAuB,IAAI,OAAO,SAAS,KAAK,QAAQ,GAAG,MAAM,OAAO;AAAA,QACvH;AAAA,MACJ,EAAE,CAAC;AAAA,IACP;AAAA,EACJ;AACJ;AACA,SAAS,cAAc,QAAQ,GAAG;AAC9B,SAAO,CAAC,OAAO,aAAa;AACxB,QAAI,qBAAqB,KAAK,EAAE,KAAK,GAAG;AACpC,YAAM,OAAO,gBAAgB,KAAK;AAClC,aAAO,aAAa,IAAI,EAAE,OAAO,QAAQ;AAAA,IAC7C;AACA,WAAO,aAAa,YAAY,OAAO,MAAM,GAAG,EAAE,MAAM,CAAC,EAAE,OAAO,QAAQ;AAAA,EAC9E;AACJ;AACA,SAAS,qBAAqB,OAAO;AACjC,SAAO,CAAC,UAAU;AACd,UAAM,QAAQ,qBAAqB,YAAY,OAAO,MAAM,CAAC,EAAE,MAAM,SAAS;AAC9E,QAAI,CAAC,OAAO;AACR,aAAO;AAAA,IACX;AACA,UAAM,EAAE,KAAK,IAAI;AACjB,QAAI,SAAS,MAAM;AACf,aAAO;AAAA,IACX;AACA,WAAO,KAAK,MAAM,OAAO,MAAM;AAAA,EACnC;AACJ;AACA,SAAS,wBAAwB;AAC7B,SAAO,CAAC,UAAU;AACd,UAAM,QAAQ,qBAAqB,YAAY,OAAO,MAAM,CAAC,EAAE,MAAM,SAAS;AAC9E,QAAI,CAAC,SAAS,CAAC,cAAc,KAAK,GAAG;AACjC,aAAO;AAAA,IACX;AACA,WAAO,QAAQ,MAAM,KAAK,MAAM,iBAAiB,CAAC;AAAA,EACtD;AACJ;AACA,SAAS,kBAAkB;AACvB,SAAO,CAAC,OAAO,aAAa;AACxB,UAAM,QAAQ,qBAAqB,YAAY,OAAO,MAAM,CAAC,EAAE,MAAM,SAAS;AAC9E,QAAI,CAAC,SAAS,CAAC,cAAc,KAAK,GAAG;AACjC,aAAO;AAAA,IACX;AACA,UAAM,cAAc,sBAAsB,EAAE,KAAK;AACjD,QAAI,aAAa;AACb,aAAO;AAAA,IACX;AACA,UAAM,SAAS,qBAAqB,MAAM,MAAM,MAAM,GAAG;AACzD,QAAI,CAAC,QAAQ;AACT,aAAO;AAAA,IACX;AACA,UAAM,EAAE,UAAU,OAAO,IAAI,IAAI;AACjC,QAAI,KAAK,MAAM,GAAG,YAAY,OAAO,KAAK,YAAY,OAAO,MAAM,EAAE,cAAc;AAAA,MAC/E,GAAG,MAAM,KAAK;AAAA,MACd,iBAAiB,SAAS,OAAO;AAAA,IACrC,GAAG,MAAM,KAAK,OAAO,CAAC;AACtB,QAAI,MAAM,qBAAqB,eAAe;AAC1C,WAAK,GAAG,aAAa,cAAc,OAAO,GAAG,KAAK,MAAM,UAAU,IAAI,CAAC;AAAA,IAC3E;AACA,QAAI,UAAU;AACV,eAAS,EAAE;AAAA,IACf;AACA,WAAO;AAAA,EACX;AACJ;AACA,SAAS,oBAAoB;AACzB,SAAO,CAAC,OAAO,aAAa;AACxB,UAAM,QAAQ,qBAAqB,YAAY,OAAO,MAAM,CAAC,EAAE,MAAM,SAAS;AAC9E,QAAI,CAAC,SAAS,CAAC,cAAc,KAAK,GAAG;AACjC,aAAO;AAAA,IACX;AACA,UAAM,cAAc,sBAAsB,EAAE,KAAK;AACjD,QAAI,CAAC,aAAa;AACd,aAAO;AAAA,IACX;AACA,UAAM,OAAO,SAAS,SAAS,MAAM,QAAQ,MAAM,KAAK,MAAM,iBAAiB,CAAC;AAChF,QAAI,KAAK,MAAM,GAAG,YAAY,MAAM,KAAK,MAAM,MAAM,MAAM,KAAK,UAAU,SAAS,UAAU;AAAA,MACzF,YAAY,OAAO,MAAM,EAAE,cAAc;AAAA,QACrC,GAAG,MAAM,KAAK;AAAA,QACd,iBAAiB;AAAA,MACrB,GAAG,MAAM,KAAK,OAAO;AAAA,IACzB,CAAC,EAAE,OAAO,IAAI,CAAC;AACf,QAAI,MAAM,qBAAqB,eAAe;AAC1C,WAAK,GAAG,aAAa,cAAc,OAAO,GAAG,KAAK,MAAM,UAAU,IAAI,CAAC;AAAA,IAC3E;AACA,QAAI,UAAU;AACV,eAAS,EAAE;AAAA,IACf;AACA,WAAO;AAAA,EACX;AACJ;AACA,SAAS,uBAAuB;AAC5B,SAAO,OAAO,kBAAkB,CAAC,OAAO,UAAU,SAAS;AACvD,UAAM,OAAO,gBAAgB,KAAK;AAClC,WAAO,YAAY,MAAM,SAAS,KAAK,EAAE,OAAO,UAAU,IAAI;AAAA,EAClE,CAAC;AACL;AACA,SAAS,uBAAuB;AAC5B,SAAO,OAAO,kBAAkB,CAAC,OAAO,UAAU,SAAS;AACvD,UAAM,OAAO,gBAAgB,KAAK;AAClC,WAAO,YAAY,MAAM,SAAS,KAAK,EAAE,OAAO,UAAU,IAAI;AAAA,EAClE,CAAC;AACL;AACA,SAAS,wBAAwB;AAC7B,SAAO,CAAC,OAAO,aAAa;AACxB,UAAM,QAAQ,qBAAqB,YAAY,OAAO,MAAM,CAAC,EAAE,MAAM,SAAS;AAC9E,QAAI,CAAC,SAAS,MAAM,UAAU,GAAG;AAC7B,aAAO;AAAA,IACX;AACA,UAAM,cAAc,sBAAsB,EAAE,KAAK;AACjD,WAAO,cACD,kBAAkB,EAAE,OAAO,QAAQ,IACnC,gBAAgB,EAAE,OAAO,QAAQ;AAAA,EAC3C;AACJ;AACA,SAAS,wBAAwB;AAC7B,SAAO,CAAC,OAAO,aAAa;AACxB,UAAM,mBAAmB,qBAAqB,KAAK;AACnD,QAAI,KAAK,MAAM;AACf,QAAI,SAAS;AACb,eAAW,EAAE,MAAM,IAAI,KAAK,kBAAkB;AAC1C,UAAI,WAAW,SAAS,SAAS,MAAM,QAAQ,oBAAoB,KAAK,MAAM,iBAAiB,CAAC,CAAC;AACjG,WAAK,GAAG,YAAY,SAAS,KAAK,SAAS,MAAM,KAAK,UAAU,SAAS,UAAU;AAAA,QAC/E,YAAY,OAAO,MAAM,EAAE,cAAc;AAAA,UACrC,GAAG,KAAK;AAAA,UACR,iBAAiB;AAAA,QACrB,GAAG,KAAK,OAAO;AAAA,MACnB,CAAC,EAAE,OAAO,QAAQ,CAAC;AACnB,gBAAU,SAAS;AAAA,IACvB;AACA,QAAI,MAAM,qBAAqB,eAAe;AAC1C,WAAK,GAAG,aAAa,cAAc,OAAO,GAAG,KAAK,MAAM,UAAU,IAAI,CAAC;AAAA,IAC3E;AACA,QAAI,UAAU;AACV,eAAS,EAAE;AAAA,IACf;AACA,WAAO;AAAA,EACX;AACJ;AACA,SAAS,qBAAqB,OAAO;AACjC,SAAO,aAAa,MAAM,KAAK,CAAC,SAAS,KAAK,SAAS,YAAY,OAAO,MAAM,KAC5E,QAAQ,KAAK,MAAM,iBAAiB,CAAC,GAAG,KAAK;AACrD;AACA,SAAS,uBAAuB,OAAO;AACnC,SAAO,aAAa,MAAM,KAAK,CAAC,SAAS,KAAK,SAAS,YAAY,OAAO,MAAM,GAAG,KAAK;AAC5F;AACA,IAAM,sBAAsB,CAAC,aAAa;AACtC,MAAI,SAAS,CAAC;AACd,WAAS,QAAQ,CAAC,aAAa;AAC3B,QAAI,SAAS,MAAM,MAAM,aAAa,SAAS,OAAO,EAAE,iBAAiB;AACrE,YAAM,kBAAkB,SAAS,OAAO,EAAE;AAC1C,aAAO,KAAK;AAAA,QACR,GAAG;AAAA,QACH,OAAO;AAAA,UACH,GAAG,SAAS,OAAO;AAAA,UACnB,iBAAiB;AAAA,QACrB;AAAA,MACJ,CAAC;AACD,aAAO,KAAK,GAAG,oBAAoB,eAAe,CAAC;AAAA,IACvD,OACK;AACD,aAAO,KAAK,QAAQ;AAAA,IACxB;AAAA,EACJ,CAAC;AACD,SAAO;AACX;AAUA,SAAS,cAAc,OAAO;AAC1B,MAAI,MAAM,UAAU,GAAG;AACnB,WAAO;AAAA,EACX;AACA,SAAO;AACX;AACA,SAAS,qBAAqB,WAAWJ,MAAK;AAE1C,MAAI,QAAQ;AACZ,MAAI,MAAM;AACV,MAAI,SAAS;AACb,QAAM,gBAAgB,CAAC,SAAS;AAC5B,QAAI,KAAK,SAAS,UAAU,MAAM;AAC9B,aAAO;AAAA,IACX;AACA,QAAI,KAAK,MAAM,OAAO,KAAK,UAAU,MAAM,OAAO,GAAG;AACjD,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AACA,EAAAA,KAAI,QAAQ,CAAC,MAAM,QAAQ,UAAU;AACjC,QAAI,QAAQ;AACR;AAAA,IACJ;AACA,QAAI,SAAS,WAAW;AACpB,cAAQ,EAAE,OAAO,QAAQ,KAAK;AAC9B;AAAA,IACJ;AACA,QAAI,OAAO;AACP,UAAI,cAAc,IAAI,GAAG;AACrB,iBAAS;AACT;AAAA,MACJ;AAKA,UAAI,KAAK,QAAQ,SAAS,GAAG;AACzB,cAAM,EAAE,OAAO,QAAQ,KAAK;AAAA,MAChC;AAAA,IACJ;AAAA,EACJ,CAAC;AACD,MAAI,CAAC,KAAK;AACN,WAAO;AAAA,EACX;AAGA,QAAM,QAAQA,KAAI;AAAA,IAAM,MAAM,SAAS,MAAM,KAAK;AAAA;AAAA,IAElD,IAAI,SAAS,IAAI,KAAK;AAAA,EAAQ;AAC9B,SAAO;AAAA,IACH,UAAU,MAAM;AAAA,IAChB,OAAO,MAAM;AAAA;AAAA,IAEb,KAAK,IAAI,SAAS,IAAI,KAAK;AAAA,EAC/B;AACJ;AAEA,IAAI,UAAuB,OAAO,OAAO;AAAA,EACrC,WAAW;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AAAA,EACV,aAAa;AAAA,EACb;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ,CAAC;AAED,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,SAAS;AACf,SAAS,gBAAgB;AACrB,SAAO;AAAA,IACH,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,MACJ,OAAO;AAAA,MACP,UAAU,CAAC,EAAE,KAAK,KAAK,CAAC;AAAA,MACxB,OAAO,MAAM,CAAC,IAAI;AAAA,IACtB;AAAA,IACA,UAAU;AAAA,MACN,WAAW,OAAO,MAAM;AACpB,cAAM,MAAM,KAAK,MAAM,QAAQ,KAAK,KAAK;AACzC,cAAM,WAAW,IAAI;AAAA,MACzB;AAAA,MACA,eAAe,EAAE,IAAI,EAAE,MAAM,OAAO,EAAE;AAAA,IAC1C;AAAA,EACJ;AACJ;AACA,SAAS,iBAAiB,EAAE,mBAAmB,KAAK,IAAI,CAAC,GAAG;AACxD,SAAO,CAAC,EAAE,OAAO,MAAM;AACnB,UAAM,OAAO,YAAY,QAAQ,MAAM;AACvC,WAAO;AAAA,MACH,oBACI,IAAI,UAAU,4BAA4B,CAAC,OAAO,OAAO,OAAO,QAAQ;AACpE,YAAI,CAAC,MAAM,CAAC,GAAG;AACX,iBAAO;AAAA,QACX;AACA,YAAI,KAAK,MAAM,GAAG,YAAY,QAAQ,GAAG,KAAK,KAAK,cAAc,CAAC;AAIlE,cAAM,QAAQ,MAAM,IAAI,QAAQ,KAAK;AACrC,YAAI,kBAAkB;AACtB,YAAI,MAAM,IAAI,KAAK,KAAK;AAGpB,4BAAkB;AAAA,QACtB,WACS,MAAM,MAAM,KAAK,MAAM,IAAI,EAAE,GAAG;AAGrC,4BAAkB;AAAA,QACtB,OACK;AACD,gBAAM,WAAW,MAAM,IAAI,QAAQ,MAAM,MAAM,CAAC,EAAE;AAElD,4BAAkB,SAAS,SAAS;AAAA,QACxC;AACA,eAAO,kBACD,WAAW,gBAAgB,KAAK,EAAE,cAAc,GAAG,GAAG,QAAQ,IAAI,MAAM,MAAM,CAAC,CAAC,EAAE,EAAE,IACpF;AAAA,MACV,CAAC;AAAA,IACT;AAAA,EACJ;AACJ;AAEA,IAAI,iBAA8B,OAAO,OAAO;AAAA,EAC5C,WAAW;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AACb,CAAC;AAID,SAAS,MAAM,KAAK;AAChB,MAAI,OAAO,IAAI,QAAQ,GAAG,MAAM,KAAK,OAAO,IAAI,QAAQ,GAAG,MAAM,KAAK,OAAO;AAC7E,SAAO,KAAK,CAAC,IAAI,MAAM,KAAK,CAAC;AACjC;AAEA,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,aAAa,CAAC;AACpB,IAAM,SAAS;AACf,SAAS,gBAAgB;AACrB,SAAO;AAAA,IACH,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,MACJ,QAAQ;AAAA,MACR,OAAO;AAAA,QACH,KAAK,CAAC;AAAA,QACN,KAAK;AAAA,UACD,SAAS;AAAA,QACb;AAAA,QACA,OAAO;AAAA,UACH,SAAS;AAAA,QACb;AAAA,MACJ;AAAA,MACA,OAAO;AAAA,MACP,WAAW;AAAA,MACX,UAAU;AAAA,QACN;AAAA,UACI,KAAK;AAAA,UACL,UAAU,CAAC,SAAS;AAAA,YAChB,KAAK,IAAI,aAAa,KAAK;AAAA,YAC3B,OAAO,IAAI,aAAa,OAAO;AAAA,YAC/B,KAAK,IAAI,aAAa,KAAK;AAAA,UAC/B;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,OAAO,CAAC,SAAS;AACb,eAAO,CAAC,OAAO,KAAK,KAAK;AAAA,MAC7B;AAAA,IACJ;AAAA,IACA,UAAU;AAAA,MACN,WAAW,OAAO,MAAM;AACpB,cAAMK,QAAO,MAAM,IAAI,KAAK,MAAM,KAAK,KAAK,EAAE;AAC9C,cAAM,MAAM,MAAM,IAAI,KAAK,MAAM,KAAK,CAAC,KAClC,KAAK,MAAM,OAAO,IAAI,MAAM,MAAM,KAAK,MAAM,OAAO,CAAC,IAAI;AAC9D,cAAM,MAAM,KAAKA,KAAI,KAAK,GAAG,GAAG;AAAA,MACpC;AAAA,MACA,eAAe;AAAA,QACX,OAAO;AAAA,UACH,MAAM;AAAA,UACN,UAAU,CAAC,SAAS;AAAA,YAChB,KAAK,IAAI,QAAQ,KAAK;AAAA,YACtB,OAAO,IAAI,QAAQ,OAAO,KAAK;AAAA,YAC/B,KAAM,IAAI,SAAS,CAAC,KAAK,IAAI,SAAS,CAAC,EAAE,WAAY;AAAA,UACzD;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;AACA,SAAS,iBAAiB,EAAE,oBAAoB,MAAM,iBAAiB,WAAW,mBAAmB,wBAAyB,IAAI,CAAC,GAAG;AAClI,SAAO,CAAC,EAAE,OAAO,MAAM;AACnB,UAAM,OAAO,YAAY,QAAQ,MAAM;AACvC,WAAO;AAAA,MACH,IAAI,UAAU,iDAAiD,CAAC,OAAO,OAAO,OAAO,QAAQ;AACzF,YAAI,CAAC,EAAE,KAAK,KAAK,KAAK,IAAI;AAC1B,YAAI,CAAC,KAAK;AACN,iBAAO;AAAA,QACX;AACA,YAAI,CAAC,OAAO;AACR,kBAAQ;AAAA,QACZ;AACA,eAAO,MAAM,GAAG,YAAY,OAAO,KAAK,KAAK,OAAO;AAAA,UAChD;AAAA,UACA;AAAA,UACA;AAAA,QACJ,CAAC,CAAC;AAAA,MACN,CAAC;AAAA,MACD,qBACI,IAAI,OAAO;AAAA,QACP,KAAK,IAAI,UAAU,SAAS,aAAa;AAAA,QACzC,OAAO;AAAA,UACH,iBAAiB;AAAA,YACb,KAAK,MAAM,QAAQ;AACf,oBAAM,QAAQ;AACd,kBAAI,MAAM,gBAAgB,MAAM;AAC5B,uBAAO;AAAA,cACX;AACA,oBAAM,QAAQ,YAAY,MAAM,cAAc,gBAAgB,IAAI;AAIlE,kBAAI,CAAC,SAAS,MAAM,WAAW,GAAG;AAC9B,uBAAO;AAAA,cACX;AACA,oBAAM,eAAe;AACrB,oBAAM,cAAc,KAAK,YAAY;AAAA,gBACjC,MAAM,MAAM;AAAA,gBACZ,KAAK,MAAM;AAAA,cACf,CAAC;AACD,+BAAiB,OAAO,YAAY,KAAK,OAAO,MAAM,GAAG,IAAI,EAAE,KAAK,CAAC,eAAe;AAChF,gCAAgB,MAAM,eAAe,OAAO,SAAY,YAAY,KAAK,UAAU;AAAA,cACvF,CAAC;AACD,qBAAO;AAAA,YACX;AAAA,UACJ;AAAA,UACA,aAAa,CAAC,MAAM,aAAa;AAC7B,kBAAM,QAAQ;AACd,gBAAI,CAAC,MAAM,eAAe;AACtB,qBAAO;AAAA,YACX;AACA,kBAAM,QAAQ,YAAY,MAAM,eAAe,gBAAgB,IAAI;AACnE,gBAAI,CAAC,SAAS,MAAM,WAAW,GAAG;AAC9B,qBAAO;AAAA,YACX;AACA,6BAAiB,OAAO,YAAY,KAAK,OAAO,MAAM,GAAG,IAAI,EAAE,KAAK,CAAC,eAAe;AAChF,8BAAgB,MAAM,KAAK,MAAM,UAAU,MAAM,UAAU;AAAA,YAC/D,CAAC;AACD,mBAAO;AAAA,UACX;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACT;AAAA,EACJ;AACJ;AACA,eAAe,wBAAwB,OAAO,WAAW,OAAO;AAC5D,MAAI,uBAAuB,MAAM,QAAQ,IAAI,MAAM,IAAI,CAAC,SAAS,uBAAuB,IAAI,CAAC,CAAC;AAC9F,SAAO,qBAAqB,IAAI,CAAC,cAAc;AAC3C,WAAO,UAAU,OAAO;AAAA,MACpB,KAAK;AAAA,IACT,CAAC;AAAA,EACL,CAAC;AACL;AACA,SAAS,gBAAgB,MAAM,KAAK,YAAY;AAC5C,aAAW,QAAQ,YAAY;AAC3B,UAAM,EAAE,GAAG,IAAI,KAAK;AACpB,QAAI,QAAQ,WAAW,MAAM,GAAG,EAAE,EAAE;AACpC,QAAI,UAAU,IAAI;AACd;AAAA,IACJ;AACA,SAAK,SAAS,KAAK;AAAA,EACvB;AACJ;AACA,SAAS,uBAAuB,MAAM;AAClC,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACpC,UAAM,SAAS,IAAI,WAAW;AAC9B,UAAM,qBAAqB,CAAC,cAAc;AACtC,YAAM,YAAY,KAAK,UAAU,OAAO,MAAM;AAC9C,cAAQ,QAAQ,KAAK,IAAI,WAAW,SAAS,EAAE;AAAA,IACnD;AACA,UAAM,gBAAgB,CAAC,cAAc;AACjC,cAAQ,UAAU,OAAO,MAAM;AAAA,IACnC;AACA,WAAO,UAAU,MAAM;AACnB,aAAO,IAAI,MAAM,uBAAuB,KAAK,IAAI,CAAC;AAAA,IACtD;AAEA,QAAI,mBAAmB,QAAQ;AAC3B,aAAO,SAAS;AAChB,aAAO,cAAc,IAAI;AAAA,IAC7B,OACK;AAED,aAAO,SAAS;AAEhB,aAAO,mBAAmB,IAAI;AAAA,IAClC;AAAA,EACJ,CAAC;AACL;AACA,SAAS,YAAY,MAAM,QAAQ,UAAU;AACzC,QAAM,gBAAgB,iBAAiB,KAAK,OAAO,QAAQ,QAAQ;AACnE,QAAM,QAAQ,CAAC;AACf,gBAAc,QAAQ,CAAC,SAAS;AAC5B,UAAM,OAAO,QAAQ,KAAK,UAAU;AACpC,QAAI,QAAQ,MAAM;AACd;AAAA,IACJ;AACA,UAAM,KAAK,IAAI;AAAA,EACnB,CAAC;AACD,SAAO;AACX;AACA,SAAS,iBAAiB,MAAM,QAAQ,UAAU;AAC9C,QAAM,YAAY,MAAM,KAAK,IAAI;AACjC,MAAI;AAEJ,MAAI,WAAW,IAAI;AACf,cAAU,UAAU,OAAO,CAAC,SAAS,KAAK,SAAS,MAAM;AACzD,WAAO,WAAW,UAAU,CAAC,QAAQ,CAAC,CAAC;AAAA,EAC3C;AACA,QAAM,UAAU,OACX,YAAY,EACZ,MAAM,GAAG,EACT,IAAI,CAACC,YAAW;AACjB,WAAOA,QAAO,MAAM,GAAG,EAAE,IAAI,CAAC,SAAS,KAAK,KAAK,CAAC;AAAA,EACtD,CAAC,EACI,OAAO,CAAC,gBAAgB,YAAY,WAAW,CAAC;AACrD,QAAM,YAAY,CAAC,SAAS;AACxB,QAAI,KAAK,SAAS,QAAQ;AACtB,aAAO;AAAA,IACX;AACA,UAAM,CAAC,UAAU,OAAO,IAAI,KAAK,KAC5B,YAAY,EACZ,MAAM,GAAG,EACT,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC;AACxB,eAAW,CAAC,YAAY,SAAS,KAAK,SAAS;AAE3C,UAAI,aAAa,eACZ,cAAc,OAAO,YAAY,YAAY;AAC9C,eAAO;AAAA,MACX;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACA,YAAU,UAAU,UAAU,OAAO,SAAS;AAC9C,MAAI,aAAa,OAAO;AACpB,cAAU,CAAC,QAAQ,CAAC,CAAC;AAAA,EACzB;AACA,SAAO;AACX;AACA,IAAM,2BAA2B,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,aAAa;AACjE,MAAI,EAAE,MAAM,qBAAqB,kBAAkB,CAAC,MAAM,UAAU,MAAM;AACtE,WAAO;AAAA,EACX;AACA,QAAM,EAAE,KAAK,IAAI,MAAM;AACvB,MAAI,KAAK,SAAS,YAAY,OAAO,MAAM,GAAG;AAC1C,WAAO;AAAA,EACX;AACA,MAAI,UAAU;AACV,aAAS,MAAM,GAAG,cAAc,MAAM,UAAU,MAAM,KAAK,QAAW;AAAA,MAClE,GAAG,KAAK;AAAA,MACR,GAAG;AAAA,IACP,CAAC,CAAC;AAAA,EACN;AACA,SAAO;AACX;AAEA,IAAI,QAAqB,OAAO,OAAO;AAAA,EACnC,WAAW;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AAAA,EACV;AACJ,CAAC;AAED,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,aAAa;AAAA,EACf;AAAA,EACA;AACJ;AACA,IAAM,gBAAgB;AAAA,EAClB,cAAc;AAClB;AACA,IAAM,SAAS;AACf,IAAM,sBAAsB,CAAC,WAAW;AACpC,QAAM,WAAW,OAAO,MAAM,MAAM;AACpC,qBAAmB,UAAU,YAAY,MAAM,YAAY;AAC3D,SAAO;AACX;AACA,SAAS,gBAAgB;AACrB,SAAO;AAAA,IACH,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,MACJ,UAAU,CAAC,EAAE,KAAK,IAAI,GAAG,EAAE,KAAK,KAAK,GAAG,EAAE,OAAO,oBAAoB,CAAC;AAAA,MACtE,OAAO,MAAM,CAAC,MAAM,CAAC;AAAA,IACzB;AAAA,IACA,UAAU;AAAA,MACN,YAAY;AAAA,QACR,MAAM;AAAA,QACN,OAAO;AAAA,QACP,SAAS;AAAA,QACT,0BAA0B;AAAA,MAC9B;AAAA,MACA,eAAe;AAAA,QACX,IAAI,EAAE,MAAM,OAAO;AAAA,MACvB;AAAA,IACJ;AAAA,EACJ;AACJ;AACA,SAAS,iBAAiB,EAAE,cAAc,cAAc,IAAI,CAAC,GAAG;AAC5D,SAAO,CAAC,EAAE,OAAO,MAAM;AACnB,UAAM,OAAO,oBAAoB,MAAM;AACvC,WAAO;AAAA,MACH,cAAgB,cAAc,IAAI;AAAA,MAClC,cAAgB,gBAAgB,IAAI;AAAA,MACpC,cAAc,oCAAoC,IAAI;AAAA,MACtD,cAAc,sCAAsC,IAAI;AAAA,MACxD,eACI,OAAO,aAAa,CAAC,CAAC,YAAY,cAAc,WAAW,IAAI,CAAC,CAAC,CAAC,CAAC;AAAA,IAC3E;AAAA,EACJ;AACJ;AACA,SAAS,eAAe;AACpB,SAAO,CAAC,OAAO,UAAU,UAAU;AAC/B,UAAM,WAAW,MAAM,OAAO,MAAM,MAAM;AAC1C,uBAAmB,UAAU,YAAY,MAAM,YAAY;AAC3D,WAAO,WAAW,QAAQ,EAAE,OAAO,QAAQ;AAAA,EAC/C;AACJ;AACA,SAAS,sBAAsB;AAC3B,SAAO,CAAC,UAAU;AACd,UAAM,WAAW,MAAM,OAAO,MAAM,MAAM;AAC1C,uBAAmB,UAAU,YAAY,MAAM,YAAY;AAC3D,WAAO,wBAAwB,QAAQ,EAAE,KAAK;AAAA,EAClD;AACJ;AAEA,IAAI,SAAsB,OAAO,OAAO;AAAA,EACpC,WAAW;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AAAA,EACV,aAAa;AAAA,EACb;AAAA,EACA;AACJ,CAAC;AAED,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,aAAa;AAAA,EACf;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AACA,IAAM,SAAS;AACf,IAAM,sBAAsB,CAAC,WAAW;AACpC,QAAM,WAAW,OAAO,MAAM,MAAM;AACpC,qBAAmB,UAAU,YAAY,MAAM,YAAY;AAC3D,SAAO;AACX;AACA,SAAS,cAAc,EAAE,cAAc,MAAM,IAAI,CAAC,GAAG;AACjD,SAAO;AAAA,IACH,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,MACJ,OAAO;AAAA,QACH,MAAM;AAAA,UACF,SAAS;AAAA,QACb;AAAA,MACJ;AAAA,MACA,WAAW;AAAA,MACX,UAAU;AAAA,QACN;AAAA,UACI,KAAK;AAAA,UACL,UAAU,CAAC,SAAS;AAAA,YAChB,MAAM,IAAI,aAAa,MAAM;AAAA,UACjC;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,OAAO,CAAC,SAAS;AAAA,QACb;AAAA,QACA;AAAA,UACI,GAAG,KAAK;AAAA,UACR,KAAK;AAAA,QACT;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AAAA,IACA,UAAU;AAAA,MACN,YAAY;AAAA,QACR,KAAK,QAAQ,MAAM,QAAQ,OAAO;AAC9B,iBAAO,WAAW,MAAM,QAAQ,OAAO,CAAC,IAAI,MAAM;AAAA,QACtD;AAAA,QACA,MAAM,OAAO,MAAM,QAAQ,OAAO;AAC9B,iBAAO,WAAW,MAAM,QAAQ,OAAO,EAAE,IACnC,MACA,OACE,MAAM,IAAI,KAAK,MAAM,MAAM,CAAC,KAC3B,KAAK,MAAM,OAAO,IAAI,MAAM,MAAM,KAAK,MAAM,OAAO,CAAC,IAAI,MAC1D;AAAA,QACZ;AAAA,MACJ;AAAA,MACA,eAAe;AAAA,QACX,MAAM;AAAA,UACF,MAAM;AAAA,UACN,UAAU,CAAC,SAAS;AAAA,YAChB,MAAM,IAAI,QAAQ,MAAM;AAAA,YACxB,OAAO,IAAI,QAAQ,OAAO,KAAK;AAAA,UACnC;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,IACA,SAAS;AAAA,MACL;AAAA,IACJ;AAAA,EACJ;AACJ;AACA,SAAS,mBAAmB;AACxB,SAAO,CAAC,EAAE,QAAQ,aAAa,MAAM;AAEjC,UAAM,EAAE,YAAY,IAAI,aAAa,QAAQ,MAAM;AACnD,UAAM,OAAO,oBAAoB,MAAM;AACvC,WAAO;AAAA,MACH,kBAAkB,IAAI;AAAA,MACtB,UAAU,8FAA8F;AAAA,MACxGC,eAAc,gGAAgG,MAAM,CAAC,WAAW,EAAE,MAAM,MAAM,EAAE;AAAA,MAChJ,eACI,IAAI,OAAO;AAAA,QACP,OAAO;AAAA,UACH,aAAa,CAAC,MAAM,MAAM,UAAU;AAChC,kBAAM,EAAE,QAAAC,QAAO,IAAI,KAAK;AACxB,kBAAM,QAAQ,aAAa,KAAK,OAAO,oBAAoBA,OAAM,CAAC;AAClE,gBAAI,MAAM,MAAM,KAAK,MAAM,kBAAkB,mBAAmB;AAC5D,oBAAM,gBAAgB;AACtB,qBAAO,KAAK,MAAM,MAAM,CAAC;AAAA,YAC7B;AACA,mBAAO;AAAA,UACX;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACT;AAAA,EACJ;AACJ;AAGA,IAAM,YAAY;AAClB,SAAS,kBAAkB,MAAM;AAC7B,SAAO,IAAI,UAAU,WAAW,CAAC,OAAO,OAAO,OAAO,QAAQ;AAC1D,QAAI,CAAC,MAAM,CAAC,GAAG;AACX,aAAO;AAAA,IACX;AACA,UAAM,CAAC,GAAG,cAAcH,OAAM,MAAM,IAAI;AACxC,QAAI,CAAC,cAAc;AAIf,UAAI,SAAS;AACb,YAAM,IAAI,aAAa,OAAO,KAAK,CAAC,SAAS;AACzC,YAAI,QAAQ;AACR,iBAAO;AAAA,QACX;AACA,YAAI,KAAK,QAAQ,KAAK,KAAK,GAAG;AAC1B,mBAAS;AACT,iBAAO;AAAA,QACX;AACA,eAAO;AAAA,MACX,CAAC;AACD,UAAI,QAAQ;AACR,eAAO;AAAA,MACX;AAAA,IACJ;AAGA,UAAM,OAAO,SAASA,QAAO,UAAUA,KAAI;AAC3C,UAAM,KAAK,MAAM;AACjB,OAAG;AAAA;AAAA,MAEH,gBAAgB,aAAa,SAAS,IAAI,QAAQ,IAAI;AAAA,MAAO;AAAA,MAAK,KAAK,OAAO,EAAE,KAAW,CAAC;AAAA,IAAC;AAE7F,OAAG,WAAW,KAAK,GAAG;AACtB,WAAO;AAAA,EACX,CAAC;AACL;AACA,SAAS,UAAU,QAAQ;AACvB,SAAO,IAAI,OAAO;AAAA,IACd,OAAO;AAAA,MACH,aAAa,SAAS,iBAAiB,MAAM,UAAU;AACnD,cAAM,QAAQ;AACd,YAAI,CAAC,MAAM,eAAe;AACtB,iBAAO;AAAA,QACX;AACA,YAAIA,QAAO,MAAM,cAAc,QAAQ,YAAY;AACnD,cAAM,OAAO,MAAM,cAAc,QAAQ,WAAW;AACpD,cAAM,cAAcA,SAAQ,CAAC;AAC7B,YAAI,CAAC,eAAe,KAAK,MAAM,UAAU,OAAO;AAC5C,iBAAO;AAAA,QACX;AACA,cAAM,EAAE,OAAO,SAAS,IAAI;AAC5B,cAAM,QAAQ,aAAa,QAAQA,KAAI;AACvC,cAAM,cAAc,MAAM,WAAW,KAAK,MAAM,MAAM,CAAC,MAAM,EAAE,KAAK;AAEpE,YAAI,CAAC,aAAa;AACd,iBAAO;AAAA,QACX;AACA,eAAO,WAAWA,KAAI,EAAE,OAAO,QAAQ;AAAA,MAC3C;AAAA,IACJ;AAAA,EACJ,CAAC;AACL;AACA,SAASE,eAAc,QAAQ,MAAM,UAAU;AAC3C,SAAO,IAAI,OAAO;AAAA,IACd,OAAO;AAAA,MACH,iBAAiB,SAAS,gBAAgB,OAAO;AAC7C,eAAO,SAAS,OAAO,CAAC,SAAS;AAC7B,cAAI,CAAC,KAAK,QAAQ;AACd,mBAAO;AAAA,UACX;AACA,gBAAMF,QAAO,KAAK;AAClB,gBAAM,UAAU,aAAa,QAAQA,KAAI;AACzC,iBAAO,QAAQ,IAAI,CAAC,EAAE,OAAO,KAAK,OAAO,UAAU,MAAM;AACrD,gBAAI,UAAU,KAAK,IAAI,OAAO,GAAG;AACjC,gBAAI,OAAO;AACP,kBAAI,QAAQ,oBAAoB,WAAW,SAAS,SAAS,IAAI;AACjE,wBAAU,QAAQ,KAAK,KAAK,OAAO,KAAK,EAAE,SAAS,KAAK,KAAK,CAAC;AAAA,YAClE;AACA,mBAAO;AAAA,UACX,CAAC;AAAA,QACL,CAAC;AAAA,MACL;AAAA,IACJ;AAAA,EACJ,CAAC;AACL;AACA,SAAS,WAAWI,OAAM,QAAQ,OAAO,MAAM;AAC3C,MAAIA,MAAK,MAAM,OAAO,KAAK,CAAC,QAAQ,KAAKA,MAAK,MAAM,MAAM,CAAC,GAAG;AAC1D,WAAO;AAAA,EACX;AACA,MAAI,UAAU,OAAO,MAAM,SAAS,OAAO,IAAI,KAAK,EAAE;AACtD,MAAI,CAAC,QAAQ,UACT,QAAQ,SAASA,MAAK,MAAM,MAAM,KAClC,QAAQ,MAAM,QAAQ,MAAM,SAAS,CAAC,MAAMA,OAAM;AAClD,WAAO;AAAA,EACX;AACA,MAAI,WAAW,OAAO,IAAI,IAAI,OAAO,aAAa,IAAI;AAClD,WAAO;AAAA,EACX;AACA,MAAI,OAAO,OAAO,MAAM,SAAS,OAAO,IAAI,KAAK,EAAE;AACnD,SAAO,CAACA,MAAK,QAAQ,KAAK,KAAK;AACnC;AACA,SAAS,YAAY,KAAK;AACtB,SAAO,CAAC,UAAU;AACd,UAAM,OAAO,MAAM,IAAI,OAAO,GAAG;AACjC,WAAO,CAAC,CAAC,QAAQ,KAAK;AAAA,EAC1B;AACJ;AACA,SAAS,QAAQ,MAAM,IAAI,MAAM;AAC7B,SAAO,QAAQ,KAAK,KAAK;AACzB,SAAO,OAAO,CAAC,UAAU,YAAY,IAAI,EAAE,KAAK,GAAG,CAAC,OAAO,aAAa;AACpE,UAAM,WAAW,oBAAoB,MAAM,MAAM;AACjD,QAAI,KAAK,MAAM,GAAG,WAAW,MAAM,IAAI,QAAQ;AAC/C,QAAI,MAAM;AACN,YAAM,OAAO,oBAAoB,MAAM,MAAM,EAAE,OAAO;AAAA,QAClD;AAAA,MACJ,CAAC;AACD,SAAG,QAAQ,MAAM,IAAI,IAAI;AAAA,IAC7B;AACA,QAAI,UAAU;AACV,eAAS,EAAE;AAAA,IACf;AACA,WAAO;AAAA,EACX,CAAC;AACL;AAUA,SAAS,WAAW,MAAM;AACtB,SAAO,OAAO,CAAC,UAAU,0BAA0B,MAAM,UAAU,MAAM,KAAK,MAAM,UAAU,IAAI,GAAG,EAAE,KAAK,GAAG,CAAC,OAAO,aAAa;AAChI,UAAM,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,UAAU,MAAM,KAAK,MAAM,UAAU,IAAI,GAAG;AACtE,UAAM,WAAW,oBAAoB,MAAM,MAAM;AACjD,QAAI,KAAK,MAAM,GAAG,WAAW,MAAM,IAAI,QAAQ;AAC/C,QAAI,KAAK,KAAK,GAAG;AACb,YAAM,OAAO,oBAAoB,MAAM,MAAM,EAAE,OAAO;AAAA,QAClD;AAAA,MACJ,CAAC;AACD,SAAG,QAAQ,MAAM,IAAI,IAAI;AAAA,IAC7B;AACA,QAAI,UAAU;AACV,eAAS,EAAE;AAAA,IACf;AACA,WAAO;AAAA,EACX,CAAC;AACL;AACA,SAAS,WAAW,MAAM;AACtB,SAAO,CAAC,OAAO,aAAa;AACxB,QAAI,CAAC,MAAM,UAAU,OAAO;AACxB,aAAO,QAAQ,MAAM,UAAU,MAAM,KAAK,MAAM,UAAU,IAAI,KAAK,IAAI,EAAE,OAAO,QAAQ;AAAA,IAC5F;AACA,UAAM,EAAE,MAAM,IAAI,MAAM;AACxB,UAAM,MAAM,MAAM,MAAM,MAAM;AAC9B,UAAM,OAAO,MAAM,IAAI,OAAO,GAAG;AACjC,QAAI,KAAK;AACT,QAAI,MAAM;AACN,YAAM,KAAK;AAAA,IACf;AACA,WAAO,QAAQ,KAAK,IAAI,IAAI,EAAE,OAAO,QAAQ;AAAA,EACjD;AACJ;AACA,SAAS,iBAAiB;AACtB,SAAO,CAAC,UAAU;AACd,UAAM,EAAE,MAAM,IAAI,MAAM;AACxB,UAAM,MAAM,MAAM,MAAM,MAAM;AAC9B,UAAM,OAAO,MAAM,IAAI,QAAQ,GAAG;AAClC,UAAM,OAAO,MAAM,IAAI,OAAO,GAAG;AACjC,UAAM,EAAE,UAAU,IAAI;AACtB,QAAI,CAAC,WAAW;AACZ,aAAO;AAAA,IACX;AACA,UAAM,OAAO,oBAAoB,MAAM,MAAM;AAC7C,UAAM,OAAO,KAAK,QAAQ,UAAU,SAAS,CAAC,CAAC;AAC/C,QAAI,MAAM;AACN,aAAO;AAAA,QACH,MAAM,KAAK,MAAM,MAAM;AAAA,QACvB,MAAM,KAAK;AAAA,MACf;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACJ;AACA,SAAS,0BAA0B,MAAM,IAAI;AACzC,SAAO,CAAC,UAAU;AACd,UAAM,QAAQ,MAAM,IAAI,QAAQ,IAAI;AACpC,UAAM,MAAM,MAAM,IAAI,QAAQ,EAAE;AAChC,UAAMA,QAAO,oBAAoB,MAAM,MAAM;AAC7C,QAAI,MAAM,WAAW,IAAI,UAAU,MAAM,OAAO,aAAa;AACzD,aAAO,MAAM,OAAO,KAAK,eAAeA,KAAI;AAAA,IAChD;AACA,WAAO;AAAA,EACX;AACJ;AACA,SAAS,oBAAoB;AACzB,SAAO,CAAC,UAAU,QAAQ,oBAAoB,MAAM,MAAM,EAAE,QAAQ,MAAM,UAAU,MAAM,MAAM,CAAC,CAAC;AACtG;AACA,SAAS,6BAA6B;AAClC,SAAO,CAAC,UAAU;AACd,UAAM,EAAE,OAAO,IAAI,IAAI,MAAM;AAC7B,UAAM,OAAO,MAAM;AACnB,WAAQ,CAAC,CAAC,QACN,MAAM,eAAe,KACrB,IAAI,MAAM,MAAM,QAAQ,KAAK,YAC7B,QAAQ,oBAAoB,MAAM,MAAM,EAAE,QAAQ,KAAK,KAAK,CAAC;AAAA,EACrE;AACJ;AAEA,IAAI,OAAoB,OAAO,OAAO;AAAA,EAClC,WAAW;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AAAA,EACV;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ,CAAC;AAED,IAAI,MAAM,MAAM;AAAE;AAClB,SAAS,uBAAuBC,OAAM;AAClC,QAAM,wBAAwB,CAAC,OAAO,QAAQ;AAC1C,QAAI,QAAQ,QAAW;AACnB,aAAO;AAAA,IACX;AACA,WAAO,MAAM,IAAI,QAAQ,GAAG,EAAE,OAAO,KAAK,SAAS;AAAA,EACvD;AACA,QAAM,iBAAiB,CAAC,aAAa;AAEjC,QAAI,CAAC,SAAS,aAAa,aAAa,qBAAqB,GAAG;AAC5D;AAAA,IACJ;AACA,aAAS,aAAa,gBAAgB,qBAAqB;AAC3D,aAAS,aAAa,YAAY,SAAS,aAAa,UAAU;AAAA,EACtE;AACA,QAAM,gBAAgB,CAAC,OAAO,aAAa,aAAa;AAEpD,QAAI,SAAS,aAAa,aAAa,qBAAqB,GAAG;AAC3D;AAAA,IACJ;AACA,UAAM,WAAW,eAAe,MAAM,aAAa,GAAG,CAAC,aAAa;AAChE,kBAAY;AAAA;AAAA;AAAA,QAGR,aAAa;AAAA,MACjB,CAAC;AAAA,IACL,CAAC;AACD,aAAS,aAAa,aAAa,uBAAuB,EAAE;AAC5D,aAAS,aAAa,QAAQ,QAAQ;AAAA,EAC1C;AACA,QAAM,iBAAiB,CAAC,aAAa,aAAa;AAC9C,UAAM,WAAW,cAAc;AAAA,MAC3B;AAAA;AAAA,MAEA,EAAE,iBAAiB,MAAM;AAAA,MACzB;AAAA,QACI;AAAA,QACA;AAAA,UACI,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ,CAAC;AACD,UAAM,eAAe,SAAS,cAAc,OAAO;AACnD,QAAI,aAAa;AACb,mBAAa,aAAa,WAAW,EAAE;AAAA,IAC3C;AACA,iBAAa,iBAAiB,SAAS,CAAC,WAAW;AAC/C,UAAI,gBAAgB,aAAa,OAAO;AACxC;AAAA;AAAA,QAEA,aAAa;AAAA,MAAO;AAAA,IACxB,CAAC;AACD,WAAO;AAAA,EACX;AACA,SAAO,SAAS,aAAa;AAAA,IACzB,MAAAA;AAAA,IACA,cAAc;AAAA,MACV;AAAA,MACA;AAAA;AAAA,QAEI,oBAAoBA;AAAA,MACxB;AAAA,IACJ;AAAA,IACA,YAAY,CAAC,QAAQ,CAAC,CAAC;AAAA,IACvB,gBAAgB;AAAA,MACZ,QAAQ,CAAC,UAAU,EAAE,OAAO,aAAa,QAAQ,KAAK,MAAM;AACxD,cAAM,cAAc,MAAM,aAAa;AAEvC,YAAI,eAAe,MAAM;AAErB,cAAI,sBAAsB,KAAK,OAAO,OAAO,CAAC,GAAG;AAC7C,0BAAc,OAAO,aAAa,QAAQ;AAAA,UAC9C;AAAA,QACJ;AAEA,iBAAS,aAAa,YAAY,SAAS,UAAU;AAAA,MACzD;AAAA;AAAA;AAAA;AAAA,MAIA,QAAQ,CAAC,UAAU,EAAE,OAAO,MAAM,QAAQ,YAAY,MAAM;AACxD,cAAM,EAAE,YAAY,IAAI;AACxB,YAAI,eAAe,MAAM;AACrB,yBAAe,QAAQ;AACvB;AAAA,QACJ;AAEA,YAAI,CAAC,sBAAsB,KAAK,OAAO,OAAO,CAAC,GAAG;AAC9C;AAAA,QACJ;AAMA,sBAAc,OAAO,aAAa,QAAQ;AAC1C,cAAM,WAAW,SAAS,aAAa,WAClC;AACL,iBAAS,UAAU;AAAA,MACvB;AAAA,MACA,SAAS,MAAM;AAAA,MAAE;AAAA,IACrB;AAAA,EACJ,CAAC;AACL;AAEA,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,aAAa;AAAA,EACf;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AACA,IAAM,gBAAgB;AAAA,EAClB,YAAY,QAAQ,MAAM,eAAe;AAAA,EACzC,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,WAAW;AAAA,EACX,UAAU;AAAA,EACV,sBAAsB;AAAA,EACtB,sBAAsB;AAC1B;AACA,IAAM,SAAS;AACf,IAAM,cAAc,CAAC,UAAU;AAC3B,QAAM,OAAO,YAAY,OAAO,MAAM;AACtC,SAAO,4BAA4B,MAAM;AAAA,IACrC,YAAY,OAAO,YAAY;AAAA,IAC/B,YAAY,OAAO,aAAa;AAAA,EACpC,CAAC;AACL;AACA,SAAS,gBAAgB;AACrB,QAAM,EAAE,OAAO,SAAS,IAAI,wBAAwB,QAAQ;AAAA,IACxD,KAAK;AAAA;AAAA,IAEL,SAAS;AAAA,EACb,CAAC;AACD,SAAO;AAAA,IACH,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,MACJ,SAAS;AAAA,MACT,UAAU;AAAA,MACV,WAAW;AAAA,MACX,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAOH,aAAa;AAAA,UACT,SAAS;AAAA,QACb;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA,IACA,UAAU;AAAA,MACN,WAAW,OAAO,MAAM;AACpB,YAAI,KAAK,MAAM,aAAa,KAAK,MAAM;AACnC,gBAAM,MAAM,KAAK,MAAM,aAAa,IAAI,SAAS,MAAM;AAAA,QAC3D;AACA,cAAM,cAAc,IAAI;AAAA,MAC5B;AAAA,MACA,eAAe;AAAA,QACX,WAAW;AAAA,UACP,OAAO;AAAA,UACP,UAAU,CAAC,QAAQ;AACf,gBAAI,cAAc;AAClB,kBAAM,aAAa,IAAI,QAAQ,QAAQ;AACvC,gBAAI,eAAe,OAAO;AACtB,4BAAc;AAAA,YAClB,WACS,eAAe,MAAM;AAC1B,4BAAc;AAAA,YAClB;AACA,mBAAO;AAAA,cACH;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;AACA,SAAS,iBAAiB,EAAE,cAAc,eAAe,WAAW,KAAM,IAAI,CAAC,GAAG;AAC9E,SAAO,CAAC,EAAE,OAAO,MAAM;AACnB,UAAM,OAAO,YAAY,QAAQ,MAAM;AACvC,WAAO;AAAA,MACH,eACI,OAAO;AAAA,QACH,CAAC,YAAY,UAAU,GAAG,OAAO,aAAa,gBAAgB,YAAY,QAAQ,UAAU,GAAG,CAAC,WAAW;AAAA,UACvG,GAAG;AAAA,UACH,aAAa,MAAM,aAAa,KAAK,OAAO,QAAQ,CAAC,MAAM,aAAa;AAAA,QAC5E,EAAE,CAAC;AAAA,QACH,WAAW,oBAAoB,IAAI;AAAA,QACnC,OAAO,gBAAgB,IAAI;AAAA,QAC3B,GAAG,aAAa;AAAA,UACZ,CAAC,YAAY,QAAQ,eAAe,CAAC;AAAA,UACrC,CAAC,YAAY,SAAS,gBAAgB,CAAC;AAAA,UACvC,CAAC,YAAY,QAAQ,eAAe,CAAC;AAAA,UACrC,CAAC,YAAY,UAAU,iBAAiB,CAAC;AAAA,UACzC,CAAC,YAAY,UAAU,OAAO,aAAa,gBAAgB,IAAI,CAAC,CAAC;AAAA,UACjE;AAAA,YACI,YAAY;AAAA,YACZ,OAAO,aAAa,iBAAiB,IAAI,CAAC;AAAA,UAC9C;AAAA,UACA,CAAC,YAAY,sBAAsB,4BAA4B,CAAC;AAAA,UAChE,CAAC,YAAY,sBAAsB,4BAA4B,CAAC;AAAA,QACpE,CAAC;AAAA,MACL,CAAC;AAAA,MACL,YAAY,uBAAuB,MAAM;AAAA,IAC7C;AAAA,EACJ;AACJ;AACA,SAAS,iBAAiB;AACtB,SAAO,CAAC,OAAO,aAAa;AACxB,UAAM,OAAO,YAAY,OAAO,MAAM;AACtC,WAAO,WAAW,IAAI,EAAE,OAAO,QAAQ;AAAA,EAC3C;AACJ;AACA,SAAS,kBAAkB;AACvB,SAAO,CAAC,OAAO,UAAU,SAAS;AAC9B,UAAM,OAAO,YAAY,OAAO,MAAM;AACtC,WAAO,YAAY,IAAI,EAAE,OAAO,UAAU,IAAI;AAAA,EAClD;AACJ;AACA,IAAM,wBAAwB,CAAC,UAAU;AACrC,SAAO,WAAW,MAAM,UAAU,MAAM,KAAK,EAAE,GAAG,MAAM,MAAM;AAClE;AACA,SAAS,aAAa,KAAK;AACvB,SAAO,CAAC,OAAO,UAAU,SAAS;AAC9B,UAAM,OAAO,YAAY,OAAO,MAAM;AACtC,UAAM,eAAe,4BAA4B,MAAM;AAAA,MACnD,YAAY,OAAO,YAAY;AAAA,MAC/B,YAAY,OAAO,aAAa;AAAA,IACpC,CAAC;AACD,UAAM,OAAO,CAACC,SAAQ,cAAc,SAAS,MAAMA,IAAG,GAAG,CAACC,QAAOC,WAAUC,UAAS;AAChF,YAAM,OAAOF,OAAM,UAAU,MAAM,KAAK,EAAE;AAC1C,YAAM,eAAe,WAAW,MAAMA,OAAM,MAAM;AAClD,YAAM,SAAS,iBAAiB,MAAMD,IAAG,EAAEC,QAAOC,WAAUC,KAAI;AAChE,UAAI,CAAC,QAAQ;AACT,eAAO;AAAA,MACX;AAGA,UAAI,gBAAgBD,WAAU;AAC1B,cAAMD,SAAQE,MAAK;AACnB,YAAI,EAAE,IAAI,OAAO,IAAIF;AACrB,aAAK,mBAAmB,IAAI,QAAQA,OAAM,UAAU,MAAM,KAAK,EAAE,GAAGA,OAAM,UAAU,MAAM,OAAO,EAAE,CAAC;AACpG,QAAAC,UAAS,EAAE;AAAA,MACf;AACA,aAAO;AAAA,IACX,CAAC;AACD,WAAO,OAAO,cAAc,KAAK,GAAG,CAAC,EAAE,OAAO,UAAU,IAAI;AAAA,EAChE;AACJ;AACA,SAAS,iBAAiB;AACtB,SAAO,aAAa,IAAI;AAC5B;AACA,SAAS,mBAAmB;AACxB,SAAO,aAAa,MAAM;AAC9B;AACA,SAAS,uBAAuB,UAAU,MAAM;AAC5C,SAAO,CAAC,OAAO,UAAU,SAAS;AAC9B,UAAM,OAAO,YAAY,OAAO,MAAM;AACtC,WAAO,cAAc,OAAO,uBAAuB,YAAY,MAAM,UAAU,UAAU,SAAS,MAAM;AAAA,MACpG,aAAa;AAAA,IACjB,CAAC,CAAC,GAAG,OAAO,aAAa,YAAY,MAAM,UAAU,UAAU,SAAS,IAAI,CAAC,CAAC,EAAE,OAAO,UAAU,IAAI;AAAA,EACzG;AACJ;AACA,SAAS,8BAA8B;AACnC,SAAO,uBAAuB,IAAI;AACtC;AACA,SAAS,8BAA8B;AACnC,SAAO,uBAAuB,KAAK;AACvC;AAEA,IAAI,oBAAiC,OAAO,OAAO;AAAA,EAC/C,WAAW;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AAAA,EACV,aAAa;AAAA,EACb;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ,CAAC;AAED,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,aAAa;AAAA,EACf;AAAA,EACA;AACJ;AACA,IAAM,gBAAgB;AAAA,EAClB,QAAQ;AACZ;AACA,IAAM,SAAS;AACf,SAAS,gBAAgB;AACrB,SAAO;AAAA,IACH,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,MACJ,OAAO;AAAA,QACH,OAAO;AAAA,UACH,SAAS;AAAA,QACb;AAAA;AAAA;AAAA;AAAA;AAAA,QAKA,OAAO;AAAA,UACH,SAAS;AAAA,QACb;AAAA,MACJ;AAAA,MACA,SAAS;AAAA,MACT,OAAO;AAAA,MACP,UAAU;AAAA,QACN;AAAA,UACI,KAAK;AAAA,UACL,UAAU,CAAC,SAAS;AAAA,YAChB,OAAO,IAAI,aAAa,OAAO,IAAI,CAAC,IAAI,aAAa,OAAO,IAAI;AAAA,UACpE;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,OAAO,CAAC,SAAS,KAAK,MAAM,OAAO,MAAM,IACnC,CAAC,MAAM,CAAC,IACR,CAAC,MAAM,EAAE,OAAO,KAAK,MAAM,OAAO,EAAE,GAAG,CAAC;AAAA,IAClD;AAAA,IACA,UAAU;AAAA,MACN,WAAW,OAAO,MAAM;AACpB,YAAI,QAAQ,KAAK,MAAM,OAAO,KAAK;AACnC,YAAI,OAAO,OAAO,QAAQ,KAAK,aAAa,CAAC,EAAE;AAC/C,YAAI,QAAQ,MAAM,OAAO,KAAK,OAAO,CAAC;AACtC,cAAM,WAAW,MAAM,OAAO,CAAC,MAAM;AACjC,cAAI,OAAO,OAAO,QAAQ,CAAC;AAC3B,iBAAO,MAAM,OAAO,KAAK,OAAO,KAAK,MAAM,IAAI,OAAO;AAAA,QAC1D,CAAC;AAAA,MACL;AAAA,MACA,eAAe;AAAA,QACX,cAAc;AAAA,UACV,OAAO;AAAA,UACP,UAAU,CAAC,KAAK,QAAQ,MAAM;AAC1B,gBAAI;AACJ,mBAAO;AAAA,cACH,OAAO,YAAY,QAAQ,CAAC;AAAA,cAC5B,OAAO,GAAG,KAAK,IAAI,QAAQ,OAAO,OAAO,QAAQ,OAAO,SAAS,KAAK;AAAA,YAC1E;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;AACA,SAAS,iBAAiB,EAAE,cAAc,cAAc,IAAI,CAAC,GAAG;AAC5D,SAAO,CAAC,EAAE,OAAO,MAAM;AACnB,UAAM,OAAO,YAAY,QAAQ,MAAM;AACvC,WAAO;AAAA,MACH,kBAAkB,eAAe,MAAM,CAAC,WAAW,EAAE,OAAO,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,OAAO,SAAS,KAAK,aAAa,KAAK,MAAM,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC;AAAA,MAC9I,eACI,OAAO,aAAa,CAAC,CAAC,YAAY,QAAQ,WAAW,IAAI,CAAC,CAAC,CAAC,CAAC;AAAA,IACrE;AAAA,EACJ;AACJ;AACA,SAAS,oBAAoB;AACzB,SAAO,CAAC,OAAO,UAAU,SAAS;AAC9B,WAAO,WAAW,YAAY,OAAO,MAAM,GAAG,YAAY,OAAO,UAAU,CAAC,EAAE,OAAO,UAAU,IAAI;AAAA,EACvG;AACJ;AACA,SAAS,2BAA2B;AAChC,SAAO,CAAC,UAAU;AACd,WAAO,4BAA4B,YAAY,OAAO,UAAU,GAAG;AAAA,MAC/D,YAAY,OAAO,MAAM;AAAA,IAC7B,CAAC,EAAE,KAAK;AAAA,EACZ;AACJ;AAEA,IAAI,cAA2B,OAAO,OAAO;AAAA,EACzC,WAAW;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AAAA,EACV,aAAa;AAAA,EACb;AAAA,EACA;AACJ,CAAC;AAED,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,aAAa;AAAA,EACf;AAAA,EACA;AACJ;AACA,IAAM,gBAAgB;AAAA,EAClB,cAAc;AAClB;AACA,IAAM,SAAS;AACf,IAAM,sBAAsB,CAAC,WAAW;AACpC,QAAM,WAAW,OAAO,MAAM,MAAM;AACpC,qBAAmB,UAAU,YAAY,MAAM,YAAY;AAC3D,SAAO;AACX;AACA,SAAS,gBAAgB;AACrB,SAAO;AAAA,IACH,MAAM;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,MACJ,UAAU;AAAA,QACN;AAAA,UACI,KAAK;AAAA,QACT;AAAA,QACA;AAAA,UACI,KAAK;AAAA,QACT;AAAA,QACA;AAAA,UACI,KAAK;AAAA,QACT;AAAA,QACA;AAAA,UACI,OAAO;AAAA,UACP,UAAU,CAAC,UAAU,UAAU,kBAAkB;AAAA,QACrD;AAAA,MACJ;AAAA,MACA,OAAO,MAAM,CAAC,KAAK,CAAC;AAAA,IACxB;AAAA,IACA,UAAU;AAAA,MACN,YAAY;AAAA,QACR,MAAM;AAAA,QACN,OAAO;AAAA,QACP,SAAS;AAAA,QACT,0BAA0B;AAAA,MAC9B;AAAA,MACA,eAAe;AAAA,QACX,GAAG,EAAE,MAAM,SAAS;AAAA,MACxB;AAAA,IACJ;AAAA,EACJ;AACJ;AACA,SAAS,iBAAiB,EAAE,cAAc,cAAc,IAAI,CAAC,GAAG;AAC5D,SAAO,CAAC,EAAE,OAAO,MAAM;AACnB,UAAM,OAAO,oBAAoB,MAAM;AACvC,WAAO;AAAA,MACH,cAAgB,sCAAsC,IAAI;AAAA,MAC1D,cAAc,sCAAsC,IAAI;AAAA,MACxD,eACI,OAAO,aAAa,CAAC,CAAC,YAAY,cAAc,WAAW,IAAI,CAAC,CAAC,CAAC,CAAC;AAAA,IAC3E;AAAA,EACJ;AACJ;AACA,SAAS,eAAe;AACpB,SAAO,CAAC,OAAO,UAAU,UAAU;AAC/B,UAAM,WAAW,MAAM,OAAO,MAAM,MAAM;AAC1C,uBAAmB,UAAU,YAAY,MAAM,YAAY;AAC3D,WAAO,WAAW,QAAQ,EAAE,OAAO,QAAQ;AAAA,EAC/C;AACJ;AACA,SAAS,sBAAsB;AAC3B,SAAO,CAAC,UAAU;AACd,UAAM,WAAW,MAAM,OAAO,MAAM,MAAM;AAC1C,uBAAmB,UAAU,YAAY,MAAM,YAAY;AAC3D,WAAO,wBAAwB,QAAQ,EAAE,KAAK;AAAA,EAClD;AACJ;AAEA,IAAI,SAAsB,OAAO,OAAO;AAAA,EACpC,WAAW;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,EACT,UAAU;AAAA,EACV,aAAa;AAAA,EACb;AAAA,EACA;AACJ,CAAC;AAED,IAAM,OAAO;AACb,IAAM,UAAU;AAChB,IAAM,WAAW;AAAA,EACb;AAAA,EACA;AACJ;AACA,IAAM,cAAc;AAAA,EAChB,iBAAiB;AACrB;AACA,IAAM,OAAO;AACb,IAAM,oBAAoB,CAAC,WAAW;AAClC,QAAM,WAAW,OAAO,MAAM,IAAI;AAClC,qBAAmB,UAAU,YAAY,IAAI,YAAY;AACzD,SAAO;AACX;AACA,SAAS,cAAc;AACnB,SAAO;AAAA,IACH,MAAM;AAAA,IACN;AAAA,IACA,QAAQ;AAAA,MACJ,UAAU;AAAA,QACN;AAAA,UACI,KAAK;AAAA,QACT;AAAA,QACA;AAAA,UACI,OAAO;AAAA,UACP,UAAU,CAAC,UAAU,UAAU,QAAQ;AAAA,QAC3C;AAAA,MACJ;AAAA,MACA,OAAO,MAAM,CAAC,KAAK,CAAC;AAAA,IACxB;AAAA,IACA,UAAU;AAAA;AAAA;AAAA;AAAA,MAIN,YAAY;AAAA,QACR,MAAM;AAAA,QACN,OAAO;AAAA,QACP,SAAS;AAAA,QACT,0BAA0B;AAAA,MAC9B;AAAA,IACJ;AAAA,EACJ;AACJ;AACA,SAAS,eAAe,EAAE,cAAc,YAAY,IAAI,CAAC,GAAG;AACxD,SAAO,CAAC,EAAE,OAAO,MAAM;AACnB,UAAM,OAAO,kBAAkB,MAAM;AACrC,WAAO;AAAA,MACH,cAAc,cAAc,IAAI;AAAA,MAChC,cAAgB,cAAc,IAAI;AAAA,MAClC,cACM,OAAO,aAAa,CAAC,CAAC,YAAY,iBAAiB,WAAW,IAAI,CAAC,CAAC,CAAC,CAAC,IACtE;AAAA,IACV;AAAA,EACJ;AACJ;AACA,SAAS,kBAAkB;AACvB,SAAO,CAAC,OAAO,UAAU,UAAU;AAC/B,UAAM,WAAW,MAAM,OAAO,MAAM,IAAI;AACxC,uBAAmB,UAAU,YAAY,IAAI,YAAY;AACzD,WAAO,WAAW,QAAQ,EAAE,OAAO,QAAQ;AAAA,EAC/C;AACJ;AACA,SAAS,yBAAyB;AAC9B,SAAO,CAAC,UAAU;AACd,UAAM,WAAW,MAAM,OAAO,MAAM,IAAI;AACxC,uBAAmB,UAAU,YAAY,IAAI,YAAY;AACzD,WAAO,wBAAwB,QAAQ,EAAE,KAAK;AAAA,EAClD;AACJ;AAEA,IAAI,YAAyB,OAAO,OAAO;AAAA,EACvC,WAAW;AAAA,EACX;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ,CAAC;",
  "names": ["liftListItem", "rootListDepth", "paragraph", "bulletList", "orderedList", "wrapInList", "doc", "codeBlock", "node", "heading", "code", "text", "accept", "markPasteRule", "schema", "link", "name", "dir", "state", "dispatch", "view"]
}
