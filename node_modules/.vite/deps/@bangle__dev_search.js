import {
  matchAllPlus
} from "./chunk-F3Z2TPKG.js";
import {
  Decoration,
  DecorationSet,
  Plugin,
  PluginKey
} from "./chunk-ZRMAPHIN.js";
import "./chunk-NVKSN2QT.js";
import "./chunk-AUZ3RYOM.js";

// .yarn/__virtual__/@bangle.dev-search-virtual-b6198a2ffb/5/Users/ted/.yarn/berry/cache/@bangle.dev-search-npm-0.32.0-92629819ea-10c0.zip/node_modules/@bangle.dev/search/dist/index.js
var name = "search";
var plugins = pluginsFactory;
function pluginsFactory({ key = new PluginKey(name), query: initialQuery, className = "bangle-search-match", maxHighlights = 1500 }) {
  function buildDeco(state, query) {
    if (!query) {
      return DecorationSet.empty;
    }
    const matches = findMatches(state.doc, query, maxHighlights);
    const decorations = matches.map((match) => {
      return Decoration.inline(match.pos + match.match.start, match.pos + match.match.end, {
        class: className
      });
    });
    return DecorationSet.create(state.doc, decorations);
  }
  return () => new Plugin({
    key,
    state: {
      init(_, state) {
        return {
          query: initialQuery,
          decos: buildDeco(state, initialQuery)
        };
      },
      apply(tr, old, oldState, newState) {
        const meta = tr.getMeta(key);
        if (meta) {
          const newQuery = meta.query;
          return {
            query: newQuery,
            decos: buildDeco(newState, newQuery)
          };
        }
        return tr.docChanged ? {
          query: old.query,
          decos: buildDeco(newState, old.query)
        } : old;
      }
    },
    props: {
      decorations(state) {
        var _a;
        return ((_a = key.getState(state)) === null || _a === void 0 ? void 0 : _a.decos) || null;
      }
    }
  });
}
function findMatches(doc, regex, maxHighlights) {
  let results = [];
  let count = 0;
  let gRegex;
  if (regex instanceof RegExp) {
    let flags = "g";
    if (regex.ignoreCase) {
      flags += "i";
    }
    if (regex.multiline) {
      flags += "m";
    }
    gRegex = RegExp(regex.source, flags);
  } else {
    gRegex = RegExp(regex, "g");
  }
  doc.descendants((node, pos) => {
    if (maxHighlights <= count) {
      return false;
    }
    if (node.isText) {
      const source = node.textContent;
      const matchedResult = matchAllPlus(gRegex, source);
      for (const match of matchedResult) {
        if (!match.match) {
          continue;
        }
        if (maxHighlights <= count++) {
          break;
        }
        results.push({
          pos,
          match
        });
      }
    }
    return;
  });
  return results;
}
function updateSearchQuery(key, query) {
  return (state, dispatch, _view) => {
    if (dispatch) {
      dispatch(state.tr.setMeta(key, { query }).setMeta("addToHistory", false));
    }
    return true;
  };
}
var search = Object.freeze({
  __proto__: null,
  plugins,
  updateSearchQuery
});
export {
  search
};
//# sourceMappingURL=@bangle__dev_search.js.map
