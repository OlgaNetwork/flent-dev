// ../../../../Users/ted/.yarn/berry/cache/@bangle.dev-collab-comms-npm-0.32.0-ee1eba97bf-10c0.zip/node_modules/@bangle.dev/collab-comms/dist/index.js
var MessageType;
(function(MessageType2) {
  MessageType2["PING"] = "PING";
  MessageType2["PONG"] = "PONG";
  MessageType2["BROADCAST"] = "BROADCAST";
})(MessageType || (MessageType = {}));
var CollabMessageBus = class _CollabMessageBus {
  constructor(_opts = {}) {
    this._opts = _opts;
    this._destroyed = false;
    this._listeners = /* @__PURE__ */ new Map();
    this._seenMessages = /* @__PURE__ */ new WeakSet();
  }
  destroy(name) {
    if (name == null) {
      this._listeners.clear();
    } else {
      this._listeners.delete(name);
    }
    this._destroyed = true;
  }
  // if name is WILD_CARD, then it will receive every message irrespective of the `to` field.
  receiveMessages(name, callback) {
    if (this._destroyed) {
      return () => {
      };
    }
    let listeners = this._listeners.get(name);
    if (!listeners) {
      listeners = /* @__PURE__ */ new Set();
      this._listeners.set(name, listeners);
    }
    listeners.add(callback);
    return () => {
      const listeners2 = this._listeners.get(name);
      listeners2 === null || listeners2 === void 0 ? void 0 : listeners2.delete(callback);
      if ((listeners2 === null || listeners2 === void 0 ? void 0 : listeners2.size) === 0) {
        this._listeners.delete(name);
      }
    };
  }
  // receive messages that specify the give `name` in the `to` field.
  transmit(message) {
    var _a, _b;
    if (this._seenMessages.has(message)) {
      return;
    }
    if (((_b = (_a = this._opts).debugFilterMessage) === null || _b === void 0 ? void 0 : _b.call(_a, message)) === false) {
      return;
    }
    this._seenMessages.add(message);
    if (message.type === MessageType.BROADCAST && message.to != null) {
      throw new Error("Broadcast message must not have a `to` field");
    }
    if (typeof message.to !== "string" && // @ts-expect-error
    (message.type === MessageType.PING || message.type === MessageType.PONG)) {
      throw new Error("PING/PONG message must have a `to` field");
    }
    const _transmit = () => {
      var _a2;
      let targetListeners = message.to ? this._listeners.get(message.to) || /* @__PURE__ */ new Set() : (
        // if there is no `to` field, then it is a broadcast to all.
        // Using a set to prevent duplicates firing of broadcast if same listener is attached
        // to multiple `to`s.
        new Set([...this._listeners.values()].flatMap((r) => [...r]))
      );
      let wildcardListeners = this._listeners.get(_CollabMessageBus.WILD_CARD) || /* @__PURE__ */ new Set();
      (_a2 = /* @__PURE__ */ new Set([...wildcardListeners, ...targetListeners])) === null || _a2 === void 0 ? void 0 : _a2.forEach((listener) => {
        listener(message);
      });
    };
    if (this._opts.debugSlowdown == null) {
      _transmit();
    } else {
      setTimeout(_transmit, this._opts.debugSlowdown);
    }
  }
};
CollabMessageBus.WILD_CARD = Symbol("WILD_CARD");
var DEFAULT_MANAGER_ID = "@bangle.dev/collab-manager/MANAGER";
var NetworkingError;
(function(NetworkingError2) {
  NetworkingError2["Timeout"] = "NetworkingError.Timeout";
})(NetworkingError || (NetworkingError = {}));
var CollabManagerBroadCastType;
(function(CollabManagerBroadCastType2) {
  CollabManagerBroadCastType2["NewVersion"] = "CollabManagerBroadCastType.NewVersion";
  CollabManagerBroadCastType2["ResetClient"] = "CollabManagerBroadCastType.ResetClient";
})(CollabManagerBroadCastType || (CollabManagerBroadCastType = {}));
var CollabFail;
(function(CollabFail2) {
  CollabFail2["ApplyFailed"] = "CollabFail.ApplyFailed";
  CollabFail2["DocumentNotFound"] = "CollabFail.DocumentNotFound";
  CollabFail2["HistoryNotAvailable"] = "CollabFail.HistoryNotAvailable";
  CollabFail2["IncorrectManager"] = "CollabFail.IncorrectManager";
  CollabFail2["InvalidVersion"] = "CollabFail.InvalidVersion";
  CollabFail2["ManagerDestroyed"] = "CollabFail.ManagerDestroyed";
  CollabFail2["OutdatedVersion"] = "CollabFail.OutdatedVersion";
  CollabFail2["ManagerUnresponsive"] = "CollabFail.ManagerUnresponsive";
})(CollabFail || (CollabFail = {}));
var CollabClientRequestType;
(function(CollabClientRequestType2) {
  CollabClientRequestType2["GetDocument"] = "CollabClientRequestType.GetDocument";
  CollabClientRequestType2["PullEvents"] = "CollabClientRequestType.PullEvents";
  CollabClientRequestType2["PushEvents"] = "CollabClientRequestType.PushEvents";
})(CollabClientRequestType || (CollabClientRequestType = {}));
var DEFAULT_TIMEOUT = 1e3;
function wrapRequest(payload, { emitter, to, from, requestTimeout = DEFAULT_TIMEOUT }) {
  return new Promise((res, rej) => {
    const id = generateUUID();
    const removeListener = emitter.receiveMessages(from, (message) => {
      if (message.type !== MessageType.PONG || message.id !== id) {
        return;
      }
      clearTimeout(timer);
      removeListener();
      return res(message.messageBody);
    });
    const timer = setTimeout(() => {
      removeListener();
      rej(new Error(NetworkingError.Timeout));
    }, requestTimeout);
    emitter.transmit({
      to,
      from,
      id,
      messageBody: payload,
      type: MessageType.PING
    });
  });
}
function generateUUID() {
  return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16) + "-" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16) + "-" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16);
}
var ClientCommunication = class {
  constructor(_opts) {
    var _a;
    this._opts = _opts;
    this.getDocument = (body) => {
      let request = {
        type: CollabClientRequestType.GetDocument,
        body
      };
      return this._wrapRequest(CollabClientRequestType.GetDocument, request);
    };
    this.pullEvents = (body) => {
      const request = {
        type: CollabClientRequestType.PullEvents,
        body
      };
      return this._wrapRequest(CollabClientRequestType.PullEvents, request);
    };
    this.pushEvents = (body) => {
      const request = {
        type: CollabClientRequestType.PushEvents,
        body
      };
      return this._wrapRequest(CollabClientRequestType.PushEvents, request);
    };
    this.managerId = this._opts.managerId;
    const removeListener = (_a = this._opts.messageBus) === null || _a === void 0 ? void 0 : _a.receiveMessages(this._opts.clientId, (message) => {
      if (message.type !== MessageType.BROADCAST && message.from !== this.managerId) {
        return;
      }
      const messageBody = message.messageBody;
      const { type } = messageBody;
      if (messageBody.body.docName !== this._opts.docName) {
        return;
      }
      switch (type) {
        case CollabManagerBroadCastType.NewVersion: {
          this._opts.onNewVersion(messageBody.body);
          return;
        }
        case CollabManagerBroadCastType.ResetClient: {
          this._opts.onResetClient(messageBody.body);
          return;
        }
        default: {
          throw new Error(`Unknown message type: ${type}`);
        }
      }
    });
    this._opts.signal.addEventListener("abort", () => {
      removeListener();
    }, { once: true });
  }
  async _wrapRequest(type, request) {
    try {
      return await wrapRequest(request, {
        from: this._opts.clientId,
        to: this.managerId,
        emitter: this._opts.messageBus,
        requestTimeout: this._opts.requestTimeout
      });
    } catch (error) {
      if (error instanceof Error) {
        const message = error.message;
        switch (message) {
          case NetworkingError.Timeout: {
            return {
              body: CollabFail.ManagerUnresponsive,
              type,
              ok: false
            };
          }
          default: {
            throw error;
          }
        }
      }
      throw error;
    }
  }
};
var ManagerCommunication = class {
  constructor(managerId, _collabMessageBus, handleRequest, signal) {
    this.managerId = managerId;
    this._collabMessageBus = _collabMessageBus;
    const removeListener = this._collabMessageBus.receiveMessages(managerId, async (message) => {
      if (message.type !== MessageType.PING) {
        return;
      }
      const { id, messageBody } = message;
      let requestBody = messageBody || {};
      switch (requestBody.type) {
        case CollabClientRequestType.GetDocument:
        case CollabClientRequestType.PullEvents:
        case CollabClientRequestType.PushEvents: {
          let response = await handleRequest(requestBody, id);
          this._collabMessageBus.transmit({
            from: managerId,
            to: message.from,
            type: MessageType.PONG,
            id,
            messageBody: response
          });
          break;
        }
      }
    });
    signal.addEventListener("abort", () => {
      removeListener();
    }, { once: true });
  }
  broadcast(messageBody) {
    this._collabMessageBus.transmit({
      from: this.managerId,
      to: void 0,
      type: MessageType.BROADCAST,
      id: generateUUID(),
      messageBody
    });
  }
};

export {
  MessageType,
  CollabMessageBus,
  DEFAULT_MANAGER_ID,
  NetworkingError,
  CollabManagerBroadCastType,
  CollabFail,
  CollabClientRequestType,
  ClientCommunication,
  ManagerCommunication
};
//# sourceMappingURL=chunk-SNN6MBEY.js.map
