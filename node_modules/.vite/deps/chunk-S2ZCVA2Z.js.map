{
  "version": 3,
  "sources": ["../../../.yarn/__virtual__/@bangle.dev-tooltip-virtual-a36c7c7d14/5/Users/ted/.yarn/berry/cache/@bangle.dev-tooltip-npm-0.32.0-1525bd9cfd-10c0.zip/node_modules/@bangle.dev/tooltip/dist/index.js"],
  "sourcesContent": ["import { DOMSerializer, PluginKey, Plugin as Plugin$1, NodeSelection, InputRule, TextSelection, keymap, Fragment, Node, Selection } from '@bangle.dev/pm';\nimport { Plugin } from '@bangle.dev/core';\nimport { bangleWarn, createObject, filter, assertNotUndefined, findFirstMarkPosition, safeInsert, isChromeWithSelectionBug } from '@bangle.dev/utils';\nimport arrow from '@popperjs/core/lib/modifiers/arrow';\nimport flip from '@popperjs/core/lib/modifiers/flip';\nimport offset from '@popperjs/core/lib/modifiers/offset';\nimport popperOffsets from '@popperjs/core/lib/modifiers/popperOffsets';\nimport preventOverflow from '@popperjs/core/lib/modifiers/preventOverflow';\nimport { createPopper } from '@popperjs/core/lib/popper-lite';\n\nfunction createTooltipDOM(tooltipDOMSpec = [\n    'div',\n    {\n        class: 'bangle-tooltip',\n        role: 'tooltip',\n    },\n    [\n        'div',\n        {\n            class: 'bangle-tooltip-content',\n        },\n        0,\n    ],\n], arrow = false) {\n    const { dom, contentDOM } = DOMSerializer.renderSpec(window.document, tooltipDOMSpec);\n    if (arrow && !dom.querySelector('.bangle-tooltip-arrow')) {\n        const arrowElement = DOMSerializer.renderSpec(window.document, [\n            'div',\n            {\n                'class': 'bangle-tooltip-arrow',\n                'data-popper-arrow': '',\n            },\n        ]);\n        dom.appendChild(arrowElement.dom);\n    }\n    return { dom, contentDOM };\n}\n\nconst plugins$2 = tooltipPlacement;\nconst rem = typeof window === 'undefined'\n    ? 12\n    : parseFloat(getComputedStyle(document.documentElement).fontSize);\nfunction tooltipPlacement({ stateKey, renderOpts: { tooltipDOMSpec, placement = 'top', getReferenceElement, getScrollContainer = (view) => {\n    return view.dom.parentElement;\n}, onUpdateTooltip = (_state, _dispatch, _view) => { }, onHideTooltip = (_state, _dispatch, _view) => { }, tooltipOffset = () => {\n    return [0, 0.5 * rem];\n}, fallbackPlacements = ['bottom', 'top'], customPopperModifiers, }, }) {\n    const plugin = new Plugin({\n        view: (view) => {\n            return new TooltipPlacementView(view);\n        },\n    });\n    class TooltipPlacementView {\n        constructor(view) {\n            this.popperInstance = null;\n            this._view = view;\n            const { dom: tooltipDOM } = createTooltipDOM(tooltipDOMSpec);\n            this._tooltip = tooltipDOM;\n            this._scrollContainerDOM = getScrollContainer(view);\n            // TODO should this be this plugins responsibility\n            this._view.dom.parentNode.appendChild(this._tooltip);\n            const pluginState = stateKey.getState(view.state);\n            validateState(pluginState);\n            // if the initial state is to show, setup the tooltip\n            if (pluginState.show) {\n                this._showTooltip();\n                return;\n            }\n        }\n        destroy() {\n            if (this.popperInstance) {\n                this.popperInstance.destroy();\n                this.popperInstance = null;\n            }\n            this._view.dom.parentNode.removeChild(this._tooltip);\n        }\n        update(view, prevState) {\n            const pluginState = stateKey.getState(view.state);\n            if (pluginState === stateKey.getState(prevState)) {\n                return;\n            }\n            if (pluginState.show) {\n                onUpdateTooltip.call(this, view.state, view.dispatch, view);\n                this._showTooltip();\n            }\n            else {\n                this._hideTooltip();\n            }\n        }\n        _createPopperInstance(view) {\n            if (this.popperInstance) {\n                return;\n            }\n            const showTooltipArrow = this._tooltip.querySelector('[data-popper-arrow]');\n            const defaultModifiers = [\n                offset,\n                preventOverflow,\n                flip,\n                {\n                    name: 'offset',\n                    options: {\n                        offset: (popperState) => {\n                            return tooltipOffset(popperState);\n                        },\n                    },\n                },\n                {\n                    name: 'flip',\n                    options: {\n                        fallbackPlacements,\n                        padding: 10,\n                    },\n                },\n                {\n                    name: 'preventOverflow',\n                    options: {\n                        boundary: this._scrollContainerDOM,\n                    },\n                },\n                popperOffsets,\n                showTooltipArrow ? arrow : undefined,\n                showTooltipArrow\n                    ? {\n                        name: 'arrow',\n                        options: {\n                            element: showTooltipArrow,\n                        },\n                    }\n                    : undefined,\n            ].filter(Boolean);\n            this.popperInstance = createPopper(getReferenceElement(view, this._tooltip, this._scrollContainerDOM), this._tooltip, {\n                placement,\n                modifiers: customPopperModifiers\n                    ? customPopperModifiers(view, this._tooltip, this._scrollContainerDOM, defaultModifiers)\n                    : defaultModifiers,\n            });\n            onUpdateTooltip.call(this, view.state, view.dispatch, view);\n        }\n        _hideTooltip() {\n            if (this.popperInstance) {\n                this._tooltip.removeAttribute('data-show');\n                this.popperInstance.destroy();\n                this.popperInstance = null;\n                onHideTooltip.call(this, this._view.state, this._view.dispatch, this._view);\n            }\n        }\n        _showTooltip() {\n            this._tooltip.setAttribute('data-show', '');\n            this._createPopperInstance(this._view);\n            this.popperInstance.update();\n        }\n    }\n    return plugin;\n}\nfunction validateState(state) {\n    if (typeof state.show !== 'boolean') {\n        bangleWarn(`Tooltip must be controlled by a plugin having a boolean field \"show\" in its state, but received the state=`, state);\n        throw new Error('\"show\" field required.');\n    }\n}\n\nvar tooltipPlacement$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    plugins: plugins$2\n});\n\nconst plugins$1 = selectionTooltip;\nconst commands$1 = {\n    updateSelectionTooltipType,\n    hideSelectionTooltip,\n    queryIsSelectionTooltipActive,\n    querySelectionTooltipType,\n};\nlet log = () => { };\nfunction selectionTooltip({ key = new PluginKey('selectionTooltipPlugin'), calculateType = (state, _prevType) => {\n    return state.selection.empty ? null : 'default';\n}, tooltipRenderOpts = {}, }) {\n    return () => {\n        // - We are creating tooltipDOMSpec inside the callback because if we create outside\n        //   it might get reused by multiple view instances if the caller of\n        //   selectionTooltip is not careful and does not make a new selectionTooltip() call.\n        //   Though this doesn't mitigate the risk of caller using real\n        //   dom instances in the `tooltipRenderOpts.tooltipDOMSpec`.\n        // - We are converting to DOM elements so that their instances\n        //   can be shared across plugins.\n        const tooltipDOMSpec = createTooltipDOM(tooltipRenderOpts.tooltipDOMSpec);\n        return [\n            selectionTooltipState({\n                key: key,\n                tooltipDOMSpec,\n                calculateType,\n            }),\n            selectionTooltipController({ stateKey: key }),\n            plugins$2({\n                stateKey: key,\n                renderOpts: {\n                    ...tooltipRenderOpts,\n                    getReferenceElement: getSelectionReferenceElement,\n                    tooltipDOMSpec,\n                },\n            }),\n        ];\n    };\n}\nfunction selectionTooltipState({ key, calculateType, tooltipDOMSpec, }) {\n    return new Plugin$1({\n        key,\n        state: {\n            init: (_, state) => {\n                const type = calculateType(state, null);\n                return {\n                    type,\n                    tooltipContentDOM: tooltipDOMSpec.contentDOM,\n                    // For tooltipPlacement plugin\n                    show: typeof type === 'string',\n                    // helpers\n                    calculateType,\n                };\n            },\n            apply: (tr, pluginState) => {\n                const meta = tr.getMeta(key);\n                if (meta === undefined) {\n                    return pluginState;\n                }\n                // Do not change object reference if 'type' was and is null\n                if (meta.type == null && pluginState.type == null) {\n                    return pluginState;\n                }\n                log('update tooltip state to ', meta.type);\n                return {\n                    ...pluginState,\n                    type: meta.type,\n                    show: typeof meta.type === 'string',\n                };\n            },\n        },\n    });\n}\nfunction selectionTooltipController({ stateKey }) {\n    let mouseDown = false;\n    return new Plugin$1({\n        props: {\n            handleDOMEvents: {\n                mousedown: (_view, _event) => {\n                    mouseDown = true;\n                    return false;\n                },\n                mouseup: (view, _event) => {\n                    mouseDown = false;\n                    _syncTooltipOnUpdate(stateKey)(view.state, view.dispatch, view);\n                    return false;\n                },\n            },\n        },\n        view() {\n            return {\n                update(view, lastState) {\n                    const state = view.state;\n                    if (mouseDown || lastState === state) {\n                        return;\n                    }\n                    if (lastState &&\n                        lastState.doc.eq(state.doc) &&\n                        lastState.selection.eq(state.selection)) {\n                        return;\n                    }\n                    return _syncTooltipOnUpdate(stateKey)(view.state, view.dispatch, view);\n                },\n            };\n        },\n    });\n}\nfunction getSelectionReferenceElement(view) {\n    return {\n        getBoundingClientRect: () => {\n            const { selection } = view.state;\n            let { head, from } = selection;\n            // since head is dependent on the users choice of direction,\n            // it is not always equal to `from`.\n            // For textSelections we want to show the tooltip at head of the\n            // selection.\n            // But for NodeSelection we always want `from` since, if we go with `head`\n            // coordsAtPos(head) might get the position `to` in head, resulting in\n            // incorrectly getting position of the node after the selected Node.\n            const pos = selection instanceof NodeSelection ? from : head;\n            const start = view.coordsAtPos(pos);\n            let { top, bottom, left, right } = start;\n            let width = right - left;\n            // Not sure why, but coordsAtPos does not return the correct\n            // width of the element, so doing this to override it.\n            if (selection instanceof NodeSelection) {\n                const domNode = view.nodeDOM(pos);\n                width = domNode ? domNode.clientWidth : width;\n            }\n            return {\n                width,\n                height: bottom - top,\n                top: top,\n                right: right,\n                bottom: bottom,\n                left: left,\n            };\n        },\n    };\n}\nfunction _syncTooltipOnUpdate(key) {\n    return (state, dispatch, view) => {\n        const tooltipState = key.getState(state);\n        const newType = tooltipState.calculateType(state, tooltipState.type);\n        if (typeof newType === 'string') {\n            return updateSelectionTooltipType(key, newType)(state, dispatch, view);\n        }\n        // Only hide if it is not already hidden\n        if (newType == null && tooltipState.type != null) {\n            return hideSelectionTooltip(key)(state, dispatch, view);\n        }\n        return false;\n    };\n}\n/** Commands  */\n// This command will rerender if you call it with the type\n// it already has. This is done in order to update the position of a tooltip.\nfunction updateSelectionTooltipType(key, type) {\n    return (state, dispatch, _view) => {\n        if (dispatch) {\n            dispatch(state.tr.setMeta(key, { type }).setMeta('addToHistory', false));\n        }\n        return true;\n    };\n}\nfunction hideSelectionTooltip(key) {\n    return (state, dispatch, _view) => {\n        if (dispatch) {\n            dispatch(state.tr.setMeta(key, { type: null }).setMeta('addToHistory', false));\n        }\n        return true;\n    };\n}\nfunction queryIsSelectionTooltipActive(key) {\n    return (state) => {\n        const pluginState = key.getState(state);\n        return pluginState && typeof pluginState.type === 'string' ? true : false;\n    };\n}\nfunction querySelectionTooltipType(key) {\n    return (state) => {\n        const pluginState = key.getState(state);\n        return pluginState && pluginState.type;\n    };\n}\n\nvar selectionTooltip$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    plugins: plugins$1,\n    commands: commands$1,\n    _syncTooltipOnUpdate: _syncTooltipOnUpdate,\n    updateSelectionTooltipType: updateSelectionTooltipType,\n    hideSelectionTooltip: hideSelectionTooltip,\n    queryIsSelectionTooltipActive: queryIsSelectionTooltipActive,\n    querySelectionTooltipType: querySelectionTooltipType\n});\n\n// ProseMirror uses the Unicode Character 'OBJECT REPLACEMENT CHARACTER' (U+FFFC) as text representation for\n// leaf nodes, i.e. nodes that don't have any content or text property (e.g. hardBreak, emoji)\n// It was introduced because of https://github.com/ProseMirror/prosemirror/issues/262\n// This can be used in an input rule regex to be able to include or exclude such nodes.\nconst leafNodeReplacementCharacter = '\\ufffc';\nfunction triggerInputRule(schema, markName, trigger) {\n    const regexStart = new RegExp(`(^|[.!?\\\\s${leafNodeReplacementCharacter}])(${escapeRegExp(trigger)})$`);\n    const startRule = new InputRule(regexStart, (editorState, match) => {\n        /**\n         * Why using match 2 and 3?  Regex:\n         * (allowed characters before trigger)(joined|triggers|(sub capture groups))\n         *            match[1]                     match[2]          match[3] – optional\n         */\n        const trigger = match[3] || match[2];\n        if (!trigger) {\n            return null;\n        }\n        const mark = schema.mark(markName, { trigger });\n        const { tr, selection } = editorState;\n        // set the selection to cover the trigger\n        // when the trigger is bigger than 1 char.\n        // for 1 char length you dont need a non empty selection.\n        if (trigger.length > 1) {\n            const textSelection = TextSelection.create(tr.doc, selection.from, selection.from - trigger.length + 1);\n            tr.setSelection(textSelection);\n        }\n        const marks = selection.$from.marks(); // selection would tell the cursor position, in this case from == to as no selection\n        return tr.replaceSelectionWith(schema.text(trigger, [mark, ...marks]), false);\n    });\n    return startRule;\n}\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nconst reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\nconst reHasRegExpChar = RegExp(reRegExpChar.source);\n/**\n * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n *\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @see escape, escapeRegExp, unescape\n * @example\n *\n * escapeRegExp('[lodash](https://lodash.com/)')\n * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n */\nfunction escapeRegExp(string) {\n    return string && reHasRegExpChar.test(string)\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string || '';\n}\n\nconst spec = specFactory;\nconst plugins = pluginsFactory;\nconst commands = {\n    queryTriggerText,\n    queryIsSuggestTooltipActive,\n    replaceSuggestMarkWith,\n    incrementSuggestTooltipCounter,\n    decrementSuggestTooltipCounter,\n    resetSuggestTooltipCounter,\n};\nconst defaultKeys = {\n    select: 'Enter',\n    up: 'ArrowUp',\n    down: 'ArrowDown',\n    hide: 'Escape',\n    right: undefined,\n    left: undefined,\n};\nfunction specFactory({ markName, trigger, markColor = '#005893', }) {\n    return {\n        name: markName,\n        type: 'mark',\n        schema: {\n            inclusive: true,\n            excludes: '_',\n            group: 'suggestTriggerMarks',\n            parseDOM: [{ tag: `span[data-${markName}]` }],\n            toDOM: (mark) => {\n                return [\n                    'span',\n                    {\n                        'data-bangle-name': markName,\n                        'data-suggest-trigger': mark.attrs['trigger'],\n                        'style': `color: ${markColor}`,\n                    },\n                ];\n            },\n            attrs: {\n                trigger: { default: trigger },\n            },\n        },\n        markdown: {\n            toMarkdown: {\n                open: '',\n                close: '',\n                mixable: true,\n            },\n        },\n    };\n}\nfunction pluginsFactory({ key = new PluginKey('suggest_tooltip'), markName, trigger, tooltipRenderOpts, keybindings = defaultKeys, onEnter = (state, dispatch, view) => {\n    return removeSuggestMark(key)(state, dispatch, view);\n}, onArrowDown = incrementSuggestTooltipCounter(key), onArrowUp = decrementSuggestTooltipCounter(key), onEscape = (state, dispatch, view) => {\n    return removeSuggestMark(key)(state, dispatch, view);\n}, onArrowLeft, onArrowRight, }) {\n    return ({ schema }) => {\n        const isActiveCheck = queryIsSuggestTooltipActive(key);\n        return [\n            new Plugin$1({\n                key,\n                state: {\n                    init(_, _state) {\n                        return {\n                            trigger,\n                            markName,\n                            triggerText: '',\n                            show: false,\n                            counter: 0,\n                        };\n                    },\n                    apply(tr, pluginState, _oldState, newState) {\n                        const meta = tr.getMeta(key);\n                        if (meta === undefined) {\n                            return pluginState;\n                        }\n                        if (meta.type === 'RENDER_TOOLTIP') {\n                            return {\n                                ...pluginState,\n                                // Cannot use queryTriggerText because it relies on\n                                // reading the pluginState which will not be there in newState.\n                                triggerText: getTriggerText(newState, markName, trigger),\n                                show: true,\n                            };\n                        }\n                        if (meta.type === 'HIDE_TOOLTIP') {\n                            // Do not change object reference if show was and is false\n                            if (pluginState.show === false) {\n                                return pluginState;\n                            }\n                            return {\n                                ...pluginState,\n                                triggerText: '',\n                                show: false,\n                                counter: 0,\n                            };\n                        }\n                        if (meta.type === 'INCREMENT_COUNTER') {\n                            return { ...pluginState, counter: pluginState.counter + 1 };\n                        }\n                        if (meta.type === 'RESET_COUNTER') {\n                            return { ...pluginState, counter: 0 };\n                        }\n                        if (meta.type === 'UPDATE_COUNTER') {\n                            return { ...pluginState, counter: meta.value };\n                        }\n                        if (meta.type === 'DECREMENT_COUNTER') {\n                            return { ...pluginState, counter: pluginState.counter - 1 };\n                        }\n                        throw new Error('Unknown type');\n                    },\n                },\n            }),\n            plugins$2({\n                stateKey: key,\n                renderOpts: {\n                    ...tooltipRenderOpts,\n                    getReferenceElement: referenceElement((state) => {\n                        const markType = schema.marks[markName];\n                        assertNotUndefined(markType, `markType ${markName} not found`);\n                        const { selection } = state;\n                        return findFirstMarkPosition(markType, state.doc, selection.from - 1, selection.to);\n                    }),\n                },\n            }),\n            triggerInputRule(schema, markName, trigger),\n            tooltipController({\n                trigger,\n                markName,\n                key,\n            }),\n            keybindings &&\n                keymap(createObject([\n                    [keybindings.select, filter(isActiveCheck, onEnter)],\n                    [keybindings.up, filter(isActiveCheck, onArrowUp)],\n                    [keybindings.down, filter(isActiveCheck, onArrowDown)],\n                    [keybindings.left, filter(isActiveCheck, onArrowLeft)],\n                    [keybindings.right, filter(isActiveCheck, onArrowRight)],\n                    [keybindings.hide, filter(isActiveCheck, onEscape)],\n                ])),\n        ];\n    };\n}\nfunction referenceElement(getActiveMarkPos) {\n    return (view, _tooltipDOM, _scrollContainerDOM) => {\n        return {\n            getBoundingClientRect: () => {\n                let state = view.state;\n                const markPos = getActiveMarkPos(state);\n                // add by + so that we get the position right after trigger\n                const startPos = markPos.start > -1 ? markPos.start + 1 : 0;\n                const start = view.coordsAtPos(startPos);\n                // if the suggestMark text spanned two lines, we want to show the tooltip based on the end pos\n                // so that it doesn't hide the text\n                const end = view.coordsAtPos(markPos.end > -1 ? markPos.end : startPos);\n                let { left, right } = start;\n                let { top, bottom } = end;\n                const x = left;\n                const y = top;\n                const width = right - left;\n                const height = bottom - top;\n                return new DOMRect(x, y, width, height);\n            },\n        };\n    };\n}\nfunction tooltipController({ key, trigger, markName, }) {\n    return new Plugin$1({\n        view() {\n            return {\n                update: (view, lastState) => {\n                    const { state } = view;\n                    if (lastState === state || !state.selection.empty) {\n                        return;\n                    }\n                    const markType = state.schema.marks[markName];\n                    assertNotUndefined(markType, `markType ${markName} not found`);\n                    if (lastState.doc.eq(state.doc) &&\n                        state.selection.eq(lastState && lastState.selection) &&\n                        // This is a shorthand for checking if the stored mark  of `markType`\n                        // has changed within the last step. If it has we need to update the state\n                        isStoredMark(state, markType) === isStoredMark(lastState, markType)) {\n                        return;\n                    }\n                    const isMarkActive = isSuggestMarkActive(markName)(state);\n                    // clear the mark if the user delete the trigger but remaining mark text\n                    // stayed.\n                    // Example `<mark>/hello</mark>` --(user deletes the /)-> `<mark>hello</mark>`\n                    // -> (clear) ->  hello\n                    if (isMarkActive && !doesQueryHaveTrigger(state, markType, trigger)) {\n                        removeSuggestMark(key)(state, view.dispatch, view);\n                        return;\n                    }\n                    if (!isMarkActive) {\n                        // performance optimization to prevent unnecessary dispatches\n                        if (key.getState(state).show === true) {\n                            hideSuggestionsTooltip(key)(view.state, view.dispatch, view);\n                        }\n                        return;\n                    }\n                    renderSuggestionsTooltip(key)(view.state, view.dispatch, view);\n                    return;\n                },\n            };\n        },\n    });\n}\nfunction isStoredMark(state, markType) {\n    return state && state.storedMarks && markType.isInSet(state.storedMarks);\n}\nfunction isSuggestMarkActive(markName) {\n    return (state) => {\n        const { from, to } = state.selection;\n        const markType = state.schema.marks[markName];\n        assertNotUndefined(markType, `markType ${markName} not found`);\n        return state.doc.rangeHasMark(from - 1, to, markType);\n    };\n}\nfunction doesQueryHaveTrigger(state, markType, trigger) {\n    const { nodeBefore } = state.selection.$from;\n    // nodeBefore in a new line (a new paragraph) is null\n    if (!nodeBefore) {\n        return false;\n    }\n    const suggestMark = markType.isInSet(nodeBefore.marks || []);\n    // suggestMark is undefined if you delete the trigger while keeping rest of the query alive\n    if (!suggestMark) {\n        return false;\n    }\n    const textContent = nodeBefore.textContent || '';\n    return textContent.includes(trigger);\n}\nfunction renderSuggestionsTooltip(key) {\n    return (state, dispatch, _view) => {\n        if (dispatch) {\n            dispatch(state.tr\n                .setMeta(key, { type: 'RENDER_TOOLTIP' })\n                .setMeta('addToHistory', false));\n        }\n        return true;\n    };\n}\nfunction hideSuggestionsTooltip(key) {\n    return (state, dispatch, _view) => {\n        if (dispatch) {\n            dispatch(state.tr\n                .setMeta(key, { type: 'HIDE_TOOLTIP' })\n                .setMeta('addToHistory', false));\n        }\n        return true;\n    };\n}\nfunction getTriggerText(state, markName, trigger) {\n    const markType = state.schema.marks[markName];\n    assertNotUndefined(markType, `markType ${markName} not found`);\n    const { nodeBefore } = state.selection.$from;\n    // nodeBefore in a new line (a new paragraph) is null\n    if (!nodeBefore) {\n        return '';\n    }\n    const suggestMark = markType.isInSet(nodeBefore.marks || []);\n    // suggestMark is undefined if you delete the trigger while keeping rest of the query alive\n    if (!suggestMark) {\n        return '';\n    }\n    const textContent = nodeBefore.textContent || '';\n    return (textContent\n        // eslint-disable-next-line no-control-regex\n        .replace(/^([^\\x00-\\xFF]|[\\s\\n])+/g, '')\n        .replace(trigger, ''));\n}\n/** Commands */\nfunction queryTriggerText(key) {\n    return (state) => {\n        const { trigger, markName } = key.getState(state);\n        return getTriggerText(state, markName, trigger);\n    };\n}\nfunction queryIsSuggestTooltipActive(key) {\n    return (state) => {\n        return key.getState(state) && key.getState(state).show;\n    };\n}\nfunction replaceSuggestMarkWith(key, maybeNode) {\n    return (state, dispatch, view) => {\n        const { markName } = key.getState(state);\n        const { schema } = state;\n        const markType = schema.marks[markName];\n        assertNotUndefined(markType, `markType ${markName} not found`);\n        const { selection } = state;\n        const queryMark = findFirstMarkPosition(markType, state.doc, selection.from - 1, selection.to);\n        if (!queryMark || queryMark.start === -1) {\n            return false;\n        }\n        const getTr = () => {\n            const { start, end } = queryMark;\n            let tr = state.tr\n                .removeStoredMark(markType)\n                .replaceWith(start, end, Fragment.empty);\n            if (!maybeNode) {\n                return tr;\n            }\n            const isInputFragment = maybeNode instanceof Fragment;\n            let node;\n            try {\n                node =\n                    maybeNode instanceof Node || isInputFragment\n                        ? maybeNode\n                        : typeof maybeNode === 'string'\n                            ? state.schema.text(maybeNode)\n                            : Node.fromJSON(state.schema, maybeNode);\n            }\n            catch (e) {\n                console.error(e);\n                return tr;\n            }\n            if (node.isText) {\n                tr = tr.replaceWith(start, start, node);\n            }\n            else if (node.isBlock) {\n                tr = safeInsert(node)(tr);\n            }\n            else if (node.isInline || isInputFragment) {\n                const fragment = isInputFragment\n                    ? node\n                    : Fragment.fromArray([node, state.schema.text(' ')]);\n                tr = tr.replaceWith(start, start, fragment);\n                // This problem affects Chrome v58+. See: https://github.com/ProseMirror/prosemirror/issues/710\n                if (isChromeWithSelectionBug) {\n                    const selection = document.getSelection();\n                    if (selection) {\n                        selection.empty();\n                    }\n                }\n                // Placing cursor after node + space.\n                tr = tr.setSelection(Selection.near(tr.doc.resolve(start + fragment.size)));\n                return tr;\n            }\n            return tr;\n        };\n        const tr = getTr();\n        if (dispatch) {\n            view === null || view === void 0 ? void 0 : view.focus();\n            dispatch(tr);\n        }\n        return true;\n    };\n}\nfunction removeSuggestMark(key) {\n    return (state, dispatch, _view) => {\n        const { markName } = key.getState(state);\n        const { schema, selection } = state;\n        const markType = schema.marks[markName];\n        assertNotUndefined(markType, `markType ${markName} not found`);\n        const queryMark = findFirstMarkPosition(markType, state.doc, selection.from - 1, selection.to);\n        const { start, end } = queryMark;\n        if (start === -1 &&\n            state.storedMarks &&\n            markType.isInSet(state.storedMarks)) {\n            if (dispatch) {\n                dispatch(state.tr.removeStoredMark(markType));\n            }\n            return true;\n        }\n        if (start === -1) {\n            return false;\n        }\n        if (dispatch) {\n            dispatch(state.tr\n                .removeMark(start, end, markType)\n                // stored marks are marks which will be carried forward to whatever\n                // the user types next, like if current mark\n                // is bold, new input continues being bold\n                .removeStoredMark(markType)\n                // This helps us avoid the case:\n                // when a user deleted the trigger/ in '<suggest_mark>/something</suggest_mark>'\n                // and then performs undo.\n                // If we do not hide this from history, command z will bring\n                // us in the state of `<suggest_mark>something<suggest_mark>` without the trigger `/`\n                // and seeing this state `tooltipActivatePlugin` plugin will dispatch a new command removing\n                // the mark, hence never allowing the user to command z.\n                .setMeta('addToHistory', false));\n        }\n        return true;\n    };\n}\nfunction incrementSuggestTooltipCounter(key) {\n    return (state, dispatch, _view) => {\n        if (dispatch) {\n            dispatch(state.tr\n                .setMeta(key, { type: 'INCREMENT_COUNTER' })\n                .setMeta('addToHistory', false));\n        }\n        return true;\n    };\n}\nfunction decrementSuggestTooltipCounter(key) {\n    return (state, dispatch, _view) => {\n        if (dispatch) {\n            dispatch(state.tr\n                .setMeta(key, { type: 'DECREMENT_COUNTER' })\n                .setMeta('addToHistory', false));\n        }\n        return true;\n    };\n}\nfunction resetSuggestTooltipCounter(key) {\n    return (state, dispatch, _view) => {\n        if (dispatch) {\n            dispatch(state.tr\n                .setMeta(key, { type: 'RESET_COUNTER' })\n                .setMeta('addToHistory', false));\n        }\n        return true;\n    };\n}\nfunction updateSuggestTooltipCounter(key, counter) {\n    return (state, dispatch, _view) => {\n        if (dispatch) {\n            dispatch(state.tr\n                .setMeta(key, { type: 'UPDATE_COUNTER', value: counter })\n                .setMeta('addToHistory', false));\n        }\n        return true;\n    };\n}\n\nvar suggestTooltip = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    spec: spec,\n    plugins: plugins,\n    commands: commands,\n    defaultKeys: defaultKeys,\n    queryTriggerText: queryTriggerText,\n    queryIsSuggestTooltipActive: queryIsSuggestTooltipActive,\n    replaceSuggestMarkWith: replaceSuggestMarkWith,\n    removeSuggestMark: removeSuggestMark,\n    incrementSuggestTooltipCounter: incrementSuggestTooltipCounter,\n    decrementSuggestTooltipCounter: decrementSuggestTooltipCounter,\n    resetSuggestTooltipCounter: resetSuggestTooltipCounter,\n    updateSuggestTooltipCounter: updateSuggestTooltipCounter\n});\n\nexport { createTooltipDOM, selectionTooltip$1 as selectionTooltip, suggestTooltip, tooltipPlacement$1 as tooltipPlacement };\n"],
  "mappings": "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",
  "names": ["trigger", "tr", "selection"]
}
