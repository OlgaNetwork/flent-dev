{
  "version": 3,
  "sources": ["../../../.yarn/__virtual__/@bangle.dev-search-virtual-b6198a2ffb/5/Users/ted/.yarn/berry/cache/@bangle.dev-search-npm-0.32.0-92629819ea-10c0.zip/node_modules/@bangle.dev/search/dist/index.js"],
  "sourcesContent": ["import { Plugin, PluginKey, DecorationSet, Decoration } from '@bangle.dev/pm';\nimport { matchAllPlus } from '@bangle.dev/utils';\n\nconst name = 'search';\nconst plugins = pluginsFactory;\nfunction pluginsFactory({ key = new PluginKey(name), query: initialQuery, className = 'bangle-search-match', maxHighlights = 1500, }) {\n    function buildDeco(state, query) {\n        if (!query) {\n            return DecorationSet.empty;\n        }\n        const matches = findMatches(state.doc, query, maxHighlights);\n        const decorations = matches.map((match) => {\n            // TODO we should improve the performance\n            // by only creating decos which need an update\n            // see https://discuss.prosemirror.net/t/how-to-update-multiple-inline-decorations-on-node-change/1493\n            return Decoration.inline(match.pos + match.match.start, match.pos + match.match.end, {\n                class: className,\n            });\n        });\n        return DecorationSet.create(state.doc, decorations);\n    }\n    return () => new Plugin({\n        key: key,\n        state: {\n            init(_, state) {\n                return {\n                    query: initialQuery,\n                    decos: buildDeco(state, initialQuery),\n                };\n            },\n            apply(tr, old, oldState, newState) {\n                const meta = tr.getMeta(key);\n                if (meta) {\n                    const newQuery = meta.query;\n                    return {\n                        query: newQuery,\n                        decos: buildDeco(newState, newQuery),\n                    };\n                }\n                return tr.docChanged\n                    ? {\n                        query: old.query,\n                        decos: buildDeco(newState, old.query),\n                    }\n                    : old;\n            },\n        },\n        props: {\n            decorations(state) {\n                var _a;\n                return ((_a = key.getState(state)) === null || _a === void 0 ? void 0 : _a.decos) || null;\n            },\n        },\n    });\n}\nfunction findMatches(doc, regex, maxHighlights) {\n    let results = [];\n    let count = 0;\n    let gRegex;\n    if (regex instanceof RegExp) {\n        let flags = 'g';\n        if (regex.ignoreCase) {\n            flags += 'i';\n        }\n        if (regex.multiline) {\n            flags += 'm';\n        }\n        gRegex = RegExp(regex.source, flags);\n    }\n    else {\n        gRegex = RegExp(regex, 'g');\n    }\n    doc.descendants((node, pos) => {\n        if (maxHighlights <= count) {\n            return false;\n        }\n        if (node.isText) {\n            const source = node.textContent;\n            const matchedResult = matchAllPlus(gRegex, source);\n            for (const match of matchedResult) {\n                if (!match.match) {\n                    continue;\n                }\n                if (maxHighlights <= count++) {\n                    break;\n                }\n                results.push({\n                    pos,\n                    match,\n                });\n            }\n        }\n        return;\n    });\n    return results;\n}\nfunction updateSearchQuery(key, query) {\n    return (state, dispatch, _view) => {\n        if (dispatch) {\n            dispatch(state.tr.setMeta(key, { query }).setMeta('addToHistory', false));\n        }\n        return true;\n    };\n}\n\nvar search = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    plugins: plugins,\n    updateSearchQuery: updateSearchQuery\n});\n\nexport { search };\n"],
  "mappings": ";;;;;;;;;;;;;AAGA,IAAM,OAAO;AACb,IAAM,UAAU;AAChB,SAAS,eAAe,EAAE,MAAM,IAAI,UAAU,IAAI,GAAG,OAAO,cAAc,YAAY,uBAAuB,gBAAgB,KAAM,GAAG;AAClI,WAAS,UAAU,OAAO,OAAO;AAC7B,QAAI,CAAC,OAAO;AACR,aAAO,cAAc;AAAA,IACzB;AACA,UAAM,UAAU,YAAY,MAAM,KAAK,OAAO,aAAa;AAC3D,UAAM,cAAc,QAAQ,IAAI,CAAC,UAAU;AAIvC,aAAO,WAAW,OAAO,MAAM,MAAM,MAAM,MAAM,OAAO,MAAM,MAAM,MAAM,MAAM,KAAK;AAAA,QACjF,OAAO;AAAA,MACX,CAAC;AAAA,IACL,CAAC;AACD,WAAO,cAAc,OAAO,MAAM,KAAK,WAAW;AAAA,EACtD;AACA,SAAO,MAAM,IAAI,OAAO;AAAA,IACpB;AAAA,IACA,OAAO;AAAA,MACH,KAAK,GAAG,OAAO;AACX,eAAO;AAAA,UACH,OAAO;AAAA,UACP,OAAO,UAAU,OAAO,YAAY;AAAA,QACxC;AAAA,MACJ;AAAA,MACA,MAAM,IAAI,KAAK,UAAU,UAAU;AAC/B,cAAM,OAAO,GAAG,QAAQ,GAAG;AAC3B,YAAI,MAAM;AACN,gBAAM,WAAW,KAAK;AACtB,iBAAO;AAAA,YACH,OAAO;AAAA,YACP,OAAO,UAAU,UAAU,QAAQ;AAAA,UACvC;AAAA,QACJ;AACA,eAAO,GAAG,aACJ;AAAA,UACE,OAAO,IAAI;AAAA,UACX,OAAO,UAAU,UAAU,IAAI,KAAK;AAAA,QACxC,IACE;AAAA,MACV;AAAA,IACJ;AAAA,IACA,OAAO;AAAA,MACH,YAAY,OAAO;AACf,YAAI;AACJ,iBAAS,KAAK,IAAI,SAAS,KAAK,OAAO,QAAQ,OAAO,SAAS,SAAS,GAAG,UAAU;AAAA,MACzF;AAAA,IACJ;AAAA,EACJ,CAAC;AACL;AACA,SAAS,YAAY,KAAK,OAAO,eAAe;AAC5C,MAAI,UAAU,CAAC;AACf,MAAI,QAAQ;AACZ,MAAI;AACJ,MAAI,iBAAiB,QAAQ;AACzB,QAAI,QAAQ;AACZ,QAAI,MAAM,YAAY;AAClB,eAAS;AAAA,IACb;AACA,QAAI,MAAM,WAAW;AACjB,eAAS;AAAA,IACb;AACA,aAAS,OAAO,MAAM,QAAQ,KAAK;AAAA,EACvC,OACK;AACD,aAAS,OAAO,OAAO,GAAG;AAAA,EAC9B;AACA,MAAI,YAAY,CAAC,MAAM,QAAQ;AAC3B,QAAI,iBAAiB,OAAO;AACxB,aAAO;AAAA,IACX;AACA,QAAI,KAAK,QAAQ;AACb,YAAM,SAAS,KAAK;AACpB,YAAM,gBAAgB,aAAa,QAAQ,MAAM;AACjD,iBAAW,SAAS,eAAe;AAC/B,YAAI,CAAC,MAAM,OAAO;AACd;AAAA,QACJ;AACA,YAAI,iBAAiB,SAAS;AAC1B;AAAA,QACJ;AACA,gBAAQ,KAAK;AAAA,UACT;AAAA,UACA;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,IACJ;AACA;AAAA,EACJ,CAAC;AACD,SAAO;AACX;AACA,SAAS,kBAAkB,KAAK,OAAO;AACnC,SAAO,CAAC,OAAO,UAAU,UAAU;AAC/B,QAAI,UAAU;AACV,eAAS,MAAM,GAAG,QAAQ,KAAK,EAAE,MAAM,CAAC,EAAE,QAAQ,gBAAgB,KAAK,CAAC;AAAA,IAC5E;AACA,WAAO;AAAA,EACX;AACJ;AAEA,IAAI,SAAsB,OAAO,OAAO;AAAA,EACpC,WAAW;AAAA,EACX;AAAA,EACA;AACJ,CAAC;",
  "names": []
}
