import {
  ClientCommunication,
  CollabFail,
  DEFAULT_MANAGER_ID
} from "./chunk-SNN6MBEY.js";
import {
  abortableSetTimeout,
  isTestEnv,
  sleep,
  uuid
} from "./chunk-F3Z2TPKG.js";
import {
  Node,
  Plugin,
  PluginKey,
  Selection,
  Step,
  TextSelection
} from "./chunk-ZRMAPHIN.js";
import "./chunk-NVKSN2QT.js";
import "./chunk-AUZ3RYOM.js";

// ../../../../Users/ted/.yarn/berry/cache/prosemirror-collab-npm-1.3.1-7906a9ff89-10c0.zip/node_modules/prosemirror-collab/dist/index.js
var Rebaseable = class {
  constructor(step, inverted, origin) {
    this.step = step;
    this.inverted = inverted;
    this.origin = origin;
  }
};
function rebaseSteps(steps, over, transform) {
  for (let i = steps.length - 1; i >= 0; i--)
    transform.step(steps[i].inverted);
  for (let i = 0; i < over.length; i++)
    transform.step(over[i]);
  let result = [];
  for (let i = 0, mapFrom = steps.length; i < steps.length; i++) {
    let mapped = steps[i].step.map(transform.mapping.slice(mapFrom));
    mapFrom--;
    if (mapped && !transform.maybeStep(mapped).failed) {
      transform.mapping.setMirror(mapFrom, transform.steps.length - 1);
      result.push(new Rebaseable(mapped, mapped.invert(transform.docs[transform.docs.length - 1]), steps[i].origin));
    }
  }
  return result;
}
var CollabState = class {
  constructor(version, unconfirmed) {
    this.version = version;
    this.unconfirmed = unconfirmed;
  }
};
function unconfirmedFrom(transform) {
  let result = [];
  for (let i = 0; i < transform.steps.length; i++)
    result.push(new Rebaseable(transform.steps[i], transform.steps[i].invert(transform.docs[i]), transform));
  return result;
}
var collabKey = new PluginKey("collab");
function collab(config = {}) {
  let conf = {
    version: config.version || 0,
    clientID: config.clientID == null ? Math.floor(Math.random() * 4294967295) : config.clientID
  };
  return new Plugin({
    key: collabKey,
    state: {
      init: () => new CollabState(conf.version, []),
      apply(tr, collab2) {
        let newState = tr.getMeta(collabKey);
        if (newState)
          return newState;
        if (tr.docChanged)
          return new CollabState(collab2.version, collab2.unconfirmed.concat(unconfirmedFrom(tr)));
        return collab2;
      }
    },
    config: conf,
    // This is used to notify the history plugin to not merge steps,
    // so that the history can be rebased.
    historyPreserveItems: true
  });
}
function receiveTransaction(state, steps, clientIDs, options = {}) {
  let collabState = collabKey.getState(state);
  let version = collabState.version + steps.length;
  let ourID = collabKey.get(state).spec.config.clientID;
  let ours = 0;
  while (ours < clientIDs.length && clientIDs[ours] == ourID)
    ++ours;
  let unconfirmed = collabState.unconfirmed.slice(ours);
  steps = ours ? steps.slice(ours) : steps;
  if (!steps.length)
    return state.tr.setMeta(collabKey, new CollabState(version, unconfirmed));
  let nUnconfirmed = unconfirmed.length;
  let tr = state.tr;
  if (nUnconfirmed) {
    unconfirmed = rebaseSteps(unconfirmed, steps, tr);
  } else {
    for (let i = 0; i < steps.length; i++)
      tr.step(steps[i]);
    unconfirmed = [];
  }
  let newCollabState = new CollabState(version, unconfirmed);
  if (options && options.mapSelectionBackward && state.selection instanceof TextSelection) {
    tr.setSelection(TextSelection.between(tr.doc.resolve(tr.mapping.map(state.selection.anchor, -1)), tr.doc.resolve(tr.mapping.map(state.selection.head, -1)), -1));
    tr.updated &= ~1;
  }
  return tr.setMeta("rebased", nUnconfirmed).setMeta("addToHistory", false).setMeta(collabKey, newCollabState);
}
function sendableSteps(state) {
  let collabState = collabKey.getState(state);
  if (collabState.unconfirmed.length == 0)
    return null;
  return {
    version: collabState.version,
    steps: collabState.unconfirmed.map((s) => s.step),
    clientID: collabKey.get(state).spec.config.clientID,
    get origins() {
      return this._origins || (this._origins = collabState.unconfirmed.map((s) => s.origin));
    }
  };
}
function getVersion(state) {
  return collabKey.getState(state).version;
}

// .yarn/__virtual__/@bangle.dev-collab-client-virtual-49c72eec71/5/Users/ted/.yarn/berry/cache/@bangle.dev-collab-client-npm-0.32.0-9de75abf98-10c0.zip/node_modules/@bangle.dev/collab-client/dist/index.js
var MAX_STATES_TO_KEEP = 15;
var STUCK_IN_ERROR_THRESHOLD = 5;
var collabClientKey = new PluginKey("bangle.dev/collab-client");
var collabMonitorKey = new PluginKey("bangle.dev/collabMonitorKey");
var EventType;
(function(EventType2) {
  EventType2["Fatal"] = "FATAL_EVENT";
  EventType2["HardReset"] = "HARD_RESET_EVENT";
  EventType2["InitDoc"] = "INIT_DOC_EVENT";
  EventType2["InitError"] = "INIT_ERROR_EVENT";
  EventType2["Pull"] = "PULL_EVENT";
  EventType2["Push"] = "PUSH_EVENT";
  EventType2["PushPullError"] = "PUSH_PULL_ERROR_EVENT";
  EventType2["Ready"] = "READY_EVENT";
  EventType2["Restart"] = "RESTART_EVENT";
})(EventType || (EventType = {}));
var FatalErrorCode;
(function(FatalErrorCode2) {
  FatalErrorCode2["InitialDocLoadFailed"] = "INITIAL_DOC_LOAD_FAILED";
  FatalErrorCode2["StuckInInfiniteLoop"] = "STUCK_IN_INFINITE_LOOP";
  FatalErrorCode2["IncorrectManager"] = "INCORRECT_MANAGER";
  FatalErrorCode2["HistoryNotAvailable"] = "HISTORY_NOT_AVAILABLE";
  FatalErrorCode2["DocumentNotFound"] = "DOCUMENT_NOT_FOUND";
  FatalErrorCode2["UnexpectedState"] = "UNEXPECTED_STATE";
})(FatalErrorCode || (FatalErrorCode = {}));
var CollabStateName;
(function(CollabStateName2) {
  CollabStateName2["Fatal"] = "FATAL_STATE";
  CollabStateName2["Init"] = "INIT_STATE";
  CollabStateName2["InitDoc"] = "INIT_DOC_STATE";
  CollabStateName2["InitError"] = "INIT_ERROR_STATE";
  CollabStateName2["Pull"] = "PULL_STATE";
  CollabStateName2["Push"] = "PUSH_STATE";
  CollabStateName2["PushPullError"] = "PUSH_PULL_ERROR_STATE";
  CollabStateName2["Ready"] = "READY_STATE";
})(CollabStateName || (CollabStateName = {}));
function applySteps(view, payload, logger) {
  if (view.isDestroyed) {
    return;
  }
  const steps = (payload.steps ? payload.steps : []).map((j) => Step.fromJSON(view.state.schema, j));
  const clientIDs = payload.clientIDs ? payload.clientIDs : [];
  if (steps.length === 0) {
    logger("no steps", payload, "version", getVersion(view.state));
    return;
  }
  try {
    const tr = receiveTransaction(view.state, steps, clientIDs).setMeta("addToHistory", false).setMeta("bangle.dev/isRemote", true);
    const newState = view.state.apply(tr);
    view.updateState(newState);
  } catch (error) {
    console.error(error);
    return false;
  }
  logger("after apply version", getVersion(view.state));
  return true;
}
function applyDoc(view, doc, version, oldSelection) {
  if (view.isDestroyed) {
    return;
  }
  const prevSelection = view.state.selection instanceof TextSelection ? view.state.selection : void 0;
  let tr = replaceDocument(view.state, doc, version);
  const selection = oldSelection || prevSelection;
  if (selection) {
    let { from } = selection;
    if (from >= tr.doc.content.size) {
      tr = tr.setSelection(Selection.atEnd(tr.doc));
    } else {
      tr = tr.setSelection(Selection.near(tr.doc.resolve(from)));
    }
  }
  try {
    const newState = view.state.apply(tr.setMeta("bangle.dev/isRemote", true));
    view.updateState(newState);
  } catch (error) {
    console.error(error);
    return false;
  }
  return true;
}
function replaceDocument(state, serializedDoc, version) {
  const { schema, tr } = state;
  const content = (
    // TODO remove serializedDoc
    serializedDoc instanceof Node ? serializedDoc.content : (serializedDoc.content || []).map((child) => schema.nodeFromJSON(child))
  );
  const hasContent = Array.isArray(content) ? content.length > 0 : Boolean(content);
  if (!hasContent) {
    return tr;
  }
  tr.setMeta("addToHistory", false);
  tr.replaceWith(0, state.doc.nodeSize - 2, content);
  tr.setSelection(Selection.atStart(tr.doc));
  if (typeof version !== void 0) {
    const collabState = { version, unconfirmed: [] };
    tr.setMeta("collab$", collabState);
  }
  return tr;
}
function getCollabState(state) {
  var _a;
  return (_a = collabClientKey.getState(state)) === null || _a === void 0 ? void 0 : _a.collabState;
}
function queryFatalError() {
  return (state) => {
    const collabState = getCollabState(state);
    if (collabState === null || collabState === void 0 ? void 0 : collabState.isFatalState()) {
      return collabState.state;
    }
    return void 0;
  };
}
function queryCollabState() {
  return (state) => {
    const collabState = getCollabState(state);
    return collabState;
  };
}
function hardResetClient() {
  return (state, dispatch) => {
    const collabState = getCollabState(state);
    collabState === null || collabState === void 0 ? void 0 : collabState.dispatchCollabPluginEvent({
      signal: new AbortController().signal,
      collabEvent: {
        type: EventType.HardReset
      },
      debugInfo: "hard-reset"
    })(state, dispatch);
    return true;
  };
}
function updateServerVersion(serverVersion) {
  return (state, dispatch) => {
    const pluginState = collabMonitorKey.getState(state);
    if (!pluginState) {
      return false;
    }
    if (pluginState.serverVersion !== serverVersion) {
      const meta = { serverVersion };
      dispatch === null || dispatch === void 0 ? void 0 : dispatch(state.tr.setMeta(collabMonitorKey, meta));
      return true;
    }
    return false;
  };
}
function onLocalChanges() {
  return (state, dispatch) => {
    const collabState = getCollabState(state);
    if (collabState === null || collabState === void 0 ? void 0 : collabState.isReadyState()) {
      collabState === null || collabState === void 0 ? void 0 : collabState.dispatch(new AbortController().signal, state, dispatch, {
        type: EventType.Push
      }, "onLocalChanges");
      return true;
    }
    return false;
  };
}
function isOutdatedVersion() {
  return (state) => {
    var _a;
    const serverVersion = (_a = collabMonitorKey.getState(state)) === null || _a === void 0 ? void 0 : _a.serverVersion;
    return typeof serverVersion === "number" && getVersion(state) < serverVersion;
  };
}
function onOutdatedVersion() {
  return (state, dispatch) => {
    const collabState = getCollabState(state);
    if (collabState === null || collabState === void 0 ? void 0 : collabState.isReadyState()) {
      collabState.dispatch(new AbortController().signal, state, dispatch, {
        type: EventType.Pull
      }, "collabMonitorKey(outdated-local-version)");
      return true;
    }
    return false;
  };
}
function isStuckInErrorStates() {
  return (state) => {
    var _a;
    const previousStates = (_a = collabClientKey.getState(state)) === null || _a === void 0 ? void 0 : _a.previousStates;
    if (!previousStates) {
      return false;
    }
    return previousStates.filter((s) => s.isTaggedError).length > STUCK_IN_ERROR_THRESHOLD;
  };
}
var CollabBaseState = class {
  constructor() {
    this.isEditingBlocked = false;
    this.isTaggedError = false;
    this.createdAt = Date.now();
  }
  // A helper function to dispatch events in correct shape
  dispatchCollabPluginEvent(data) {
    return (state, dispatch) => {
      if (!data.signal.aborted) {
        dispatch === null || dispatch === void 0 ? void 0 : dispatch(state.tr.setMeta(collabClientKey, data));
        return true;
      }
      return false;
    };
  }
  isFatalState() {
    return this instanceof FatalState;
  }
  isReadyState() {
    return this instanceof ReadyState;
  }
};
var FatalState = class extends CollabBaseState {
  constructor(state, debugInfo) {
    super();
    this.state = state;
    this.debugInfo = debugInfo;
    this.isEditingBlocked = true;
    this.isTaggedError = true;
    this.name = CollabStateName.Fatal;
  }
  dispatch(signal, state, dispatch, event, debugInfo) {
    return this.dispatchCollabPluginEvent({
      signal,
      collabEvent: event,
      debugInfo
    })(state, dispatch);
  }
  async runAction({ signal, clientInfo, logger }) {
    if (signal.aborted) {
      return;
    }
    logger(`Freezing document(${clientInfo.docName}) to prevent further edits due to FatalState`);
    return;
  }
  transition(event, debugInfo) {
    return this;
  }
};
var InitState = class extends CollabBaseState {
  constructor(state = {}, debugInfo) {
    super();
    this.state = state;
    this.debugInfo = debugInfo;
    this.isEditingBlocked = true;
    this.name = CollabStateName.Init;
    this.clientCreatedAt = Date.now();
  }
  dispatch(signal, state, dispatch, event, debugInfo) {
    return this.dispatchCollabPluginEvent({
      signal,
      collabEvent: event,
      debugInfo
    })(state, dispatch);
  }
  async runAction({ clientInfo, signal, view }) {
    if (signal.aborted) {
      return;
    }
    const { docName, userId, clientCom } = clientInfo;
    const debugSource = `initStateAction:`;
    if (typeof clientInfo.warmupTime === "number") {
      await sleep(clientInfo.warmupTime);
      if (signal.aborted) {
        return;
      }
    }
    const result = await clientCom.getDocument({
      clientCreatedAt: this.clientCreatedAt,
      docName,
      userId
    });
    if (signal.aborted) {
      return;
    }
    if (!result.ok) {
      this.dispatch(signal, view.state, view.dispatch, {
        type: EventType.InitError,
        payload: { failure: result.body }
      }, debugSource);
      return;
    }
    const { doc, managerId, version } = result.body;
    this.dispatch(signal, view.state, view.dispatch, {
      type: EventType.InitDoc,
      payload: {
        doc: view.state.schema.nodeFromJSON(doc),
        version,
        managerId,
        selection: void 0
      }
    }, debugSource);
    return;
  }
  transition(event, debugInfo) {
    const type = event.type;
    if (type === EventType.InitDoc) {
      const { payload } = event;
      return new InitDocState({
        initialDoc: payload.doc,
        initialSelection: payload.selection,
        initialVersion: payload.version,
        managerId: payload.managerId,
        clientCreatedAt: this.clientCreatedAt
      }, debugInfo);
    } else if (type === EventType.InitError) {
      return new InitErrorState({
        failure: event.payload.failure
      }, debugInfo);
    } else {
      console.debug("@bangle.dev/collab-client Ignoring event" + type);
      return;
    }
  }
};
var InitDocState = class extends CollabBaseState {
  constructor(state, debugInfo) {
    super();
    this.state = state;
    this.debugInfo = debugInfo;
    this.isEditingBlocked = true;
    this.name = CollabStateName.InitDoc;
  }
  dispatch(signal, state, dispatch, event, debugInfo) {
    return this.dispatchCollabPluginEvent({
      signal,
      collabEvent: event,
      debugInfo
    })(state, dispatch);
  }
  async runAction({ signal, view }) {
    if (signal.aborted) {
      return;
    }
    const { initialDoc, initialVersion, initialSelection } = this.state;
    if (!signal.aborted) {
      const success = applyDoc(view, initialDoc, initialVersion, initialSelection);
      if (success === false) {
        this.dispatch(signal, view.state, view.dispatch, {
          type: EventType.Fatal,
          payload: {
            message: "Failed to load initial doc",
            errorCode: FatalErrorCode.InitialDocLoadFailed
          }
        });
      } else {
        this.dispatch(signal, view.state, view.dispatch, {
          type: EventType.Ready
        }, `runAction:${this.name}`);
      }
    }
  }
  transition(event, debugInfo) {
    const type = event.type;
    if (type === EventType.Ready) {
      return new ReadyState(this.state, debugInfo);
    } else if (type === EventType.Fatal) {
      return new FatalState({ message: event.payload.message, errorCode: event.payload.errorCode }, debugInfo);
    } else {
      console.debug("@bangle.dev/collab-client Ignoring event" + type);
      return;
    }
  }
};
var InitErrorState = class extends CollabBaseState {
  constructor(state, debugInfo) {
    super();
    this.state = state;
    this.debugInfo = debugInfo;
    this.isEditingBlocked = true;
    this.isTaggedError = true;
    this.name = CollabStateName.InitError;
  }
  dispatch(signal, state, dispatch, event, debugInfo) {
    return this.dispatchCollabPluginEvent({
      signal,
      collabEvent: event,
      debugInfo
    })(state, dispatch);
  }
  async runAction(param) {
    await handleErrorStateAction({ ...param, collabState: this });
  }
  transition(event, debugInfo) {
    const type = event.type;
    if (type === EventType.Restart) {
      return new InitState(void 0, debugInfo);
    } else if (type === EventType.Fatal) {
      return new FatalState({ message: event.payload.message, errorCode: event.payload.errorCode }, debugInfo);
    } else {
      console.debug("@bangle.dev/collab-client Ignoring event" + type);
      return void 0;
    }
  }
};
var ReadyState = class extends CollabBaseState {
  constructor(state, debugInfo) {
    super();
    this.state = state;
    this.debugInfo = debugInfo;
    this.name = CollabStateName.Ready;
  }
  dispatch(signal, state, dispatch, event, debugInfo) {
    return this.dispatchCollabPluginEvent({
      signal,
      collabEvent: event,
      debugInfo
    })(state, dispatch);
  }
  async runAction({ signal, view }) {
    if (signal.aborted) {
      return;
    }
    const debugString = `runActions:${this.name}`;
    if (!signal.aborted) {
      if (isOutdatedVersion()(view.state)) {
        this.dispatch(signal, view.state, view.dispatch, {
          type: EventType.Pull
        }, debugString + "(outdated-local-version)");
      } else if (sendableSteps(view.state)) {
        this.dispatch(signal, view.state, view.dispatch, {
          type: EventType.Push
        }, debugString + "(sendable-steps)");
      }
    }
    return;
  }
  transition(event, debugInfo) {
    const type = event.type;
    if (type === EventType.Push) {
      return new PushState(this.state, debugInfo);
    } else if (type === EventType.Pull) {
      return new PullState(this.state, debugInfo);
    } else {
      console.debug("@bangle.dev/collab-client Ignoring event" + type);
      return;
    }
  }
};
var PushState = class extends CollabBaseState {
  constructor(state, debugInfo) {
    super();
    this.state = state;
    this.debugInfo = debugInfo;
    this.name = CollabStateName.Push;
  }
  dispatch(signal, state, dispatch, event, debugInfo) {
    return this.dispatchCollabPluginEvent({
      signal,
      collabEvent: event,
      debugInfo
    })(state, dispatch);
  }
  async runAction({ clientInfo, signal, view }) {
    if (signal.aborted) {
      return;
    }
    const { docName, userId, clientCom } = clientInfo;
    const debugSource = `pushStateAction:`;
    const steps = sendableSteps(view.state);
    if (!steps) {
      this.dispatch(signal, view.state, view.dispatch, {
        type: EventType.Ready
      }, debugSource + "(no steps):");
      return;
    }
    const { managerId } = this.state;
    const response = await clientCom.pushEvents({
      clientCreatedAt: this.state.clientCreatedAt,
      version: getVersion(view.state),
      steps: steps ? steps.steps.map((s) => s.toJSON()) : [],
      // TODO  the default value numerical 0 before
      clientID: (steps ? steps.clientID : 0) + "",
      docName,
      userId,
      managerId
    });
    if (signal.aborted) {
      return;
    }
    if (response.ok) {
      this.dispatch(signal, view.state, view.dispatch, {
        type: EventType.Pull
      }, debugSource);
    } else {
      this.dispatch(signal, view.state, view.dispatch, {
        type: EventType.PushPullError,
        payload: { failure: response.body }
      }, debugSource);
    }
    return;
  }
  transition(event, debugInfo) {
    const type = event.type;
    if (type === EventType.Ready) {
      return new ReadyState(this.state, debugInfo);
    } else if (type === EventType.Pull) {
      return new PullState(this.state, debugInfo);
    } else if (type === EventType.PushPullError) {
      return new PushPullErrorState({
        failure: event.payload.failure,
        initDocState: this.state
      }, debugInfo);
    } else {
      console.debug("@bangle.dev/collab-client Ignoring event" + type);
      return;
    }
  }
};
var PullState = class extends CollabBaseState {
  constructor(state, debugInfo) {
    super();
    this.state = state;
    this.debugInfo = debugInfo;
    this.name = CollabStateName.Pull;
  }
  dispatch(signal, state, dispatch, event, debugInfo) {
    return this.dispatchCollabPluginEvent({
      signal,
      collabEvent: event,
      debugInfo
    })(state, dispatch);
  }
  async runAction({ clientInfo, logger, signal, view }) {
    if (signal.aborted) {
      return;
    }
    const { docName, userId, clientCom } = clientInfo;
    const { managerId } = this.state;
    const response = await clientCom.pullEvents({
      clientCreatedAt: this.state.clientCreatedAt,
      version: getVersion(view.state),
      docName,
      userId,
      managerId
    });
    if (signal.aborted) {
      return;
    }
    const debugSource = `pullStateAction:`;
    if (response.ok) {
      const success = applySteps(view, response.body, logger);
      if (success === false) {
        this.dispatch(signal, view.state, view.dispatch, {
          type: EventType.PushPullError,
          payload: { failure: CollabFail.ApplyFailed }
        }, debugSource + "(local-apply-failed)");
      } else {
        updateServerVersion(response.body.version)(view.state, view.dispatch);
        this.dispatch(signal, view.state, view.dispatch, {
          type: EventType.Ready
        }, debugSource);
      }
    } else {
      this.dispatch(signal, view.state, view.dispatch, {
        type: EventType.PushPullError,
        payload: { failure: response.body }
      }, debugSource);
    }
    return;
  }
  transition(event, debugInfo) {
    const type = event.type;
    if (type === EventType.Ready) {
      return new ReadyState(this.state, debugInfo);
    } else if (type === EventType.PushPullError) {
      return new PushPullErrorState({
        failure: event.payload.failure,
        initDocState: this.state
      }, debugInfo);
    } else {
      return;
    }
  }
};
var PushPullErrorState = class extends CollabBaseState {
  constructor(state, debugInfo) {
    super();
    this.state = state;
    this.debugInfo = debugInfo;
    this.isTaggedError = true;
    this.name = CollabStateName.PushPullError;
  }
  dispatch(signal, state, dispatch, event, debugInfo) {
    return this.dispatchCollabPluginEvent({
      signal,
      collabEvent: event,
      debugInfo
    })(state, dispatch);
  }
  async runAction(param) {
    await handleErrorStateAction({ ...param, collabState: this });
  }
  transition(event, debugInfo) {
    const type = event.type;
    if (type === EventType.Restart) {
      return new InitState(void 0, debugInfo);
    } else if (type === EventType.Pull) {
      return new PullState(this.state.initDocState, debugInfo);
    } else if (type === EventType.Fatal) {
      return new FatalState({ message: event.payload.message, errorCode: event.payload.errorCode }, debugInfo);
    } else {
      console.debug("@bangle.dev/collab-client Ignoring event" + type);
      return;
    }
  }
};
var handleErrorStateAction = async ({ clientInfo, view, logger, signal, collabState }) => {
  if (signal.aborted) {
    return;
  }
  const failure = collabState.state.failure;
  logger("Handling failure=", failure, "currentState=", collabState.name);
  const debugSource = `pushPullErrorStateAction(${failure}):`;
  if (isStuckInErrorStates()(view.state)) {
    collabState.dispatch(signal, view.state, view.dispatch, {
      type: EventType.Fatal,
      payload: {
        message: "Stuck in error loop, last failure: " + failure,
        errorCode: FatalErrorCode.StuckInInfiniteLoop
      }
    }, debugSource);
    return;
  }
  switch (failure) {
    case CollabFail.InvalidVersion: {
      abortableSetTimeout(() => {
        if (!signal.aborted) {
          collabState.dispatch(signal, view.state, view.dispatch, {
            type: EventType.Restart
          }, debugSource);
        }
      }, signal, clientInfo.cooldownTime);
      return;
    }
    case CollabFail.IncorrectManager: {
      collabState.dispatch(signal, view.state, view.dispatch, {
        type: EventType.Fatal,
        payload: {
          message: "Incorrect manager",
          errorCode: FatalErrorCode.IncorrectManager
        }
      }, debugSource);
      return;
    }
    case CollabFail.HistoryNotAvailable: {
      collabState.dispatch(signal, view.state, view.dispatch, {
        type: EventType.Fatal,
        payload: {
          message: "History/Server not available",
          errorCode: FatalErrorCode.HistoryNotAvailable
        }
      }, debugSource);
      return;
    }
    case CollabFail.DocumentNotFound: {
      logger("Document not found");
      collabState.dispatch(signal, view.state, view.dispatch, {
        type: EventType.Fatal,
        payload: {
          message: "Document not found",
          errorCode: FatalErrorCode.DocumentNotFound
        }
      }, debugSource);
      return;
    }
    case CollabFail.OutdatedVersion: {
      if (collabState instanceof PushPullErrorState) {
        collabState.dispatch(signal, view.state, view.dispatch, {
          type: EventType.Pull
        }, debugSource);
      } else {
        collabState.dispatch(signal, view.state, view.dispatch, {
          type: EventType.Fatal,
          payload: {
            message: `Cannot handle ${failure} in state=${collabState.name}`,
            // TODO: is this the right error code?
            errorCode: FatalErrorCode.UnexpectedState
          }
        }, debugSource);
      }
      return;
    }
    case CollabFail.ManagerDestroyed: {
      abortableSetTimeout(() => {
        if (!signal.aborted) {
          if (collabState instanceof PushPullErrorState) {
            collabState.dispatch(signal, view.state, view.dispatch, {
              type: EventType.Pull
            }, debugSource);
          } else if (collabState instanceof InitErrorState) {
            collabState.dispatch(signal, view.state, view.dispatch, {
              type: EventType.Restart
            }, debugSource);
          } else
            ;
        }
      }, signal, clientInfo.cooldownTime);
      return;
    }
    case CollabFail.ApplyFailed: {
      if (collabState instanceof PushPullErrorState) {
        abortableSetTimeout(() => {
          if (!signal.aborted) {
            collabState.dispatch(signal, view.state, view.dispatch, {
              type: EventType.Pull
            }, debugSource);
          }
        }, signal, clientInfo.cooldownTime);
      } else {
        collabState.dispatch(signal, view.state, view.dispatch, {
          type: EventType.Fatal,
          payload: {
            message: `Cannot handle ${failure} in state=${collabState.name}`,
            errorCode: FatalErrorCode.UnexpectedState
          }
        }, debugSource);
      }
      return;
    }
    case CollabFail.ManagerUnresponsive: {
      abortableSetTimeout(() => {
        if (!signal.aborted) {
          if (collabState instanceof PushPullErrorState) {
            collabState.dispatch(signal, view.state, view.dispatch, {
              type: EventType.Pull
            }, debugSource);
          } else if (collabState instanceof InitErrorState) {
            collabState.dispatch(signal, view.state, view.dispatch, {
              type: EventType.Restart
            }, debugSource);
          } else
            ;
        }
      }, signal, clientInfo.cooldownTime);
      return;
    }
    default: {
      throw new Error(`Unknown failure ${failure}`);
    }
  }
};
var LOG = true;
var log = (isTestEnv ? false : LOG) ? console.debug.bind(console, `collab-client:`) : () => {
};
var collabMonitorInitialState = {
  serverVersion: void 0
};
var INFINITE_TRANSITION_SAMPLE = 500;
var INFINITE_TRANSITION_THRESHOLD_TIME = 1e3;
function collabClientPlugin({ requestTimeout, clientID, collabMessageBus, docName, managerId, cooldownTime, userId, warmupTime }) {
  const logger = (state) => (...args) => {
    var _a;
    return log(`${clientID}:version=${getVersion(state)}:debugInfo=${(_a = collabClientKey.getState(state)) === null || _a === void 0 ? void 0 : _a.collabState.debugInfo}`, ...args);
  };
  return [
    new Plugin({
      key: collabClientKey,
      filterTransaction(tr, state) {
        var _a;
        if (tr.getMeta(collabClientKey) || tr.getMeta(collabMonitorKey) || tr.getMeta("bangle.dev/isRemote")) {
          return true;
        }
        if (tr.docChanged && ((_a = getCollabState(state)) === null || _a === void 0 ? void 0 : _a.isEditingBlocked) === true) {
          console.debug("@bangle.dev/collab-client blocking transaction");
          return false;
        }
        return true;
      },
      state: {
        init() {
          return {
            collabState: new InitState(),
            previousStates: [],
            infiniteTransitionGuard: { counter: 0, lastChecked: 0 }
          };
        },
        apply(tr, value, oldState, newState) {
          const meta = tr.getMeta(collabClientKey);
          if (meta === void 0 || !meta.collabEvent) {
            return value;
          }
          if (meta.collabEvent.type === EventType.HardReset) {
            logger(newState)("apply state HARD RESET, newStateName=", CollabStateName.Init, "oldStateName=", value.collabState.name);
            return {
              collabState: new InitState(void 0, "(HardReset)"),
              previousStates: [],
              infiniteTransitionGuard: { counter: 0, lastChecked: 0 }
            };
          }
          value.infiniteTransitionGuard.counter++;
          if (value.infiniteTransitionGuard.counter % INFINITE_TRANSITION_SAMPLE === 0) {
            if (Date.now() - value.infiniteTransitionGuard.lastChecked <= INFINITE_TRANSITION_THRESHOLD_TIME) {
              queueMicrotask(() => {
                throw new Error("Stuck in infinite transitions. Last few states: " + value.previousStates.map((s) => s.name + (s.debugInfo ? `:${s.debugInfo}` : "")).join(", ").slice(0, 5));
              });
              return {
                collabState: new FatalState({
                  message: "Infinite transitions",
                  errorCode: FatalErrorCode.StuckInInfiniteLoop
                }, "(stuck in infinite transitions)"),
                previousStates: [value.collabState, ...value.previousStates],
                infiniteTransitionGuard: { counter: 0, lastChecked: 0 }
              };
            }
            value.infiniteTransitionGuard.lastChecked = Date.now();
            value.infiniteTransitionGuard.counter = 0;
          }
          const newCollabState = value.collabState.transition(meta.collabEvent, meta.debugInfo);
          if (!newCollabState) {
            return value;
          }
          if (newCollabState.name !== value.collabState.name) {
            logger(newState)("apply state, newStateName=", newCollabState.name, `debugInfo=${newCollabState.debugInfo}`, "oldStateName=", value.collabState.name);
            let previousStates = [value.collabState, ...value.previousStates];
            if (previousStates.length > MAX_STATES_TO_KEEP) {
              previousStates = previousStates.slice(0, MAX_STATES_TO_KEEP);
            }
            return {
              ...value,
              collabState: newCollabState,
              previousStates
            };
          }
          logger(newState)(`applyState IGNORE EVENT ${meta.collabEvent.type} due to self transition`, `debugInfo=${meta.debugInfo}`);
          return value;
        }
      },
      view(view) {
        let actionController = new AbortController();
        let clientComController = new AbortController();
        let clientCom = new ClientCommunication({
          clientId: clientID,
          managerId,
          docName,
          messageBus: collabMessageBus,
          signal: clientComController.signal,
          requestTimeout,
          onNewVersion: ({ version }) => {
            updateServerVersion(version)(view.state, view.dispatch);
          },
          onResetClient() {
            hardResetClient()(view.state, view.dispatch);
          }
        });
        const pluginState = collabClientKey.getState(view.state);
        const clientInfo = {
          clientID,
          docName,
          cooldownTime,
          clientCom,
          managerId,
          userId,
          warmupTime
        };
        if (pluginState) {
          pluginState.collabState.runAction({
            clientInfo,
            view,
            signal: actionController.signal,
            logger: logger(view.state)
          });
        }
        return {
          destroy() {
            actionController.abort();
            clientComController.abort();
          },
          update(view2, prevState) {
            var _a;
            const pluginState2 = collabClientKey.getState(view2.state);
            if ((pluginState2 === null || pluginState2 === void 0 ? void 0 : pluginState2.collabState) === ((_a = collabClientKey.getState(prevState)) === null || _a === void 0 ? void 0 : _a.collabState)) {
              return;
            }
            if (pluginState2) {
              actionController.abort();
              actionController = new AbortController();
              pluginState2.collabState.runAction({
                clientInfo,
                view: view2,
                signal: actionController.signal,
                logger: logger(view2.state)
              });
            }
          }
        };
      }
    }),
    new Plugin({
      key: collabMonitorKey,
      props: {
        attributes: (state) => {
          var _a;
          const editingBlocked = (_a = getCollabState(state)) === null || _a === void 0 ? void 0 : _a.isEditingBlocked;
          return {
            class: editingBlocked ? "bangle-collab-frozen" : "bangle-collab-active"
          };
        }
      },
      state: {
        init: (_, _state) => {
          return collabMonitorInitialState;
        },
        apply: (tr, value, oldState, newState) => {
          var _a;
          const meta = tr.getMeta(collabMonitorKey);
          if (meta) {
            logger(newState)("collabMonitorKey received tr", meta);
            return {
              ...value,
              ...meta
            };
          }
          if (((_a = getCollabState(newState)) === null || _a === void 0 ? void 0 : _a.name) === CollabStateName.Init) {
            return collabMonitorInitialState;
          }
          return value;
        }
      },
      view(view) {
        const check = (view2) => {
          if (isOutdatedVersion()(view2.state)) {
            onOutdatedVersion()(view2.state, view2.dispatch);
          } else if (sendableSteps(view2.state)) {
            onLocalChanges()(view2.state, view2.dispatch);
          }
        };
        check(view);
        return {
          update(view2) {
            check(view2);
          }
        };
      }
    })
  ];
}
var plugins = pluginsFactory;
var commands = { queryFatalError, hardResetClient, queryCollabState };
function pluginsFactory({ requestTimeout, clientID = "client-" + uuid(), collabMessageBus, docName, managerId = DEFAULT_MANAGER_ID, cooldownTime = 100, warmupTime = 0 }) {
  const userId = "user-" + clientID;
  return [
    collab({
      clientID
    }),
    collabClientPlugin({
      requestTimeout,
      clientID,
      collabMessageBus,
      docName,
      managerId,
      cooldownTime,
      userId,
      warmupTime
    })
  ];
}
var collabExtension = Object.freeze({
  __proto__: null,
  plugins,
  commands
});
export {
  collabExtension as collabClient
};
//# sourceMappingURL=@bangle__dev_collab-client.js.map
